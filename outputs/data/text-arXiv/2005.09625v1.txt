arXiv:2005.09625v1 [q-bio.PE] 19 May 2020

Inference, prediction and optimization of
non-pharmaceutical interventions using
compartment models: the PyRoss library
R. Adhikari‚àó, Austen Bolitho, Fernando Caballero,
Michael E. Cates, Jakub Dolezal, Timothy Ekeh, Jules Guioth,
Robert L. Jack, Julian Kappler, Lukas Kikuchi, Hideki Kobayashi,
Yuting I. Li, Joseph D. Peterson, Patrick Pietzonka, Benjamin Remez,
Paul B. Rohrbach, Rajesh Singh, and G√ºnther Turk
University of Cambridge, United Kingdom

‚àó

ra413@cam.ac.uk

PyRoss1 is an open-source Python library that offers an integrated platform for inference, prediction and optimisation of non-pharmaceutical interventions in age- and contactstructured epidemiological compartment models. This report outlines the rationale and
functionality of the PyRoss library, with various illustrations and examples focusing on wellmixed, age-structured populations. The PyRoss library supports arbitrary age-structured
compartment models formulated stochastically (in terms of master equations) or deterministically (as systems of differential equations) and allows mid-run transitioning from one
to the other. By supporting additional compartmental subdivision ad libitum, PyRoss can
emulate time-since-infection models and allows medical stages such as hospitalization or
quarantine to be modelled and forecast. The PyRoss library enables fitting to epidemiological data, as available, using Bayesian parameter inference, so that competing models
can be weighed by their evidence. PyRoss allows fully Bayesian forecasts of the impact of
idealized non-pharmaceutical interventions (NPIs) by convolving uncertainties arising from
epidemiological data, model choice, parameters, and intrinsic stochasticity. Algorithms to
optimize time-dependent NPI scenarios against user-defined cost functions are included.
PyRoss‚Äôs current age-structured compartment framework for well-mixed populations will
in future reports be extended to include compartments structured by location, occupation,
use of travel networks and other attributes relevant to assessing disease spread and the
impact of NPIs. We argue that such compartment models, by allowing social data of arbitrary granularity to be combined with Bayesian parameter estimation for poorly-known
disease variables, could enable more powerful and robust prediction than other approaches
to detailed epidemic modelling. We invite others to use the PyRoss library for research to
address today‚Äôs COVID-19 crisis, and to plan for future pandemics.

1

https://github.com/rajeshrinet/PyRoss

2

Contents
1 Introduction
1.1 Rationale for compartment models . . . . . .
1.2 NPIs and compartment structure . . . . . . .
1.3 Limitations . . . . . . . . . . . . . . . . . . .
1.4 Bayesian parameter inference and forecasting
1.5 Optimising the outcomes of NPIs . . . . . . .
1.6 Provenance . . . . . . . . . . . . . . . . . . .
1.7 Remaining chapters . . . . . . . . . . . . . . .

.
.
.
.
.
.
.

2 Inference, Prediction and Optimized Intervention
2.1 Compartment models . . . . . . . . . . . . . .
2.2 Age structure and contact matrices . . . . . .
2.3 Modelling and optimizing NPIs . . . . . . . .

for
. .
. .
. .

3 Techniques
3.1 Discrete-state continuous-time Markov process
3.2 Approximations . . . . . . . . . . . . . . . . . .
3.2.1 Diffusion limit and the ‚Ñ¶-expansion . .
3.2.2 Deterministic limit . . . . . . . . . . . .
3.3 Inference . . . . . . . . . . . . . . . . . . . . . .
3.3.1 Non-stationary Gauss-Markov process .
3.3.2 Parameter inference . . . . . . . . . . .
3.3.3 Latent variables . . . . . . . . . . . . . .
3.3.4 Model evidence . . . . . . . . . . . . . .
3.3.5 Nested sampling . . . . . . . . . . . . .
3.4 Tangent space inference . . . . . . . . . . . . .
3.5 Prediction . . . . . . . . . . . . . . . . . . . . .
3.5.1 Posterior predictive distributions . . . .
3.5.2 Data uncertainty . . . . . . . . . . . . .
3.5.3 Parameter uncertainty . . . . . . . . . .
3.5.4 Model uncertainty . . . . . . . . . . . .
3.5.5 Model averaging . . . . . . . . . . . . .
3.6 Interventions . . . . . . . . . . . . . . . . . . .
3.6.1 Non-pharmaceutical interventions (NPI)

3

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

5
5
6
7
7
8
9
9

Compartment Models
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .

11
11
11
13

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

15
15
16
16
17
17
18
19
19
20
21
22
23
24
24
26
26
27
27
27

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Contents

3.7

3.6.2 Intervention protocols . . . . . . . .
3.6.3 Bayesian forecast of NPI . . . . . . .
3.6.4 Optimised intervention parameters .
Numerical methods . . . . . . . . . . . . . .
3.7.1 Exact sampling . . . . . . . . . . .
3.7.2 Acceleration by œÑ -leaping . . . . . .
3.7.3 Integration in the deterministic limit

4 Bestiary
4.1 SIR . . . . . . . . . . . . . . . .
4.2 SIR with stages (SIkR) . . . . .
4.3 SIIR . . . . . . . . . . . . . . .
4.4 SEIR . . . . . . . . . . . . . . .
4.5 SEIR with stages (SEkIkR) . .
4.6 SEIIR . . . . . . . . . . . . . .
4.7 SEIIR with stages (SEkIkIkR) .
4.8 SEAIIR . . . . . . . . . . . . .
4.9 SEAI8R . . . . . . . . . . . . .
4.10 SEAIIRQ . . . . . . . . . . . .
4.11 SIIRS . . . . . . . . . . . . . .
4.12 Generic user-defined model . .

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

5 Applications
5.1 Basic reproductive ratio R0 from local rate of growth
5.2 Beyond R0 : Kreiss constant K(J ) . . . . . . . . . .
5.3 Stochastic sampling . . . . . . . . . . . . . . . . . .
5.4 Deterministic integration . . . . . . . . . . . . . . . .
5.5 Bayesian inference and forecasting . . . . . . . . . .
5.6 Effect of event-driven NPI . . . . . . . . . . . . . .
5.7 Optimising parameters of NPI . . . . . . . . . . . . .
5.8 Model sensitivity . . . . . . . . . . . . . . . . . . . .
6 Conclusion

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

28
29
29
30
30
31
31

.
.
.
.
.
.
.
.
.
.
.
.

33
33
35
35
36
37
38
39
41
41
43
44
45

.
.
.
.
.
.
.
.

47
47
49
53
54
56
59
63
70
73

4

1 Introduction
This report introduces PyRoss, a Python library for inference, forecasting and optimisation of non-pharmaceutical interventions (NPIs), using compartment models of epidemics.
These models are very widely used in epidemiology [1‚Äì3], including simple examples such
as SIR, but also more complicated variants [4‚Äì7], some of which are discussed further below. The central modelling philosophy is to group individuals into compartments, which
correspond to disease states (such as susceptible / infectious) and may be further divided
by age, and by objective medical states (for example, seropositive, hospitalized, in ICU, on
ventilator). This leads to a broad class of models that are intermediate in detail between
simple compartment models (such as SIR [1]) and agent-based or similar models where the
population is disaggregated into synthetic individuals [8].
The functionality of PyRoss not only includes simulation of such compartment models,
but also automates inference of their parameters from data, and construction of Bayesian
forecasts. In addition, it offers framework for modelling NPIs, and optimisation of their
parameters (for example, the length of a lockdown) against user-defined cost functions.
While the simulation aspects of PyRoss may be comparable to those available elsewhere
(such as epiModel [9]), its integration of inference and optimisation engines create enhanced
functionality within a unified and relatively transparent open-source coding environment.

1.1 Rationale for compartment models
PyRoss is built around Markovian compartment models, in which a system‚Äôs future evolution depends only on the current occupancies of the compartments. This leads to several
useful simplifications -- the average dynamics of a large population can be obtained by
solving a system of ordinary differential equations, and the stochastic dynamics of a finite
population can be simulated by a simple (Markovian) stochastic process. On the other
hand, such models are sometimes criticised [2] because they result in exponential distributions of residence times in each compartment, which is often inconsistent with realistic
disease progression. To address this, time-since-infection (TSI) models may be used [2, 10‚Äì
15].
Nevertheless, the behaviour of TSI models can be captured by compartment models,
at the modest cost of introducing additional compartments. This is called the method of
stages [4‚Äì7]. In stochastic modelling, it amounts to replacing a non-Markovian model by
a Markovian one on a larger space (which here is a model with extra compartments). PyRoss supports an unlimited number of compartments, which achieves high generality while

5

1 Introduction
retaining the conceptual and computational advantages of compartment models. Subdivision of a compartment into k stages, even for modest values such as k = 5, already allow
considerable flexibility in capturing non-Markovian distributions of residence times within
different disease states. Larger values of k can of course be used, if required.
Lifting any restriction on the number of compartments has advantages beyond the TSI
issue just described. For example, the medical data used to infer parameters is often provided in the form of compartment populations, such as ICU occupancy or serological test
data (perhaps segregated by age). The observed population of these added compartments
can then inform the parameters of the model, improving predictions of the future prevalence of these (and other) outcomes. This is valuable when, as with COVID-19, avoiding
saturation of ICU or ventilator provision is a policy objective.
One standard use of compartment models is to address age-structured populations. Crucially, this resolves the assortative character of social contacts through which disease transmission occurs. By compartmenting into age bands, representing the contact rates between
each pair of bands in terms of a contact matrix, and partitioning this matrix further into
home- based, school-based, workplace-based and ‚Äòother‚Äô components (on which NPIs have
separately estimable effects) one can, within a well-mixed population model, prediction
epidemic evolution and NPIs outcomes in countries with different demographic and societal
structures. Indeed the first use of PyRoss was to make such predictions for COVID-19 in
India [16] where three-generation households are widespread. More generally, resolving the
age structure of an epidemic is clearly essential in modelling diseases whose transmission
and/or morbidity shows a strong age-dependence.

1.2 NPIs and compartment structure
NPIs are modelled in PyRoss using either user-specified or inference-based modifications
to the contact matrices. For instance the closure of schools reduces the matrix elements
between school-going age groups by the school-based contact contribution. It is clear in this
context that subdivision to resolve the contact matrix more finely (for instance, splitting
work environments by occupation or sector, and adding retail, catering and entertainment
contributions) would improve predictive power. Such models could address the fact that
NPIs such as social distancing will have different efficacies (and also different costs, see
below) in each context. Although PyRoss currently implements only home, school and
work compartments, finer subdivision requires no fundamental change to its structure.
A further extension of PyRoss adds a compartment-based treatment of spatial structure
whereby locally well-mixed populations in different neighbourhoods exchange individuals
by means of additional, reversibly populated compartments describing a ‚Äúcommuterverse‚Äù.
The resulting codebase, PyRossGeo 1 , which has been implemented for a model of Greater
London, will be the subject of a separate report. As described there, this approach to spatial
1

https://github.com/lukastk/PyRossGeo

6

1 Introduction
modelling could offer advantages over agent-based and other approaches, particularly in
mid-epidemic where disease dynamics may become effectively deterministic even at local
scale (at least in a city as densely populated as London).

1.3 Limitations
Of course, compartment models are not universally applicable. One drawback emerges on
considering strong lockdown scenarios in which transmission between households becomes
extremely low. This violates the concept of a well-mixed population; disease cannot spread
no matter how high the intra-household contact rate. However, it seems plausible that by
transferring attention from individuals to households (each described as a set of several
individuals that becomes exposed when any one of them is infected) a compartment model
for this situation could also be developed. Challenges also arise in modeling track-and-test,
quarantine and other individually resolved NPIs, but we suspect some of these challenges
can also be overcome by careful compartment design.
We surmise that the full potential of compartment models in epidemic modelling remains
unrealized. To help achieve this potential, the PyRoss library currently supports general
age-structured compartment models formulated stochastically (in terms of so-called ‚Äòchemical master equations‚Äô or CMEs) or deterministically (as systems of differential equations).
The library can automatically switch between stochastic and deterministic descriptions such
that the more expensive stochastic sampling is used when compartment numbers are small,
as they are in the early and late stages of an epidemic, while the less expensive deterministic
sampling is used when compartment numbers are large, as they are near the peak of the
epidemic, at least within well-mixed models. This allows for accurate and efficient sampling
of entire epidemiological trajectories taking into account the intrinsic stochasticity of the
transmission process.
Perhaps the greatest limitation of compartment models is the tendency toward proliferation within such models of large numbers of parameters to describe the transition rates
between compartments, many of which cannot be directly measured. A disciplined methodology for parameter estimation is then essential.

1.4 Bayesian parameter inference and forecasting
Accordingly, PyRoss supports fitting to epidemiological (and other) data using Bayesian
parameter inference and model selection. We use the Gauss-Markov limit of the discretestate continuous-time Markov process described by the relevant chemical master equation
for this purpose. Then, the standard machinery of Gaussian process regression can be used
to infer parameters. The kernels of the Gaussian process are adapted, via the Gauss-Markov
limit, to the models being fitted and these adapted kernels are obtained from the solution
of systems of ordinary differential equations. The numerous advantages of Gaussian process

7

1 Introduction
regression, in particular tractable inference and the ability to admit latent variables, accrue
automatically. The Bayesian model evidence, necessary for model comparison, model selection and model averaging, alongside the Fisher information matrix, necessary for assessing
parameter sensitivities, are thereby obtained in PyRoss without the need for computationally expensive sampling methods such as Markov Chain Monte Carlo.
Within PyRoss the future course of an epidemic can be predicted, with Bayesian confidence estimation, from models fitted to data gathered up to the present. These forecasts
take into the account uncertainties in data, the epidemiological parameters, choice of models, and the intrinsic stochasticity of the transmission. The Bayesian methodology is known
to provide a principled way of managing uncertainty [17, 18], which is inherent in epidemic
modelling and prediction.
Bayesian methods also defend against over-fitting, which is a risk in all models with
large numbers of parameters. For instance, the CovidSim model of [19] has, we estimate,
over 600 parameters, many of which are not readily accounted for even after geographical,
social and other data inputs are identified. Over-fitted models, containing parameters
unconstrained by data, are liable to be precise but inaccurate forecasters, particularly under
data-poor conditions as is currently the case for COVID-19. In contrast, relatively simple
compartment models can be adequate forecasters under these same conditions. An appendix
to this report gives a tutorial discussion of the Bayesian approach to this topic for the benefit
of those unfamiliar with it.

1.5 Optimising the outcomes of NPIs
NPIs such as lockdown or social distancing each carry a cost (including, but not limited
to, economic, medical, social and ethical costs). This can differ substantially between interventions. For measures that treat different age groups differently, age-structured models
can be used to assess the their differential impact. Similar remarks apply to other types
of compartmenting in more general models, for instance by geographic, social or industrial
sector, as we plan to consider in subsequent reports.
By representing NPIs through their effects on contact matrices, PyRoss can provide
Bayesian forecasts of the impact of specific interventions (albeit limited in the currently
implemented examples to the age-structured case). Intervention strategies that extremise
imputed costs can then be found without leaving the platform.
The optimisation methodology provided within PyRoss a principled way of minimising
harm in sustained application of NPIs. The exact definition of ‚Äòharm‚Äô is of course controversial and subjective. To create a well posed optimization problem, the first step is
formulation of a cost function which encodes mathematically how one type of harm (such
as fatalities) is weighed against another (such as unemployment). For obvious reasons,
PyRoss leaves the choice of cost function to the user, although a schematic example of the
approach is described later in this report.

8

1 Introduction

1.6 Provenance
PyRoss is named after Sir Ronald Ross, doctor, mathematician and poet. In 1898 he made
"the great discovery" in his laboratory in Calcutta "that malaria is conveyed by the bite of
a mosquito". Ross won the Nobel Prize for Physiology or Medicine in 1902 and helped lay
the foundations of the mathematical modelling of infectious diseases.
As previously mentioned, PyRoss was initially developed to study the age-structured
impact of social distancing on the COVID-19 epidemic in India [16]. Currently it is being
developed by the authors of this report who form a task team of the RAMP initiative (Rapid
Assistance in Modelling the Pandemic) coordinated by the Royal Society. The library can be
used directly to study the transmission, and mitigation through NPIs, of infectious diseases
for any well mixed demographic where age and social contact structures are available.
As described already, extensions to more general compartment models are either nearing
completion (PyRossGeo), or readily envisaged within the same coding structure. More will
be added as resources allow.
Compartment models in epidemiology have a long history and while a number of references are cited below, we have not had time to survey the literature as thoroughly as
we would like in preparing this report. Some parts may therefore cover territory familiar
to experts, but our aim here is to present PyRoss to a wider scientific community as an
open-source, well coded Python library that combines the flexibility and generality of agestratified (and prospectively more general) compartment models with appropriate inference
and optimization tools. We hope this resource might prove equally valuable to seasoned
epidemic modellers and to the many now entering the field for the first time.

1.7 Remaining chapters
The remainder of this report is structured as follows. In Chapter 2 we provide an overview of
metapopulation models of infectious diseases, focussing on age and contact structures. We
then sketch a pipeline where models and epidemiological data can be combined, forecasts
can be made, and the impact of interventions can be studied in a fully Bayesian manner. In
Chapter 3 we outline the theory of inference, prediction, and optimal control of the abstract
Markovian epidemic where the pipeline of the preceding chapter can be feasibly realised. In
Chapter 4 we provide a bestiary of epidemiological compartment models that illustrate but
by no means exhaust PyRoss‚Äôs capabilities for model construction. We discuss compartment
subdivision to allow non-exponentially distributed infectious periods and also to uncouple
combinations of rate parameters that would otherwise not be independent. Although the
specific examples we discuss have been hard-optimized for the PyRoss library, we also
describe how user-defined models can be implemented with only mildly reduced efficiency
while retaining full use of the surrounding inference and optimisation tools. In Chapter
5 we present several fully coded worked examples in PyRoss, touching upon sampling,
inference, prediction, control and optimal control. As in the preceding chapter, our purpose

9

1 Introduction
is illustrative and focuses on simple rather than fully realistic cases. We conclude in Chapter
6 with a brief summary.

10

2 Inference, Prediction and Optimized
Intervention for Compartment Models
We now specify in more detail the types of model PyRoss currently implements and outline
how these form part of an integrated inference, prediction and optimization pipeline, shown
schematically in Fig. 2.0.1.

2.1 Compartment models
PyRoss is designed to simulate structured epidemiological compartment models. The basic
variable in this class of models is a metapopulation labeled by its epidemiological state
(susceptible, infectious, recovered/removed, etc.,) and additional attributes like age, gender, geographic location and so on [1, 2, 20‚Äì22]. These additional attributes define the
structure of the model. The user can specify more disease-state compartments than is
traditional, and examples described later in this report include not only susceptible (S),
infectious (I), exposed (E), quarantined (Q) and recovered/removed (R) states but also,
for example, subdivisions of I into asymptomatic and symptomatic, with the latter further
divided into hospitalized and in intensive care. Additionally, the infectious class or classes
can be subdivided into k time stages [4‚Äì7] to approximate fixed overall residence times as
described in Chapter 1. Similar latent compartments can also be used to overcome other
constraints on the disease dynamics that arise from a few-compartment approach.
The compartment subdivision scheme exploits PyRoss‚Äôs efficient representation of transitions between compartments as Markovian jump processes of given rate. This means that
the residence time in any (sub-)compartment is exponentially distributed unless the jump
rates themselves vary in time (as they do if an NPI regime is changed). The time evolution of the compartment occupancy variables are accordingly described by chemical master
equations with time-dependent rates and, when compartmental fluctuations are small so
that deterministic dynamics arises, by ordinary differential equations.

2.2 Age structure and contact matrices
An infectious disease is spread by social contacts which are typically assortative in age
[1, 23]. Therefore, it is important to account for the country-specific age and social contact
structures when modelling the spread of infection. Also, in diseases where morbidity and

11

2 Inference, Prediction and Optimized Intervention for Compartment Models

Figure 2.0.1: Inference, prediction and intervention framework in PyRoss. For
explanations of mathematical symbols see Chapter 3.
Country

Basic reproductive ratio

UK

R0 = 82Œ≤

Italy

R0 = 119Œ≤

India

R0 = 136Œ≤

Table 2.1: Country-specific basic reproductive ratio of the age-structured SIR model for
fixed probability of infection on contact Œ≤ and recovery rate Œ≥ = 1/7.
mortality are strongly age-dependent, as with COVID-19, it is important not only to know
how many people are likely to be infected but also how they are distributed in age. For
example, India is one of the few countries in the world with a high prevalence of threegeneration households. This poses a large risk to the elderly, as they are more likely to
catch the disease from second- and third-generation members of the household with greater
social contacts. PyRoss has already provided the first age-structured forecasts of morbidity
and mortality of the COVID-19 epidemic in India [16] and can do so for any community
in which the appropriate age stratified contact structure is available, including the 152
countries reported in [24]; see Fig. 2.2.1 for examples.
The resulting differences between countries can be substantial. For instance, with a
simple SIR model [1‚Äì3, 25], the difference between age and contact structures in UK and
India leads to a basic reproduction ratio R0 that is more than 50 percent higher in the
latter case; see Table 2.1. This of course means that identical NPIs could suppress the
epidemic in one country and fail completely to do so in another. (For similar reasons it
could fail in cities but succeed in the countryside, for example.)

12

2 Inference, Prediction and Optimized Intervention for Compartment Models

Figure 2.2.1: Age and contact structures of the populations of UK (top), Italy and
India (bottom). The first column shows population pyramids by age and
gender. The second third and fourth columns show the contact structures in
households, workplaces and schools respectively. The darker colours represent
greater contacts. Taken from [24].

2.3 Modelling and optimizing NPIs
The purpose of many NPIs, such as lockdown and social distancing, is to reduce either the
frequency of social contacts or the transmission rates at each contact. Absorbing the latter
into the former, such NPIs simply alter the contact matrix. Age-structured models can
therefore address age-structured NPIs; the examples in this report are limited to such cases,
retaining for simplicity the simplest three-way breakdown of contact spaces (Fig. 2.2.1). As
mentioned in Chapter 1, further compartmenting in principle allows resolution of NPIs
that affect specific subsets of social contacts, such as closing restaurants or public transport
systems, without raising major issues of principle.
An obvious example is schools closure, an NPI for which the schools channel of the

13

2 Inference, Prediction and Optimized Intervention for Compartment Models
contact matrix is set to zero ‚Äì or perhaps some nonzero multiplier of its normal value to
describe partial opening. Another simple case is a phased unlock stratified by age-bands.
A model with additional structure, such as workplaces stratified by occupation or sector,
should allow the outcome of more nuanced NPIs to be predicted in the same way.
In PyRoss, we partition contacts into spheres of home, workplace, school and all other
categories, such that the contact matrix can be written as
H
W
S
O
Cij (t) = aH (t)Cij
+ aW (t)Cij
+ aS (t)Cij
+ aO (t)Cij
.

(2.3.1)

The social contact matrix Cij denotes the average number of contacts made per day by an
individual in class i with an individual in class j. Clearly, the total number of contacts
between group i to group j must equal the total number of contacts from group j to group
i, and thus, for populations of fixed size the contact matrices obey the reciprocity relation
Ni Cij = Nj Cji [26, 27], where Ni is the population in age-group i.
In general, PyRoss expects NPIs to be represented by time-dependent contact matrices.
Its inference platform for learning from data is structured accordingly to infer time dependent parameters where appropriate. For example, sufficient age-stratified disease data
spanning an initially unlocked and subsequently locked-down state, should allow Bayesian
prediction of the effects not just of full unlock but of a partial unlock comprising school
closure plus home sequestration of people over 70 (say). There are clearly limitations to
this, in that the effect of a completely novel intervention cannot be predicted without prior
knowledge of its likely effects on contact matrices. However such priors might be provided
by expert judgement. Then, upon actually starting the intervention, incoming data can
refine and update model parameters to give increasingly confident prediction of its future
effects.
For policy purposes it is obviously desirable to allow objective comparison of alternative
NPIs. PyRoss supports user-defined cost functions to allow this. Intervention strategies
that extremise the chosen cost function can then be found using optimization tools which
are built into PyRoss as detailed in Chapter 3.

14

3 Techniques
In this chapter, we describe age-structured epidemiological compartment models formulated
as discrete-state continuous-time Markov processes. We present the chemical master equation (CME) that describes such processes and then provide the diffusion and Gauss-Markov
approximations of the process. The Gauss-Markov approximation is used for Bayesian
parameter inference and to compute the model evidence. Bayesian posterior predictive
distributions are used to provide forecasts given epidemiological data. Such forecasts convolve uncertainties arising from epidemiological data, parameters, models, and intrinsic
stochasticity. Non-pharmaceutical interventions (NPI) are imposed by altering the contact
structures of the models. Incorporating uncertainties, a Bayesian forecast of the effect of
such interventions can be obtained. The protocol of the NPI - defined for instance by
points of triggering and its duration - can be optimized by extremizing a supplied cost
function. This sequence of inference, prediction and intervention can be applied iteratively
with the arrival of newer data, as shown pictorially in Fig.(2.0.1), leading to improved
epidemiological compartment models.

3.1 Discrete-state continuous-time Markov process
We consider a structured metapopulation
n = (n1 , . . . nL√óM )

(3.1.1)

consisting of L classes of epidemiological states and M age-compartments. The Œæ-th transition between compartments can be written down in its most general form as
wŒæ

Œæ-th transition step: n ‚àí‚Üí n + r Œæ

(3.1.2)

where r Œæ is the vector of change and wŒæ is the rate for the transition Œæ. This gives the
chemical master equation (CME) for the evolution of joint distribution over states P (n, t)
:
X
‚àÇt P (n, t) =
[wŒæ (t, Œ∏, n ‚àí r Œæ )P (n ‚àí r Œæ , t) ‚àí wŒæ (t, Œ∏, n)P (n, t)] .
(3.1.3)
Œæ

Here Œ∏ = (Œ∏1 , . . . , Œ∏k ) is the set of parameters for transitions between the states. The
CME describes a discrete-state continuous-time Markov process on the positive integers.
The CME resists solution for all but the simplest form of the transition rates, which can

15

3 Techniques
be at most linear. Since the transmission of contagion necessarily involves the contact of,
at least, pairs the rates in epidemiological models cannot be linear. Numerical sampling,
or, analytical approximations become necessary to extract model behavior from the CME.
We describe the analytical approximations in the next section and numerical sampling in
Section (3.7).

3.2 Approximations
The family of approximations we consider here replaces the discrete-state continuous-time
Markov process by a continuous-time continuous-state Markov process. In this diffusion
limit, the transitions n ‚Üí
‚àí n + r Œæ in the discrete state space n are replaced by transitions
x‚Üí
‚àí x+dr, in a continuous state space x with continuous increments dr and appropriately
chosen rates. The continuous state x is usually the discrete state rescaled by the size of
the population, x = n/N . This makes it apparent that the diffusion
approximation is
PM
appropriate when the population size N is large. Here N =
i=1 Ni and Ni is total
population in the age-group i = 1, 2, . . . M .

3.2.1 Diffusion limit and the ‚Ñ¶-expansion
Formally, the diffusion limit is obtained by truncating the Kramers-Moyal expansion of the
CME to second order. The theorem due to Pawula [28] constrains this truncation to be the
only one that yields positive-definite probability distributions. The result is the so-called
chemical Fokker-Planck equation (CFPE) with drift and diffusion coefficients that are jump
moments of the transition rates of the CME [29, 30]:

‚àÇt P (x, t) = L(t, Œ∏, x)P (x, t),

L=‚àí

‚àÇ
‚àÇ2
Ai (t, Œ∏, x) + 12
Bij (t, Œ∏, x),
‚àÇxi
‚àÇxi ‚àÇxj

(3.2.1)

where
A(t, Œ∏, x) =

X

r Œæ wŒæ (t, Œ∏, x),

(3.2.2)

r Œæ r Œæ wŒæ (t, Œ∏, x).

(3.2.3)

Œæ

B(t, Œ∏, x) =

X
Œæ

The equivalent It√¥ stochastic differential equation (SDE) is,
dx = A(t, Œ∏, x)dt + œÉ(t, Œ∏, x) ¬∑ dW
where œÉ is such that œÉœÉ T = B and W is a L √ó M dimensional Wiener process with zero
mean and unit variance.

16

3 Techniques
The diffusion approximation yields an Ito process with configuration-dependent noise. A
further approximation due to Van Kampen decomposes the diffusion process into a mean
process without noise and a fluctuation which is described by a time-dependent OrnsteinUhlenbeck process. The resulting process is both Markovian and Gaussian. In this linear
noise approximation (LNA), the state is expressed as,
1
x(t) = x0 (t) + ‚àö x1 (t)
‚Ñ¶
where ‚Ñ¶ = N is the system size. The two components satisfy

(3.2.4)

dx0 (t) = A(t, Œ∏, x0 )dt,

(3.2.5)

dx1 = J (t, Œ∏, x0 ) ¬∑ x1 dt + œÉ(t, Œ∏, x0 ) ¬∑ dW ,

(3.2.6)

where
Jij (t, Œ∏, x0 ) = ‚àÇj Ai (t, Œ∏, x)

x=x0

is the time-dependent Jacobian evaluated at x0 (t). The lowest order term x0 describes
the mean evolution whereas the next order term x1 characterises the Gaussian fluctuation around the deterministic trajectory. The fluctuation x1 is a non-stationary Ornstein
Uhlenbeck process whose mean and variance can be obtained for any point on the mean
trajectory.
As a note of caution, there are some subtleties associated with whether the high order
terms can grow significantly over time. This is particularly relevant to us as the growth is
exponential at the early stage of an epidemic, where the approximation is not likely to be
good.

3.2.2 Deterministic limit
From the ‚Ñ¶-expansion, we obtain the deterministic limit for free as the evolution of the
mean xÃÑ = x0 + x1 . It is simple to show that the mean obeys the same equation as x0 ,
dxÃÑ
= A(t, Œ∏, xÃÑ)
dt
In pyross.deterministic, the rescaling of Œ≤ is built in to suit simulations with both intensive
and extensive variables.

3.3 Inference
In this section, we describe inference of parameters Œ∏ = (Œ∏1 , . . . , Œ∏k ) performed by the
pyross.inference module. The data consists of the time series
X = {xi (tŒΩ ) | i = 1, . . . M √ó L; ŒΩ = 1, . . . Nt }

17

(3.3.1)

3 Techniques
of the values of the components xi (tŒΩ ) at the times tŒΩ . The module is capable of inferring
the parameters with full and partial information; in the latter case, the latent variables
are also inferred. The module determines Bayesian credible intervals for the inferred parameters, which can be supplied to pyross.forecast to perform Bayesian forecasting with
both parameter uncertainty and inherent stochasticity. In the future, mode selection will
be added to pyross.inference to measure how well the various epidemiological models fit the
data.

3.3.1 Non-stationary Gauss-Markov process
Consider the time interval (tŒΩ , t¬µ ) with initial condition x(tŒΩ ) = x0 . The outcome of
the ‚Ñ¶-expansion is a Gauss-Markov process, implying that the conditional probability
P1|1 (x, t¬µ |x0 , tŒΩ ) follows a Gaussian distribution determined uniquely by its conditional
mean xÃÑ(t¬µ ) = hx(t¬µ )|x0 i and conditional variance, denoted as Œ£ [31].
x, t¬µ |x0 , tŒΩ ‚àº N (xÃÑ(t¬µ ), Œ£(t¬µ ))
Recall from section 3.2.2 that the mean obeys the deterministic equation,
dxÃÑ
= A(t, Œ∏, xÃÑ)
dt
with the initial condition xÃÑ(tŒΩ ) = x0 , which can be solved numerically with pyross.deterministic
. The conditional variance, defined as,
Œ£(t) = x(t)xT (t)|x0 , tŒΩ ‚àí xÃÑ(t)xÃÑ(t)T
only has contributions from the fluctuating term x1 since x0 evolves deterministically,
Œ£(t) =


1 1
x (t)(x1 )T (t)|0, tŒΩ
‚Ñ¶

where we note that the mean of x1 remains zero as long as we choose x1 (tŒΩ ) = 0 (which
can always be done as the splitting of the initial condition x‚Äô into x0 and x1 is arbitrary).
It is a well established result that the covariance of an Ornstein-Uhlenbeck process evolves
according to the time-dependent differential Lyapunov equation [29, 30],
Œ£Ãá(t) = J (xÃÑ(t), t)Œ£(t) + Œ£(t)J T (xÃÑ(t), t) + B(xÃÑ(t), t)/‚Ñ¶

(3.3.2)

For our models of interest, the Lyapunov equation cannot be solved analytically and is
computed numerically in pyross.inference. For improved accuracy, J and B, both of which
are functions of xÃÑ(t), are computed by interpolating the numerical solution of the deterministic equation using Chebyshev polynomials. Once both the mean and the variance are
computed, the conditional probability P1|1 (x, tŒΩ+1 |x(tŒΩ ), tŒΩ ) is given by

18

3 Techniques



0

ln P1|1 (x, t¬µ |x , tŒΩ ) = ‚àí

1 T ‚àí1
1
‚àÜ¬µ Œ£¬µ ‚àÜ¬µ + ln det 2œÄŒ£¬µ
2
2



where ‚àÜ¬µ = x ‚àí xÃÑ(t¬µ ) is the deviation of the endpoint x from the deterministic trajectory.

3.3.2 Parameter inference
The conditional probability can be computed as above for each time step, the posterior,
using flat priors enforcing positive parameters, is given as the sum of the conditional probabilities,
ln P (Œ∏|X) = ‚àí

Nt 
X
1
¬µ=1

2

‚àÜT¬µ Œ£‚àí1
¬µ ‚àÜ¬µ


1
+ ln det 2œÄŒ£¬µ .
2

(3.3.3)

Here ‚àÜ¬µ = x(t¬µ ) ‚àí xÃÑ(t¬µ ). This is then used to numerically obtain the MAP estimates
for the parameters. Near the onset of an epidemic, the higher order fluctuations can grow
exponentially and significantly deviate from the mean trajectory, to resolve this issue, one
needs to sample more frequently where the growth rate (effectively R0 ) is large.

3.3.3 Latent variables
With limited information, we may only be able to observe a few components X Reduced =
{xi (tŒΩ ) | i = 1, ...MReduced √ó LReduced ; ŒΩ = 1, . . . Nt }, e.g. the number of confirmed cases
and deaths.
The first step towards inference for latent variables is to express the probability of an
full time series for a given set of parameters. One would then need to trace out unobserved
degrees of freedom. However, this is hard to do in practice, because the joint distribution
may be highly non-Gaussian. This is the case even though the propagator itself is Gaussian,
because Œ£ and xÃÑ may depend on x. Nonetheless, Gaussian inference is possible for latent
variables if the system-size expansion remains approximately valid for time intervals as long
as the whole observed time series. Then, all typical trajectories remain close to the mean
of the time series, evolving according to the ODE
‚àÇt xÃÑ = A(xÃÑ),

(3.3.4)

with the drift vector A. One has to be careful, though, because the Jacobian of A typically
has positive eigenvalues which results in exponential growth of any deviation from the mean.
We need a sufficiently large system size N .
‚àö
We now write x(t) = xÃÑ(t) + ‚àÜ(t). The variable ‚àÜ = x1 / ‚Ñ¶ and therefore also evolves
according to an Ornstein Uhlenbeck process. The conditional probability distribution for
‚àÜ at time t¬µ given its value at time tŒΩ is
‚àÜ¬µ , t¬µ |‚àÜŒΩ , tŒΩ ‚àº N (U ¬µ ‚àÜŒΩ , Œ£¬µ )

19

(3.3.5)

3 Techniques
where the matrix U ¬µ = U (t¬µ ) is the time evolution operator, defined by the equation
‚àÇt U (t) = J (xÃÑ(t))U (t). It yields the mean of ‚àÜ(t¬µ ) for given ‚àÜ(tŒΩ ). Œ£¬µ is calculated
from Eq.3.3.2, but xÃÑ is different, since we couldn‚Äôt update it with a recent initial condition.
For a Gaussian initial distribution with covariance Œ£0 , the conditional probabilities are
concatenated to yield the joint distribution. The overall covariance matrix for the vectors
(‚àÜ(t1 ), . . . , ‚àÜ(tNt ))T is given by the inverse of the following tridiagonal block matrix:
Ô£´
Ô£∂

Œ£ ‚àí1

Ô£¨
Ô£∑
Ô£¨ ‚àí1
Ô£∑
T Œ£‚àí1
Ô£¨Œ£1 + U T2 Œ£‚àí1
Ô£∑
U
‚àíU
0
.
.
.
2
2 2
2
Ô£¨
Ô£∑
Ô£¨
Ô£∑
Ô£¨
Ô£∑
Ô£¨
Ô£∑
Ô£¨
Ô£∑
‚àí1
‚àí1
‚àí1
‚àí1
T
T
Ô£¨
‚àíŒ£2 U 2
Œ£2 + U 3 Œ£3 U 3 ‚àíU 2 Œ£2
0 . . .Ô£∑
Ô£¨
Ô£∑
=Ô£¨
Ô£∑.
Ô£¨
Ô£∑
Ô£¨
Ô£∑
Ô£¨
Ô£∑
.
.
Ô£¨
Ô£∑
..
..
U
0
‚àíŒ£‚àí1
Ô£¨
Ô£∑
3
3
Ô£¨
Ô£∑
Ô£¨
Ô£∑
Ô£¨
Ô£∑
Ô£≠
Ô£∏
..
..
..
.
.
.
0

(3.3.6)

Note that after the inversion Œ£ typically has nonzero entries everywhere. With latent
observable, we simply eliminate all rows and columns associated with (sub-)indices other
than those known. The joint distribution of the remaining then follows as a multivariate
Gaussian with the reduced covariance and the mean for the observed variables. In the
pyross.inference module, the initial conditions for x are also treated as parameters to be
inferred, as they are unknown for the unobserved variables.

3.3.4 Model evidence
Bayesian credible intervals (BCI), or standard deviation of the maximum a posteriori (MAP)
estimates, can be understood by writing H = ‚àí‚àá‚àá ln P (Œ∏|X, Mi )|Œ∏‚àó for the Hessian, and
Taylor expanding the log posterior of the parameters Œ∏, given the data X and the model
Mi with ‚àÜŒ∏ = Œ∏ ‚àí Œ∏ ‚àó , where Œ∏ ‚àó are the MAPs [17, 32],


1
‚àó
T
P (Œ∏|X, Mi ) ‚âà P (Œ∏ |X, Mi ) exp ‚àí ‚àÜŒ∏ H‚àÜŒ∏ .
(3.3.7)
2
This is a local Gaussian approximation to the posterior around its mode with covariance
matrix H ‚àí1 . The square root of the diagonal elements of this covariance matrix gives the
BCIs.
In case the functional form of the posterior distribution is known, numerical errors associated with finite differences methods can be circumvent by using automatic differentiation

20

3 Techniques
(eg ‚Äôautograd [33]‚Äô). This allows for exact and rapid computation of the Hessian matrix,
neither over- nor underestimating the uncertainty of our estimates.
Mostly branded ‚Äôthe second level of inference‚Äô after the first level of obtaining the MAP
estimates, the arguably most important feature of Bayesian inference is model selection.
The posterior probability for each model is by Bayes‚Äô theorem
P (Mi |X) ‚àù P (X|Mi )P (Mi ).

(3.3.8)

In the following we assume a flat model prior P (Mi ), ie we a priori have no reason to
prefer one model over an other. This leaves us with the model evidence P (X|Mi ), which
at the same time is the normalization constant in Bayes‚Äô theorem for the posterior of the
parameters Œ∏ given the data
P (Œ∏|X, Mi ) =

P (X|Œ∏, Mi )P (Œ∏|Mi )
.
P (X|Mi )

(3.3.9)

In order to evaluate the evidence, we have to marginalize the likelihood function over the
often high-dimensional parameter space
Z
P (X|Mi ) = P (X|Œ∏, Mi )P (Œ∏|Mi )dŒ∏.
(3.3.10)
However, if the posterior in equation (3.3.9) is reasonably well approximated by a Gaussian, which is expected to be increasingly accurate the more data we use, we can use
Laplace‚Äôs method to approximate the evidence by
P (X|Mi ) ‚âà P (X|Œ∏ ‚àó , Mi ) P (Œ∏ ‚àó |Mi )(2œÄ)k/2 det{H}‚àí1/2 ,
|
{z
}|
{z
}
Best f it likelihood

(3.3.11)

Occam f actor

the height of the peak of the integrand in equation (3.3.10) times its width. The Occam
factor automatically penalizes over-fitting [17]. By comparing the contributions of best fit
likelihood and Occam factor one can at least qualitatively decide whether this approximation is expected to be sufficient. The evaluation is of course orders of magnitude faster than
computing the integral in equation (3.3.10).

3.3.5 Nested sampling
Nested sampling (eg via ‚Äônestle‚Äô package [34]) is an algorithm invented by John Skilling [35],
dealing with those high-dimensional integrals in the evidence calculation equation (3.3.10)
by reducing them to one-dimensional integrals over unit range. We have found this to be
rather slow for most of our models, but since the evidence has to be calculated only once
per model, it might still be feasible to use nested sampling. Especially, when not enough
data is available and the Gaussian approximation equation (3.3.11) fails to be sufficient,

21

3 Techniques
this should be used. The method is slow when running on a single core for the inference
on the manifold as described in sec 3.3. However, we have found that for the tangent space
inference described in section 3.4, nestle is actually reasonably fas. This is simply because of
the much faster log-posterior evaluations. With parallel processing of the nested sampling,
log-posterior evaluation takes few seconds on a 8 core machine for M = 2 and N = 5 √ó 104 .

3.4 Tangent space inference
As mentioned before, a self-consistent method of taking the diffusion limit of equation
equation (3.1.3) is van Kampen‚Äôs system size expansion [30]. With the population densities
x ‚â° n/‚Ñ¶, where ‚Ñ¶ is the system size - the total population size, the a posteriori justified
ansatz of the ‚Ñ¶-expansion is where xŒΩ = x(tŒΩ ). The mean in 3.2.4 evolves according to the
macroscopic rate equations (MRE)
Àô ŒΩ = A(tŒΩ , xÃÑŒΩ , Œ∏),
xÃÑ

(3.4.1)

and can thus be found by solving this system of ODEs. The CFPE is equivalent to the
Ito stochastic differential equation describing the dynamics of u, the so called chemical
Langevin equation (CLE),
duŒΩ = J (tŒΩ , xÃÑŒΩ , Œ∏) ¬∑ uŒΩ dt + œÉ(tŒΩ , xÃÑŒΩ , Œ∏) ¬∑ dW ,

œÉœÉ T = B(tŒΩ , xÃÑŒΩ , Œ∏),

(3.4.2)

with Jab = ‚àÇb Aa , and W being a multi-dimensional Wiener process. Thus, in this approximation the population density evolves according to the stochastic process
1

dxŒΩ = A(tŒΩ , xÃÑŒΩ , Œ∏)dt + ‚Ñ¶‚àí 2 duŒΩ ,

(3.4.3)

1

driven by a small (suppressed by a factor of ‚Ñ¶‚àí 2 ) Ornstein-Uhlenbeck noise. Formally
re-writing equation equation (3.4.3) we get
1

Àô ŒΩ + ‚Ñ¶‚àí 2 uÃáŒΩ
xÃáŒΩ = xÃÑ
1

= A(tŒΩ , xÃÑŒΩ , Œ∏) + ‚Ñ¶‚àí 2 (J (tŒΩ , xÃÑŒΩ , Œ∏) ¬∑ uŒΩ + ŒΩ )
= A(tŒΩ , xÃÑŒΩ , Œ∏) + J (tŒΩ , xÃÑŒΩ , Œ∏) ¬∑ (xŒΩ ‚àí xÃÑŒΩ ) + Œ∑ ŒΩ ,

(3.4.4)

with the Gaussian white noises ŒΩ ‚àº N (0, B(tŒΩ , xÃÑŒΩ , Œ∏)) and Œ∑ ŒΩ ‚àº N 0, ‚Ñ¶1 B(tŒΩ , xÃÑŒΩ , Œ∏) .
Thus, with the change of measure
P (xÃáŒΩ )dxÃá = P (Œ∑ ŒΩ )dŒ∑ ŒΩ

(3.4.5)

and the Jacobian ‚àÇŒ∑ŒΩi /‚àÇxjŒΩ = Œ¥ ij we obtain a multivariate normal distribution for the
likelihood of xÃá, given the parameters Œ∏


T
Y
1
P (xÃá|Œ∏) =
N hxÃáŒΩ i, B(tŒΩ , xÃÑŒΩ , Œ∏) ,
(3.4.6)
‚Ñ¶
ŒΩ=1

22

3 Techniques
with the mean velocity defined by
hxÃáŒΩ i ‚â° A(tŒΩ , xÃÑŒΩ , Œ∏) + J (tŒΩ , xÃÑŒΩ , Œ∏) ¬∑ (xŒΩ ‚àí xÃÑŒΩ ) .

(3.4.7)

Assuming improper informative priors, i.e‚Äû flat priors enforcing positive parameters, the
log-posterior distribution is
ln P (Œ∏|xÃá) = ‚àí

T 
X
‚Ñ¶
ŒΩ=1

2

T

(xÃáŒΩ ‚àí hxÃáŒΩ i) ¬∑ B

‚àí1


1
2œÄ
¬∑ (xÃáŒΩ ‚àí hxÃáŒΩ i) + ln det B .
2
‚Ñ¶

(3.4.8)

This posterior distribution, albeit complicated, is analytical up to integration of equation
equation (3.4.1) and thus, can be easily traced by automatic differentiation.
Having obtained the maximum a posteriori (MAP) estimates Œ∏ ‚àó one can therefore easily
obtain the Hessian H ‚â° ‚àí‚àá‚àá ln P (Œ∏|xÃá)|Œ∏‚àó of the posterior distribution and thus, calculate
the Laplacian approximation to the evidence for the model Mi [17]
1

P (xÃá|Mi ) ‚âà P (xÃá|Œ∏ ‚àó , Mi ) P (Œ∏ ‚àó |Mi )(2œÄ)k/2 det{}‚àí 2 H ,
{z
} |
{z
}
|
Best f it likelihood

(3.4.9)

Occam f actor

and most importantly the Bayesian credible intervals, or error bars of the MAP estimates.
Not relying on finite differences-methods enables us to quantify the uncertainties of our
predictions in a much more reliable manner.
Due to the just-in-time (JIT) compilation of ‚ÄòJAX‚Äô [36], a python machine learning
library, it is even possible to compute the multi-dimensional integral for the model evidence
Z
P (xÃá|Mi ) = P (xÃá|Œ∏, Mi )P (Œ∏|Mi )dŒ∏
exactly within seconds (nestle). With this, we can pursue the task of Bayesian model
averaging for epidemiological models.
Operationally , the stochastic population density vector x is given by the data itself. Its
derivative xÃá is simply obtained by finite differences (jax.numpy.gradient) [36], no fitting
is applied. The mean xÃÑ satisfying the MREs equation (3.4.1) can be found by solving
this system of ODEs for a given set of parameters Œ∏ (jax.experimental.ode.odeint), and
therefore, is part of the optimization process of finding the MAPs Œ∏ ‚àó . The coefficients of
the system size expansion A, J and B depend on the mean.

3.5 Prediction
In the previous section, we described the inference of model parameters Œ∏ = (Œ∏1 , . . . , Œ∏k )
given data X in the form of a time series, c.f. equation (3.3.1). We now discuss how the
results of this inference are used for prediction in the pyross.forecast module. An example
where the forecasting module is used is given in section 5.5.

23

3 Techniques

3.5.1 Posterior predictive distributions
Once given data X has been used to infer parameters Œ∏ of a model Mi , the probability to
make an observation Y is given by
Z
P (Y |X, Mi ) = P (Y |X, Œ∏, Mi )P (Œ∏|X, Mi )dŒ∏,
(3.5.1)
where Y is the observation whose probability one wants to predict. The first term in the
integral, called model uncertainty, is the probability that, for given data X and parameters Œ∏, one observes Y . The second term, called parameter uncertainty, represents the
probability of the parameters Œ∏ itself given the data X. As indicated in the notation, all
three probabilities are conditional on Mi . In the present context, X is typically a fully or
partially observed time series up to the present, and Y denotes future values of the time
series, or more generally any function of the time series. To use the right-hand side of
equation (3.5.1) for calculating predictions, explicit expressions for both factors need to be
obtained. We first approximate the equation as
P (Y |X, Mi ) ‚âà

N
1 X
P (Y |X, Œ∏ j , Mi ),
N

(3.5.2)

j=1

where Œ∏ j are N independent samples drawn from the distribution P (Œ∏|X, Mi ). In the
following sections, we describe both this sampling process, and how the corresponding
terms in equation (3.5.2) are evaluated in pyross.forecast.

3.5.2 Data uncertainty
Uncertainty in the available data needs to be considered when fitting model parameters.
Sources of uncertainty are twofold. On the one hand, authorities may be not able to report
all the infected cases or deads. On the other hand, uncertainty arises from the fact that
tests can never be perfect. The consequence of this uncertainty is that the reported numbers
of infectives do not match the actual numbers considered in our models.
One way to reduce data uncertainty is to focus on refined models that attribute specific
compartments to the data available with the least uncertainty. These compartments can
be (see the bestiary 4) compartments for hospitalised individual, people in ICU, deads,
etc. Our inference methods in principle allow one to extract model parameters from such
incomplete information. However, as it can be expected that these three classes cover only
a small fraction of the overall infected population (in particular older age groups), the
suitability of these data for extensive model fitting is questionable.
It would therefore be desirable to also use data from more universal testing campaigns.
The only way to handle uncertainty in these numbers is to model the testing process explicitly. Such testing models typically need to be informed by the number of tests being
performed per day and a guess for the specificity of the tests.

24

3 Techniques
To do so, all individuals who are positively tested are moved in a new class T+ (confirmed
cases)1 . Note that people in T+ are not isolated by default and can still infect others if
they are not quarantined.
For the same reasons as every compartment models considered in PyRoss, the testing
process is intrinsically stochastic (although it becomes deterministic in the law of large
numbers limit). It is generically defined by:
1. the probability to actually report a confirmed case when a test is conducted,
2. the distribution of tests in time.
Random testing in the population
When a test is conducted, it can be performed completely at random by selecting one
individual in the whole population or it can be restricted to some subpopulation.
By noting I(t) the number of infected ‚Äî yet not tested ‚Äî individuals, and T+ (t) the
number of positively tested individuals, the simplest model is to consider a perfectly random
testing procedure among the Ntestpop (t) = N ‚àí T+ (t) individuals in the population who
have not been tested positive yet. The probability to detect one infected individual at time
t thus reads as
I(t)
p+ (t) =
.
(3.5.3)
Ntestpop (t)
Possible refinements of the testing process include more selective processes like symptomatic testing, contact tracing, etc.
Markovian testing process
To go further, one needs to make some assumption about the distribution of tests in time.
The simplest assumption is to assume that the tests are also performed randomly in time,
without any memory of the tests conducted earlier (Markov assumption). If one denotes
by œÑ (t) the rate at which tests are performed, the number of tests conducted between t and
R t+‚àÜt
œÑ (u)du.
t + ‚àÜt is drawn from a Poisson distribution of parameter t
The rates at which infected people are tested positive thus reads
wtest (t) = œÑ (t)p+ (t) .

(3.5.4)

We recall that when a positive case is detected, the global state of the system (I(t), T+ , . . . )
is updated as (I(t) ‚àí 1, T+ (t) + 1, . . . ).

1

Note that this class can be confused with the quarantine class Q when confirmed people are quarantined
(see SEAIRQ model in Sec. 4.10). Otherwise, we interpret T+ as a subclass of infected people who can
still infect susceptibles.

25

3 Techniques
In practice, one typically knows from data the average number of tests per day. If one
assumes œÑ (t) to be constant over one day, the average number of tests conducted in one
day is œÑ √ó 1 day.
At the expense of introducing non-Markovian features into the dynamics, the distribution
of tests in time is not limited to be Poissonian, and one can imagine to conduct a strictly
fixed number of tests per day, or even more complex time distributions.

3.5.3 Parameter uncertainty
With equation (3.3.7) we have a Gaussian approximation for the distribution of the parameters Œ∏, which, for data X and model Mi , is given by


1
P (Œ∏|X, Mi ) ‚âà N exp ‚àí ‚àÜŒ∏ T H‚àÜŒ∏ ,
(3.5.5)
2
where N is a normalisation constant, ‚àÜŒ∏ = Œ∏ ‚àí Œ∏ ‚àó with Œ∏ ‚àó the MAPs, and H the Hessian
of the log-likelihood function. To generate numerical samples Œ∏ j for system parameters, we
draw from this Gaussian distribution. While in the parameter inference for compartment
models, the components of the parameters Œ∏ typically represent rates between compartments, which are positive, the Gaussian distribution equation (3.5.5) in principle allows
for arbitrary real values. To avoid unphysical values for system parameters, we redraw a
sample Œ∏j if any of its vector component is negative, meaning we use a truncated version
of the Gaussian distribution.

3.5.4 Model uncertainty
For a deterministic model and a definite initial condition we have
P (Y |X, Œ∏, Mi ) = Œ¥(Y ‚àí Y (X, Œ∏, Mi ))

(3.5.6)

where Y (X, Œ∏, Mi ) is the deterministic value for Y , calculated from model Mi using the
parameters Œ∏ and the initial condition determined by the data X. For a deterministic
model, the approximate posterior predictive distribution equation (3.5.2) is thus given by
P (Y |X, Mi ) ‚âà

N
1 X
Œ¥(Y ‚àí Y (X, Œ∏j , Mi )).
N

(3.5.7)

j=1

Obtaining Y (X, Œ∏, Mi ) in practice means one has to integrate the model equations, which
for the nonlinear ODEs corresponding to the compartment models is achieved by numerical
integration using pyross.deterministic. To estimate (3.5.2) for a stochastic model, we also
use (3.5.7), but now Y (X, Œ∏ j , Mi ) represents a realisation of the stochastic dynamics,
generated using pyross.stochastic.

26

3 Techniques

3.5.5 Model averaging
In section 3.5.1 we discussed predicting the outcome of an observation Y , assuming a given
observation X and a model Mi . However, typically there are multiple models that are,
in principle, compatible with the observation X. A more refined forecast is thus obtained
by not only averaging over parameter uncertainties and model uncertainties, but also over
models, i.e. by considering
P (Y |X) =

X

P (Y |X, Mi ) P (Mi |X),

(3.5.8)

i

where the summation is over the models Mi considered, the first term in the sum was
discussed in section 3.5.1, and the second term in the sum is the probability that, of all
the models considered, Mi is the correct model, was discussed in section 3.3.4. In practice,
incorporating a model-average in the prediction formula 3.5.2, we thus obtain
N
1 X
P (Y |X) ‚âà
P (Y |X, Œ∏ j , Mj ),
N

(3.5.9)

j=1

where now for the j-th trajectory, first a model Mj is randomly drawn with probability
given by equation (3.3.11) (properly normalised so that the sum over all models considered
is unity), and then a random sample Œ∏ j for the parameters of that model is drawn from the
distribution P (Œ∏|X, Mj ), as discussed in section (3.5.3). Finally, the probability appearing
in the j-th term is obtained as described in section (3.5.4).

3.6 Interventions
To achieve a desired goal, such as reducing the number of infectives, one would like to
understand how a given intervention influences the time evolution of a model. As will
be discussed in this chapter, pyross offers several ways of implementing and optimising
intervention parameters. See examples 5.6 and 5.6 for examples involving prescribed- and
optimised intervention parameters.

3.6.1 Non-pharmaceutical interventions (NPI)
Non-pharmaceutical interventions (NPIs) are strategies that mitigate the spread of a disease by suppressing its normal pathways for transmission. These include social distancing,
wearing masks, working from home, and isolation of vulnerable populations. In contrast to
pharmaceutical interventions, which are slow to develop but effective in the long term, NPIs
can be rapidly implemented but are generally too costly to maintain indefinitely. In the
modelling framework of pyross, we represent NPIs as modifications to the contact matrix

27

3 Techniques
C, the elements Cij of which describe the number of contacts between age groups i and j
(see Eq.2.3.1). Without any NPI, we typically consider the contact matrix as a sum
H
W
S
O
Cij (t) = Cij
+ Cij
+ Cij
+ Cij
.

(3.6.1)

where the four terms denote the number of contact at home, at work, at school, and the
other remaining contacts. We have written the above by setting the constants aH = aS =
aW = a0 = 1 in Eq.2.3.1. The class pyross.contactMatrix provides an interface to retrieve the
individual contact matrices C H , C W , C S , C O , for several countries, obtained from Ref. [24].
In the presence of a NPI, typically in at least one of these spheres contacts are reduced,
and the corresponding contact matrix is to be replaced by
X
CX
ij ‚Üí ui C ij vj ,

(3.6.2)

where X ‚àà {H, W, S, O} labels the sphere, ui is the fraction by which susceptible members of
age group i reduce their contacts and vj is the corresponding fraction for infective members.

3.6.2 Intervention protocols
An intervention typically consists of a time- and state-dependent protocol for the contact
matrix. The pyross module currently allows for two kinds of intervention strategies. Purely
time-dependent interventions, meaning a given time-dependent contact matrix C(t), are
available directly in the main simulation modules pyross.deterministic and pyross.stochastic
. An example for purely time-dependent interventions is a full lockdown starting at time
t0 and released at time t1 , for which the time-dependent contact matrix is
(
H + C W + C S + C O t < t or t > t
Cij
0
1
ij
ij
ij
Cij (t) =
(3.6.3)
H
Cij
t0 < t < t1 .
If one considers a system with uncertainty, either intrinsic from the model or because of
imperfect knowledge of system parameters, then a purely time-dependent protocol could
be insufficient. For example, if at time t1 in the protocol given by equation (3.6.3), the
number of infectives has not decreased below some threshold, one might not want to release
the lockdown yet before that threshold is met. To allow for interventions that dependent
on time and state, the submodule pyross.control allows to consider event-driven protocols.
An event Ei is a function, Ei ‚â° Ei (y(t), t), where y(t) is the state of the dynamics, and it
occurs at a time t‚àó if Ei (y(t‚àó ), t‚àó ) = 0, possibly with the additional requirement that the
total derivative d/dt Ei (y(t‚àó ), t‚àó ) be either positive or negative. In pyross.control, the user
provides the program with a list of events (E1 , E2 , ..., EM ), and for each event supplies a
contact matrix Ci which is used in the further time evolution of the model once the event
Ei has occurred. An example for a protocol defined by events is given by the two functions
E1 (y, t) = yi ‚àí c1 , E2 (y, t) = yi ‚àí c2 , where c1 > c2 and we require that the total derivative

28

3 Techniques
of E1 be positive for an event, while the total derivative of E2 be negative for an event. For
the contact matrix, we consider
Ô£±
H
W
S
O
Ô£¥
Ô£≤Cij + Cij + Cij + Cij initially,
H
Cij (t) = Cij
(3.6.4)
if E1 occurs,
Ô£¥
Ô£≥ H
W
S
O
Cij + Cij + Cij + Cij if E2 occurs.
This protocol puts a lockdown into place once the population yi of compartment i exceeds
a threshold c1 , and releases this lockdown once the population drops below c2 . In pyross.
control, the user can define whether each event can only occur once or repeatedly; if each
event can only occur once, the user can furthermore set whether the events can occur in
arbitrary order, or only in the order they are given.
For quarantine and contact tracing (Testing, contact-Tracing and Isolation procedures),
one can also imagine to model such interventions by adding new compartments explicitly
in the model (see for instance SEAIIRQ in Sec. 4.10). For instance, when quarantine is
decided after a test has been performed, the rate at which the quarantine compartment
is filled is directly proportional to the average number of tests currently conducted, which
can be a priori controlled. This other kind of intervention is currently being implemented
within PyRoss.

3.6.3 Bayesian forecast of NPI
Simulations can be used to determine whether a given control strategy achieves a desired
goal. If all system parameters are known exactly, and if the dynamics of the model is
deterministic, then a single simulation using pyross.control is sufficient to explore the consequences of a given intervention strategy. For the case of uncertain parameters, or a
stochastic model, pyross.forecast can be used to generate an ensemble-forecasting for both
purely time-dependent and event-driven intervention strategies.

3.6.4 Optimised intervention parameters
Intervention protocols are typically considered to achieve a desired goal, such as reducing
the number of infectives. To frame this in the language of an optimisation problem, we
consider events (E1 , E2 , ..., EM ) which depend on a parameter c ‚àà Rm . An example for this
are the two thresholds c ‚â° (c1 , c2 ) ‚àà R2 from the protocol considered in section 3.6.2. We
furthermore consider a cost functional Cc [yc ], which quantifies the cost of a given realisation
yc (t) of the dynamics. With the index c we emphasise that the functional can depend on c
both explicitly, and implicitly because the model dynamics depends on the protocol. Taking
into account both model- and parameter uncertainty, the average cost is given by
Z Z
hCc i =
Cc [y c ]PŒ∏ [y c ]D[y c ]P (Œ∏)dŒ∏,
(3.6.5)

29

3 Techniques
where PŒ∏ [y c ]D[y c ] denotes the path-integral density of the trajectory y c for given system
parameters Œ∏. The optimal protocol c‚àó is defined as the protocol which minimises the
average cost,
c‚àó = argminc hCc i,

(3.6.6)

and to determine it numerically, a practical means of evaluating the average cost of a
protocol needs to be established. For deterministic dynamics, there is only one path which
occurs with probability one, and the mean cost of a protocol is given by
Z
hCc i = Cc [y c ]P (Œ∏)dŒ∏,
(3.6.7)
where y c denotes the deterministic solution corresponding to the parameters Œ∏ and a given
initial conditions. An estimate for this average cost can be obtained numerically by approximating P (Œ∏) by a Gaussian, drawing N samples Œ∏ j for this Gaussian, and averaging
over the resulting cost, i.e.
N
1 X
hCc i ‚âà
Cc [y jc ],
N

(3.6.8)

j=1

where y jc is the deterministic solution of the model dynamics subject to the protocol with
parameters c and model parameters Œ∏ j . If the model dynamics is furthermore stochastic,
we approximate the path-integral in equation (3.6.5) by additionally averaging over realisations of the model dynamics; then, equation (3.6.8) is still valid and y jc simply denotes a
stochastic realisation subject to the protocol with parameters c and model parameters Œ∏ j .
Equation (3.6.8) constitutes a numerically accessible means of evaluating the average cost
of a protocol, which can be used for numerical solution of the minimisation problem (3.6.6).
While an optimisation framework within pyross is in the works, pyross.control can be conveniently used to generate the sample trajectories y jc which appear in equation (3.6.8). For
an example of a problem with optimised intervention parameters, see example 5.7.

3.7 Numerical methods
3.7.1 Exact sampling
The generate a realization of a discrete-state continuous time model as described in section
3.1, pyross.stochastic by default uses the Gillespie SSA algorithm [37]. In this algorithm,
an integration step
(t, n(t)) 7‚àí‚Üí (t + ‚àÜt, n(t + ‚àÜt))
consists of two parts, each of which involves a random choice:

30

(3.7.1)

3 Techniques
1. Determine a waiting time ‚àÜt until any population in the compartment model changes
(a ‚Äúreaction‚Äù takes place).
2. Decide which population changes.
P
For step 1, first the total reaction rate is calculated as W = Œ± wŒ± , and then an exponentially distributed random variable ‚àÜt with mean 1/W is generated to determine the time
at which the next reaction occurs. For step 2, a random reaction Œ± is then chosen with
probability pŒ± = wŒ± /W . The population vector n is finally updated by adding the vector
r Œ± , as described in equation (3.1.2), i.e.
n(t + ‚àÜt) = n(t) + r Œ± .

(3.7.2)

3.7.2 Acceleration by œÑ -leaping
For large populations the Gillespie algorithm described in section 3.7.1, which simulates
every event individually, can be very slow. To accelerate stochastic simulations of large
populations, pyross.stochastic also supports an integration method called tau-leaping [38].
Here, an integration step (3.7.1) consists of the following two parts:
1. A time interval œÑ is chosen deterministically, as discussed further below.
2. For each possible reaction Œ±, a random sample qŒ± for the number of occurring reactions
in the time interval œÑ is drawn from a Poisson distribution with mean wŒ± ¬∑ œÑ .
The population vector n is then updated by adding up all the population changes, i.e.
n(t + œÑ ) = n(t) +

X

qŒ± r Œ± ,

(3.7.3)

Œ±

where the vector r Œ± was introduced in equation (3.1.2).
The time interval œÑ needs to be so small that the rates, which depends on the current state,
wŒ± ‚â° wŒ± (n), does not change appreciably during all the reactions that take place during
œÑ . To select œÑ , pyross.stochastic uses the algorithm by Cao, Gillespie, and Petzold [39].
To avoid unphysical negative populations, which can be the consequence of a tau-leaping
step (3.7.3), pyross.stochastic switches to the Gillespie SSA algorithm if any population is
below a threshold; identifying critical reaction channels and only propagating those via the
Gillespie SSA algorithm, as described in Ref. [39], will be added soon.

3.7.3 Integration in the deterministic limit
The deterministic dynamic of the models given in 4 is obtained by numerical integration
in pyross.deterministic. By default PyRoss uses scipy.integrate.odeint for numerical integrations. This is an adaptive time step integrator, which switches between the backward

31

3 Techniques
differentiation formula for stiff problems [40] and Adams method for non-stiff problems
[41]. Alternatively, we also allow to use integration methods from the package Odespy [42]
and other integrators from Scipy [43] such as scipy.integrate.solve_ivp. See chapter 4, for
deterministic dynamical systems.

32

4 Bestiary
In this chapter, we describe the implementations of age-structured epidemiological compartment models in PyRoss. The basic variable in this class of models is a metapopulation
labeled by its epidemiological state (susceptible, infectious, removed, etc) and additional
attributes like age, gender, geographic location and so on. The additional attributes are
what comprise the "structure" of the model. Currently, PyRoss supports the models with
susceptible (S), infected (I), exposed (E), activated (A), quarantined (Q) and removed
(R) epidemiological states. Additionally, the infectious class can be subdivided into kstages. The progress of these variables in time are described by chemical master equations
and, when compartmental fluctuations (CME) are small, by ordinary differential equations
(ODE). A hybrid method is also possible which switches from CME to ODE when the
population reaches a user defined threshold, at which point it is assumed that random
fluctuations are a negligible percentage of the total population. These integration methods
build the foundation of PyRoss, upon which investigation into the effects of control such as
self-isolation or forecasting made from real world data can be performed.
PyRoss takes the inputs - age, contact structure and an epidemiological compartment
model - to simulate the deterministic and stochastic trajectories. The age [44] and contact
structures [24] can be obtained from published data. The demographic parameters which
determine contact matrices, together with their uncertainties, will be discussed elsewhere.
In this work, we assumed they are user-supplied. In what follows, 4.1-4.11.1, we describe
various models available in PyRoss with increasing complexity. We also provide a class to
implement a generic user-defined compartment model in 4.12.

4.1 SIR
We first present the well studied SIR model, where population within age group i, is partitioned into susceptibles Si , infectives Ii , and removed individuals Ri . The sum of these is
the size of the population in age group i, Ni = Si + Ii + Ri [1, 2, 20‚Äì22]. For this model,
vital dynamics and the change in age structure on the time scale of the epidemic in this
model is ignored. Therefore each Ni and, consequently, the total population size
N=

M
X

Ni

(4.1.1)

i=1

remain constant in time. With these assumptions the progress of the epidemic is governed
by the age-structured SIR model. Figure 4.1.1 shows the schematic. The deterministic

33

4 Bestiary

Figure 4.1.1: Schematic of the SIR model. The parameters for this model are: Œ∏ =
(Œ≤, Œ≥I ). The class SIR can be instantiated in PyRoss using pyross.deterministic
.SIR.

Figure 4.1.2: Schematic of the SIR with stages (SIkR) model. The parameters for
this model are: Œ∏ = (kI , Œ≤, Œ≥I ). The class SIkR can be instantiated in PyRoss
using pyross.deterministic.SIkR.
limit of the SIR model is given by the ODE:
SÃái = ‚àíŒªi (t)Si ,
IÀôi = Œªi (t)Si ‚àí Œ≥I Ii ,
RÃái = Œ≥I Ii .
The rate of infection of a susceptible individual in age group i is
Œªi (t) = Œ≤

M 
X
j=1

Ij
Cij (t)
Nj


,

i, j = 1, . . . M

(4.1.2)

where Œ≤ is the probability of infection on contact (assumed intrinsic to the pathogen) .
We take the age-independent removal rate Œ≥ to be identical for both asymptomatic and
symptomatic individuals whose fractions are, respectively, Œ±i and Œ±ÃÑi = 1 ‚àí Œ±i . The social
contact matrix Cij denotes the average number of contacts made per day by an individual
in class i with an individual in class j. Clearly, the total number of contacts between group
i to group j must equal the total number of contacts from group j to group i, and thus,
Ni Cij = Nj Cji .
The SIR model can be improved by adding more epidemiological states as we describe below. Addition epidemiological states, like exposed (E), where the individual has contracted
the diseases but is not infectious, or quarantined (Q), where the individual has contracted
the disease, is infectious, but cannot spread contagion because of confinement, may be necessary for a better-resolved description. Despite these limitations, the SIR model and its

34

4 Bestiary
age-structured variant provide the most parsimonious description of infectious disease and
provide a null model against which all others must be compared.

4.2 SIR with stages (SIkR)
The SIR model considers only three mutually exclusive epidemiological states: S, I, R. This
leads to an exponentially distributed residence time in the infectious state. Within the
compartment framework, the simplest way to make infectious period distributions more
realistic is to use stages (k stages of infectious) [7]. The model SIR with stages (SIkR)
is obtained by allowing I class is the SIR to have k-stages [7]. The SIkR model then
has an infectious period with Erlang, Gamma distributions with integer shape parameter,
distribution [4‚Äì6]. The number of states k can be adjusted to match empirically observed
infectious periods. Figure 4.1.2 shows the schematic. The deterministic limit of the SIkR
model is given as
SÃái = ‚àíŒªi (t)Si ,
IÀôi1 = Œªi (t)Si ‚àí kI Œ≥I Ii1 ,
..
.
IÀôk = kI Œ≥I I k‚àí1 ‚àí kI Œ≥I I k ,
i

RÃái =

(4.2.1)

i

i
kI Œ≥I Iik .

The rate of infection of a susceptible individual in age group i is
Œªi (t) = Œ≤

M X
k
X

Cij (t)

j=1 n=1

Ijn
,
Nj

(4.2.2)

4.3 SIIR
We now extend the classic SIR model to an SIIR model, where the infective class has been
divided in asymptomatic Iia and symptomatic Iis . We assume that the rate of infection of
a susceptible individual in age group i is
Œªi (t) = Œ≤

M 
X
j=1

a
Cij
(t)

Ija
Ijs
s
+ Cij
(t)
Nj
Nj


,

i, j = 1, . . . M

(4.3.1)

where Œ≤ is the probability of infection on contact (assumed intrinsic to the pathogen) and
a and C s are, respectively, the number of contacts between asymptomatic and sympCij
ij
tomatic infectives in age-group j with susceptibles in age-group i (reflecting the structure

35

4 Bestiary

Figure 4.3.1: Schematic of the SIIR model. The parameters for this model are: Œ∏ =
(Œ±i , Œ≤, Œ≥I a , Œ≥I s ). The class SIIR can be instantiated in PyRoss using pyross.
deterministic.SIR. Please note that both SIIR and SIR have been implemented
as pyross.deterministic.SIR in PyRoss, as it possible to go from one to another
by correct choice of parameters.
of social contacts). We assume that symptomatic infectives reduce their contacts compared
s = f s C a ‚â° f s C , where 0 ‚â§ f s ‚â§ 1 is the proporto asymptomatic infectives and set Cij
ij
ij
tion of contacts that are now avoided by these self-isolating individuals (allowing also for
compliance rates)
With these assumptions the progress of the epidemic is governed by the age-structured
SIIR model. Figure 4.3.1 shows the schematic. The deterministic limit is given as,
SÃái = ‚àíŒªi (t)Si ,
IÀôia = Œ±i Œªi (t)Si ‚àí Œ≥I a Iia ,
IÀôs = Œ±ÃÑi Œªi (t)Si ‚àí Œ≥I s I s ,
i

RÃái =

(4.3.2)

i

Œ≥I a Iia

+

Œ≥I s Iis .

Here Œ≥I a is the removal rate for asymptomatic infectives, Œ≥I s is the removal rate for symptomatic infectives, Œ±i is the fraction of asymptomatic infectives.

4.4 SEIR
The SIR model does not model the incubation period of a virus. This can be included
by adding to the SIR model an exposed E compartment (to give an age-structured SEIR
model) [3, 45‚Äì47]. Figure 4.4.1 shows the schematic of the SEIR model. The deterministic

36

4 Bestiary

Figure 4.4.1: Schematic of the SEIR model. The parameters for this model are:
Œ∏ = (Œ≤, Œ≥I , Œ≥E ). The class SEIR can be instantiated in PyRoss using pyross.
deterministic.SEIR.

Figure 4.5.1: Schematic of the SEIR with stages (SEkIkR) model. The parameters for this model are: Œ∏ = (kI , kE , Œ≤, Œ≥I , Œ≥E ). The class SEkIkR can be
instantiated in PyRoss using pyross.deterministic.SEkIkR.
ODE giving its time-evolution is
SÃái = ‚àíŒªi (t)Si ,
EÃái = Œªi (t)Si ‚àí Œ≥E Ei
IÀôi = Œ≥E Ei ‚àí Œ≥I Ii ,

(4.4.1)

RÃái = Œ≥I Ii .
The rate of infection of a susceptible individual in age group i is
Œªi (t) = Œ≤

M 
X
j=1

Ij
Cij (t)
Nj


,

i, j = 1, . . . M

(4.4.2)

4.5 SEIR with stages (SEkIkR)
The SEIR model considers only four mutually exclusive epidemiological states: S, E, I, R.
This leads to an exponentially distributed residence time in the incubating and infectious
state. We use the same resolution as in SIkR model, see 4.2, to obtain a more realistic
distribution of incubation and infectious times. The SEIR model can be extended to an
age-structured k‚àístaged SEkIkR model. Figure 4.5.1 shows the schematic. The ODE

37

4 Bestiary

Figure 4.6.1: Schematic of the SEIIR model. The parameters for this model are: Œ∏ =
(Œ±i , Œ≤, Œ≥E , Œ≥I a , Œ≥I s ). The class SEIIR can be instantiated in PyRoss using
pyross.deterministic.SEIR. Please note that both SEIIR and SEIR have been
implemented as pyross.deterministic.SEIR in PyRoss as it possible to go from
one to another by correct choice of parameters.
describing SEIR is:
SÃái = ‚àíŒªi (t)Si ,
EÃái1 = Œªi (t)Si ‚àí kE Œ≥E Ei1
..
.
EÃáik = kE Œ≥E Eik‚àí1 ‚àí kE Œ≥E Eik
IÀôi1 = kE Œ≥E Eik ‚àí kI Œ≥I Ii1 ,
..
.

(4.5.1)

(k‚àí1)
IÀôik = kI Œ≥I Ii
‚àí kI Œ≥I Iik ,

RÃái = kI Œ≥I Iik .
The rate of infection of a susceptible individual in age group i is
Œªi (t) = Œ≤

M X
k
X
j=1 n=1

Cij (t)

Ijn
,
Nj

(4.5.2)

4.6 SEIIR
We now extend the classic SIR model to an SIIR model, where the infective class has been
divided in asymptomatic Iia and symptomatic Iis . We assume that the rate of infection of

38

4 Bestiary

Figure 4.7.1: Schematic of the SEIIR with stages (SEkIkIkR) model. The parameters for this model are: Œ∏ = (kI , kE , Œ±i , Œ≤, Œ≥I a , Œ≥I s , Œ≥E ). The class SEkIkIkR
can be instantiated in PyRoss using pyross.deterministic.SEkIkIkR.
a susceptible individual in age group i is

M 
X
Ia
Is
a j
s j
Œªi (t) = Œ≤
Cij
+ Cij
,
Nj
Nj

(4.6.1)

j=1

The deterministic dynamics is given by the following ODE:

SÃái = ‚àíŒªi (t)Si ,
EÃái = Œªi (t)Si ‚àí Œ≥E Ei
IÀôia = Œ±i Œ≥E Ei ‚àí Œ≥I a Iia ,
IÀôis = Œ±ÃÑi Œ≥E Ei ‚àí Œ≥I a Iis ,

(4.6.2)

RÃái = Œ≥I a Iia + Œ≥I s Iis .

4.7 SEIIR with stages (SEkIkIkR)
We now extend the SEIIR model to have stages in exposed, asymptomatic infectives, and
symptomatic infectives classes. This is the the same resolution as in SIkR model, see 4.2, to
obtain a more realistic distribution of incubation and infectious times. Figure 4.7.1 shows
the schematic. The deterministic dynamics is given as

39

4 Bestiary

Figure 4.8.1: Schematic of the SEAIIR model. The parameters for this model are:
Œ∏ = (Œ±i , Œ≤, Œ≥E , Œ≥A , Œ≥I a , Œ≥I s ). The class SEAIIR can be instantiated in PyRoss
using pyross.deterministic.SEAIR.

SÃái = ‚àíŒªi (t)Si ,
EÃái1 = Œªi (t)Si ‚àí kE Œ≥E Ei1
..
.
EÃáikE = kE Œ≥E EikE ‚àí1 ‚àí kE Œ≥E EikE
IÀôia1 = Œ±i kE Œ≥E Eik ‚àí kI Œ≥I a Iia1 ,
..
.

(4.7.1)

a(k ‚àí1)
IÀôiakI = kI a Œ≥I a Ii I
‚àí kI Œ≥I a IiakI ,
IÀôis1 = Œ±ÃÑi kE Œ≥E EikE ‚àí kI Œ≥I s Iia1 ,
..
.

(4.7.3)

s(k ‚àí1)
IÀôiskI = kI Œ≥I s Ii I
‚àí kI Œ≥I s IiskI ,

(4.7.4)

RÃái =

kI Œ≥I a IiakI

+

(4.7.2)

kI Œ≥I s IiskI .

We assume that the rate of infection of a susceptible individual in age group i is
Œªi (t) = Œ≤


kI 
M X
X
I sn
I an
s j
a j
+ Cij
,
Cij
Nj
Nj
j=1 n=1

40

(4.7.5)

4 Bestiary

4.8 SEAIIR
This model is an extension of the SEIR model, introducing the additional class A, which
is both asymptomatic and infectious. In other words, this models shows what ensues if
everyone who gets infected, undergoes a latency period where they are both asymptomatic
and infectious. This class is potentially quite important, as there is some evidence that
people are infectious before they start showing symptoms. The deterministic limit of this
case
SÃái = ‚àíŒªi (t)Si
EÃái = Œªi (t)Si ‚àí Œ≥E Ei
AÃái = Œ≥E Ei ‚àí Œ≥A Ai
IÀôia = Œ±i Œ≥A Ai ‚àí Œ≥I a Iia
IÀôs = Œ±ÃÑi Œ≥A Ai ‚àí Œ≥I s I s
i

RÃái =

(4.8.1)

i

Œ≥I a Iia

+

Œ≥I s Iis

The rate of infection of a susceptible individual in age group i is

M 
X
Ia
Is
a j
a Aj
s j
Œªi (t) = Œ≤
Cij
+ Cij
+ Cij
,
Nj
Nj
Nj

(4.8.2)

j=1

The A and I a classes should behave virtually the same (so their contact matrices should
be equal). The two are kept distinct to keep track of the fact that some people remain
asymptomatic even in the I stage. Since it‚Äôs difficult to find data on the ratio of I s to I a ,
it is possible to disregard the distinction and simply use I instead.

4.9 SEAI8R
This model is an extension of the SEAIIR model. There are now six more types of infectives
(Iih : infectives who are hospitalized, Iic : infectives who are in ICU, Iim : mortality due to
0
0
the infection from ICU, Iis : intermediate stage between symptomatic and removed, Iic :
0
intermediate stage between hospitalized and removed, and Iic : intermediate stage between
ICU and removed). The intermediate stages are needed to allow for a fast progression of the
disease while retaining the longer recovery time and the ratios of people experiencing different levels of severity of the disease. Figure 4.9.1 shows the schematic. The deterministic
dynamics if given by the following ODE:

41

4 Bestiary

Figure 4.9.1: Schematic of the SEAI8R model. The class SEAI8R can be instantiated
in PyRoss using pyross.deterministic.SEAI8R.

42

4 Bestiary

Figure 4.10.1: Schematic of the SEAIIRQ model. The parameters for this model
are: Œ∏ = (Œ±i , Œ≤, Œ≥E , Œ≥A , Œ≥I a , Œ≥I s , œÑE , œÑA , œÑI a , œÑI s ). The class SEAIIRQ can be
instantiated in PyRoss using pyross.deterministic.SEAIRQ.

SÃái = ‚àíŒªi (t)Si + œÉi ,
IÀôia = Œ±i Œ≥A Ai ‚àí Œ≥I a Iia ,
IÀôh = hi Œ≥I s I s ‚àí Œ≥I h I h ,

EÃái = Œªi (t)Si ‚àí Œ≥E Ei ,
IÀôs = Œ±ÃÑi Œ≥A Ai ‚àí Œ≥I s I s ,
i

i

AÃái = Œ≥E Ei ‚àí Œ≥A Ai
0
0
IÀôs = hÃÑi Œ≥I s I s ‚àí Œ≥ s0 I s
i

i

I

i

0
0
IÀôih = cÃÑi Œ≥I h Iih ‚àí Œ≥I h0 Iih ,
IÀôic = ci Œ≥I h Iih ‚àí Œ≥I c Iic ,
i
i
i
0
0
IÀôic = mÃÑi Œ≥I c Iic ‚àí Œ≥I c0 Iic ,
IÀôim = mi Œ≥I c Iic ,
NÃái = œÉi ‚àí mi Œ≥I c Iic
(4.9.1)
0

0

0

RÃái = Œ≥I a Iia + Œ≥I s0 Iis + Œ≥I h0 Iih + Œ≥I c0 Iic .
The rate of infection of a susceptible individual in age group i is
Œªi (t) = Œ≤

M
X
j=1

Is
Ih
Ia
a Aj
s j
h j
a j
+ Cij
+ Cij
+ Cij
Cij
Nj
Nj
Nj
Nj

!
,

(4.9.2)

s = f s C a ‚â° f s C and C s = f h C a ‚â° f h C . We note
Here hÃÑi = 1 ‚àí hi , mÃÑi = 1 ‚àí mi , Cij
ij
ij
ij
ij
ij
the individuals can be removed at any stage from either of the eight infection classes.

4.10 SEAIIRQ
This model is an extension of the SEAIIR model. We introduce the Qi class, which may
model individuals who have been tested and put into quarantine (and can therefore not
infect anyone else). This point of Qi class is to model a possible an implementation of

43

4 Bestiary

Figure 4.11.1: Schematic of the SIIRS model. The parameters for this model are:
Œ∏ = (Œ±i , Œ≤, Œ≥I a , Œ≥I s , ). The class SIIRS can be instantiated in PyRoss using
pyross.deterministic.SIRS.
contact tracing in PyRoss. Figure 4.10.1 shows the schematic. The deterministic dynamics
of the SEAIRQ model is given as:
SÃái = ‚àíŒªi (t)Si
EÃái = Œªi (t)Si ‚àí (Œ≥E + œÑE )Ei
AÃái = Œ≥E Ei ‚àí (Œ≥A + œÑA )Ai
IÀôia = Œ±i Œ≥A Ai ‚àí (Œ≥I a + œÑI a )Iia
IÀôis = Œ±ÃÑi Œ≥A Ai ‚àí (Œ≥I s + œÑI s )Iis

(4.10.1)

RÃái = Œ≥I a Iia + Œ≥I s Iis
QÃái = œÑS Si + œÑE Ei + œÑA Ai + œÑI s Iis + œÑI a Iia
The rate of infection of a susceptible individual in age group i is

M 
X
Is
Ia
a Aj
s j
a j
+ Cij
+ Cij
,
Œªi (t) = Œ≤
Cij
Nj
Nj
Nj

(4.10.2)

j=1

Here œÑE,A,I s ,I a is the testing rate in the population, these are in general different for different
classes. We have presumed that people in the incubation stage E can also be tested.

4.11 SIIRS
We now extend the age-structured SIR model to allow for removed persons to be susceptible
and for change in the population of each age group. Figure 4.11.1 shows the schematic.

44

4 Bestiary
model_spec = {
" classes " : [ " S " , " I " , " R " ] ,

"S" : {
" linear "
: [] ,
" infection " : [ [ " I " , " - beta " ] ]
},
"I" : {
" linear "
: [ [ " I " , " - gamma " ] ] ,
" infection " : [ [ " I " , " beta " ] ]
},
"R" : {
" linear "
: [ [ " I " , " gamma " ] ] ,
" infection " : []
}
}

Figure 4.12.1: Definition of the Spp class. The Spp class can be instantiated in PyRoss
using pyross.deterministic.Spp.
The deterministic dynamics of the resulting SIRS model is:
SÃái = ‚àíŒªi (t)Si + œÉi + (Œ≥I a Iia + Œ≥I s Iis )
IÀôia = Œ±i Œªi (t)Si ‚àí Œ≥I a Iia + li
IÀôis = Œ±ÃÑi Œªi (t)Si ‚àí Œ≥I a Iis

(4.11.1)

RÃái = Œ≥I a Iia + Œ≥I s Iis .
NÃái = œÉi + li
Here  is fraction of removed who is susceptible. œÉi denotes of the arrival of new susceptibles,
while li are new asymptomatic infectives. This means that Ni is now dynamical. The rate
of infection of a susceptible individual in age group i is same as in the SIIR model.

4.12 Generic user-defined model
If the plethora of models described in the preceding sections are not enough, then PyRoss
provides the additional class pyross.deterministic.Spp (pronounced ‚ÄúS plus plus‚Äù), which
has the ability to simulate any generic compartmental model. The model is specified by
providing a Python dictionary, and supports age-differentiated parameters. As an example,
the SIR model, defined in the Spp class, is given in Fig.4.12.1.
Currently, the Spp class supports the two types of terms which all the compartmental
models above share: linear terms and infection terms. The class could be used to simulate

45

4 Bestiary
any generic age-structured epidemiological compartment model, where the rates could be
both time and state dependent.
Note that pyross.deterministic.Spp is designed with generality rather than optimality in
mind. A model implemented using pyross.deterministic.Spp will in general perform worse
than any of the corresponding hard-coded classes above.

46

5 Applications
In this chapter, we provide illustrative examples of usage of the PyRoss library.

5.1 Basic reproductive ratio R0 from local rate of growth
Our first example is on computing the basic reproductive ratio R0 as a function of intervention measures. In a population of susceptibles Si , the expected number of secondary
infections arising from a single individual during the entire infectious period is defined as
R0 [14, 48]. We obtain the basic reproductive ratio of the SIR model, defined in section
4.1, by linearising the dynamics about the disease-free fixed point, where Si = Ni . The
time evolution of infectives is governed by
J = Œ≥(L ‚àí 1).

(5.1.1)

Here 1 is the identity matrix and
L=

Œ±Œ≤
Ni
Cij
.
Œ≥
Nj

It is sufficient for the spectral radius of L to be greater than unity for the epidemic to grow.
The R0 is then obtained as the spectral radius of L [14, 48]:
R0 ‚â° œÅ(L) = max{|Œõ1 |, . . . , |ŒõM |}.

(5.1.2)

We can now extend the linearisation at any point in time t by making the replacements Ni
‚àí‚Üí Si (t) and Cij ‚àí‚Üí Cij (t) in the expression for L, giving the time-dependent stability
matrix L(t) [16], and thus, define effective time-dependent basic reproductive ratio
(t)

(t)

(t)
Reff
0 (t) ‚â° œÅ(L ) = max{|Œõ1 |, . . . , |ŒõM |}

(5.1.3)

We now provide illustrative examples of measuring R0 and Reff 0 (t). In Fig.(5.1.1), we
obtain the basic reproductive ration as intervention measures are changed.
import pyross
import matplotlib . pyplot as plt , numpy as np
M =16
# # number of age classes
my_data = np . genfromtxt ( ‚Äô UK . csv ‚Äô , delimiter = ‚Äô , ‚Äô , skip_header =1)
Ni = ( my_data [: ,1]+ my_data [: ,2]) [0: M ]

47

5 Applications
# contact structure of the UK
ukCH , ukCW , ukCS , ukCO = pyross . contactMatrix . UK ()
aH , aW , aS , aO = 1 , 1 , 1 , 1
CH , CW , CS , CO = aH * ukCH , aW * ukCW , aS * ukCS , aO * ukCO
beta = 1
# the probability of infection on contact
gIa
= 1./7
# removal rate of asymptomatic infectives
gIs
= 1./7
# removal rate of symptomatic infectives
alpha = 0.
# asymptomatic fraction
fsa
= 1
# suppresion of contact by symptomatics
parameters = { ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô fsa ‚Äô: fsa , ‚ÄôM ‚Äô
:M , ‚Äô Ni ‚Äô: Ni }
contactMatrix = pyross . contactMatrix . SIR ( CH , CW , CS , CO )
r0UK1 = contactMatrix . bas ic Re p ro duc ti veR ati o ( parameters )
# switch off contacts at work
aH , aW , aS , aO = 1 , 0 , 1 , 1
CH , CW , CS , CO = aH * ukCH , aW * ukCW , aS * ukCS , aO * ukCO
contactMatrix = pyross . contactMatrix . SIR ( CH , CW , CS , CO )
r0UK2 = contactMatrix . bas ic Re p ro duc ti veR ati o ( parameters )
# switch off contacts at work and school
aH , aW , aS , aO = 1 , 0 , 0 , 1
CH , CW , CS , CO = aH * ukCH , aW * ukCW , aS * ukCS , aO * ukCO
contactMatrix = pyross . contactMatrix . SIR ( CH , CW , CS , CO )
r0UK3 = contactMatrix . bas ic Re p ro duc ti veR ati o ( parameters )
# switch off all contacts but at home
aH , aW , aS , aO = 1 , 0 , 0 , 0
CH , CW , CS , CO = aH * ukCH , aW * ukCW , aS * ukCS , aO * ukCO
contactMatrix = pyross . contactMatrix . SIR ( CH , CW , CS , CO )
r0UK4 = contactMatrix . bas ic Re p ro duc ti veR ati o ( parameters )
r0 = np . array ([ r0UK1 , r0UK2 , r0UK3 , r0UK4 ]) / r0UK1
plt . bar ( range ( r0 . size ) , r0 , align = ‚Äô center ‚Äô , alpha =0.5) ;
plt . ylabel ( r ‚Äô$ \ mathcal R_0 /\ mathcal R ^{{1}} _0$ ‚Äô)
labelY = ( ‚Äô All open ‚Äô , ‚Äô Work close ‚Äô , ‚Äô School close ‚Äô , ‚Äô All close ‚Äô ) ;
plt . xticks ( range ( r0 . size ) , labelY ) ;

48

5 Applications

Figure 5.1.1: The basic reproductive ratio as a function of intervention measures.
The y-axis is normalized by the case without no intervention measures. Here
‚ÄòW+S close‚Äô means both work and school are closed and R10 is the basic
reproductive ration without any intervention measure.

5.2 Beyond R0 : Kreiss constant K(J )
In the previous section, we used linearisation to study growth of epidemic. The prediction
made by linearised theory is based on the fact that the growth rate of a linear system is
exponential in the largest eigenvalue. This is well known in the epidemiology community,
where the value of R0 is used as a measure of how dangerous an epidemic will become and
on what timescale. On the other hand, far less well known is the transient effect due to
non-normality of J on the initial dynamics. There have been some papers [49, 50] in the
ecology community on this effect in the context of population dynamics. The best way to
understand why non-normality can be important is through an instructive example. Let
x = xÃÑ + u,
du
= J (t, Œ∏, xÃÑ) ¬∑ u
dt
Consider,
Ô£´
Ô£∂
‚àí1 500
Ô£∏
J =Ô£≠
0 ‚àí2
import pyross
import numpy as np , matplotlib . pyplot as plt
import scipy . linalg as spl
from scipy . integrate import solve_ivp
from pyross . contactMatrix import cha rac te ris e_ tra nsi en t
M = 2
N = 100000

# the SIR model has no age structure
# the total population

49

5 Applications

Ni = np . zeros (( M ) )
# population in each group
fi = np . zeros (( M ) )
# fraction of population in age age group
fi = np . array ((0.25 , 0.75) )
for i in range ( M ) :
Ni [ i ] = fi [ i ]* N
beta = 0.02
gamma = 0.007
gIa
= gamma
gIs
= gamma
alpha = 0
fsa
= 1
Ia0 = np . array ([0 ,0])
Is0 = np . array ([1 ,.1])
R0 = np . array ([0 ,0])
initially
S0 = Ni - Ia0 - Is0 - R0

# infection rate
#
#
#
#
#
#
#

removal rate of asymptomatic infectives
removal rate of symptomatic infectives
fraction of asymptomatic infectives
the self - isolation parameter
the SIR model has only one kind of infective
we take these to be symptomatic
and assume there are no removed individuals

# set the contact structure
C11 , C22 , C12 = 1 ,1 ,4
C = np . array (([ C11 , C12 ] , [ C12 * fi [1]/ fi [0] , C22 ]) )
def contactMatrix ( t ) :
return C
# duration of simulation and data file
Tf = 160; Nt =160;
# instantiate model
parameters = { ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô fsa ‚Äô: fsa }
model = pyross . deterministic . SIR ( parameters , M , Ni )
# simulate model
data = model . simulate ( S0 , Ia0 , Is0 , contactMatrix , Tf , Nt )
# matrix for linearised dynamics
C = contactMatrix (0)
A =(( beta *C - gamma * np . identity ( len ( C ) ) ) . T * fi ) . T / fi
mcA = pyross . contactMatrix . c ha rac te ris e_t ra nsi en t (A , ord =1)
AP = A - np . max ( np . linalg . eigvals ( A ) ) * np . identity ( len ( A ) )
mcAA = pyross . contactMatrix . c h ara ct eri se _tr ans ie nt ( AP , ord =1)
# plot the data and obtain the epidemic curve
Sa = data [ ‚ÄôX ‚Äô ][: ,:1]. flatten () ; Sk = data [ ‚ÄôX ‚Äô ][: ,1: M ]. flatten ()
Isa = data [ ‚ÄôX ‚Äô ][: ,2* M :2* M +1]. flatten () ; Isk = data [ ‚ÄôX ‚Äô ][: ,2* M +1:3* M ]. flatten ()
St = Sa + Sk ; It = Isa + Isk
# It = np . sqrt ( Isa **2 + Isk **2)
t = data [ ‚Äôt ‚Äô]
fig = plt . figure ( num = None , figsize =(10 , 8) , dpi =80 , facecolor = ‚Äôw ‚Äô ,
edgecolor = ‚Äôk ‚Äô)
plt . fill_between (t , 0 , St /N , color = " #348 ABD " , alpha =0.3)
plt . plot (t , St /N , ‚Äô - ‚Äô , color = " #348 ABD " , label = ‚Äô $S$ ‚Äô , lw =4)
plt . fill_between (t , 0 , It /N , color = ‚Äô# A60628 ‚Äô , alpha =0.3)
plt . plot (t , It /N , ‚Äô - ‚Äô , color = ‚Äô# A60628 ‚Äô , label = ‚Äô $I$ ‚Äô , lw =4)
Rt =N - St - It ; plt . fill_between (t , 0 , Rt /N , color = " dimgrey " , alpha =0.3)
plt . plot (t , Rt /N , ‚Äô - ‚Äô , color = " dimgrey " , label = ‚Äô $R$ ‚Äô , lw =4)
plt . autoscale ( enable = True , axis = ‚Äôx ‚Äô , tight = True )

50

5 Applications
# ## Estimate from Kreiss constant
plt . plot (t , mcAA [2]* It [0]* np . exp ( mcA [0]* t ) /N , ‚Äô - ‚Äô , color = " green " ,
label = ‚Äô $Estimate$ ‚Äô , lw =4)
plt . yscale ( ‚Äô log ‚Äô) ; plt . xlabel ( " time " ) ; plt . ylabel ( " % of population " ) ;
plt . legend ( fontsize =26) ; plt . grid () ; plt . show ()
def linear_system (t , x , A ) : return A@x
A2 = np . array ([[3 ,2] ,[9 ,4]])
x0 , tf = [1 ,1] , 1
ivp_exp = solve_ivp ( linear_system , (0 , tf ) , x0 , args =[ A2 ] , t_eval = np . arange
(0 , tf ,.1) )
t = ivp_exp . t
Gamma = A2 - np . max ( spl . eigvals ( A2 ) ) * np . identity ( len ( A2 ) )
mcA2 = ch ara ct eri se _tr ans ie nt ( Gamma )
ivp_exp2 = solve_ivp ( linear_system , (0 , tf ) , x0 , args =[ Gamma ] , t_eval = np .
arange (0 , tf ,.01) )
f , ax = plt . subplots ()
plt . plot ( ivp_exp2 .t , spl . norm ( ivp_exp2 . y .T , axis =1) / spl . norm ( x0 ) )
ax . set_xlabel ( " time " ) ; ax . set_ylabel ( r ‚Äô$ | u |/| u_0 | $ ‚Äô)
ax . plot (t , np . exp ( mcA2 [0]* t ) ," --" , color = " darkgreen " )
ax . set_ylim (( -.1 , np . max ( spl . norm ( ivp_exp2 . y .T , axis =1) / spl . norm ( x0 ) ) *1.1) )
t_trunc = t [ np . where (t < mcA2 [3]) ]
ax . plot ( t_trunc , np . exp ( mcA2 [1]* t_trunc ) ," --" , color = " orange " )
plt . axhline ( y = mcA2 [2] , linestyle = " dotted " , color = " black " )
plt . ylim ([.98 ,1.4]) ; plt . annotate ( r ‚Äô Long time behaviour $ \ alpha (\ Gamma ) $ ‚Äô ,
[.2 ,1.01])
plt . annotate ( r ‚Äô Initial growth rate $ \ omega (\ Gamma ) $ ‚Äô ,[.0 ,1.05] , rotation
=68)
plt . annotate ( r ‚Äô Kreiss constant $ \ mathcal { K } (\ Gamma ) $ ‚Äô , [.4 ,1.3]) ; plt . show
()

Obviously the eigenvalues are ‚àí1, ‚àí2 so a simple eigenvalue criterion would expect an
exponential decay of any initial perturbations. However, let u0 = (0, 1) and it is obvious
that |u| is dramatically magnified in value. After a long enough time, the system will
obviously decay to 0 but in a non-linear system, transient amplification may have a dramatic
effect on the long term dynamics if a system is only locally stable around some fixed point
[51, 52]. The behaviour results from the non-normality of J . Normal matrices are defined
as J J T = J T J , which, by the spectral theorem, is the criterion for diagonalisability.
Obviously eigenvalues alone cannot hope to encapsulate the full picture here. Here we
show these effects can be encapsulated by the introduction of a single new multiplicative
parameter and can be used to better understand the initial growth dynamics.
The transient is best characterized by the Kreiss constant K(J ) which provides a lower
bound to the maximum amplitude of a system evolving under J [49, 51, 53]. For a system
that grows with time, the ‚Äúextra increase‚Äù can be estimated by
K(J ‚àí ŒªMax (J )),
The associated system uÃá = (J ‚àí ŒªM ax I) u = Œìu has the solution
u(t) =

eJt
eŒªMax t

u(0) ‚Üí K(Œì)u(0).
t‚Üí‚àû

51

5 Applications

(a)

(b)

Figure 5.2.1: Effect of non-normality on the dynamics. (a) The evolution of the
associated : (a) The evolution of the associated . The non-normality of C
results in a greater total number of infected, plotted in green. . The system
quickly saturates the Kreiss bound and asymptotically tends towards normal
evolution along it. (b) the 2-age structured SIR model with contact matrix

52

5 Applications
In practice, the bound is well saturated over the time scale of the transient œÑ which is
usually much faster than any other dynamics of the system (and can be estimated from
pseudospectral methods [53] )
u(t) ‚Üí K(Œì)u(0)
t‚ÜíœÑ

Thus, the solution to our initial equation uÃá = J u can be estimated as
u(t) = eŒªMax t K(Œì)u(0).

(5.2.1)

In summary, the maximum eigenvalue and the Kreiss constant of the associated system
together characterise the initial growth of non-normal evolution as seen in Eq.(5.2.1) and
5.2.1. This new parameter acts as an amplification of the initial conditions based on the
degree of non-normality of our network and is general for any type of network, for example
age structure or geographical information.

5.3 Stochastic sampling
We now illustrate the usage of PyRoss for stochastic sampling of epidemics.
import numpy as np
import pyross
import matplotlib . pyplot as plt
M = 1
Ni = 1000* np . ones ( M )
N = np . sum ( Ni )
group

# the SIR model has no age structure
# so there is only one age group
# and the total population is the size of this age

beta
gIa
gIs
alpha
fsa

#
#
#
#
#

=
=
=
=
=

0.2
0.1
0.1
0
1

Ia0 = np . array ([0])
Is0 = np . array ([5])
R0 = np . array ([0])
initially
S0 = N -( Ia0 + Is0 + R0 )
from S + Ia + Is + R

infection rate
removal rate of asymptomatic infectives
removal rate of symptomatic infectives
fraction of asymptomatic infectives
self - isolation of symtomatic infectives
# the SIR model has only one kind of infective
# we take these to be symptomatic
# and assume there are no removed individuals
# so that the initial susceptibles are obtained
= N

# there is no contact structure
def contactMatrix ( t ) :
return np . identity ( M )
# duration of simulation and data file
Tf = 160; Nt =160;
# instantiate model
parameters = { ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô fsa ‚Äô: fsa }
model = pyross . stochastic . SIR ( parameters , M , Ni )

53

5 Applications

# simulate model
data = model . simulate ( S0 , Ia0 , Is0 , contactMatrix , Tf , Nt )
# plot the compartments
pyross . utils . plotSIR ( data )
# plot the basic reproductive ratio as a function of time
C = np . identity ( M )
contactMatrix = pyross . contactMatrix . SIR (0.25* C , 0.25* C , 0.25* C , 0.25* C )
r0de = contactMatrix . b asi cR ep r odu ct ive Ra tio ( data , state = ‚Äô dynamic ‚Äô)
t = data [ ‚Äôt ‚Äô]
plt . fill_between (t , 0 , t *0+1 , color = " dimgrey " , alpha =0.2)
plt . plot ( r0de , ‚Äô* ‚Äô , color = ‚Äô# A60628 ‚Äô)
plt . xlabel ( ‚Äô Days ‚Äô) ; plt . grid ()
plt . ylabel ( ‚Äô Basic reproductive ratio ‚Äô)
plt . autoscale ( enable = True , axis = ‚Äôx ‚Äô , tight = True ) ;
plt . yticks ( np . arange (0 , 3 , step =0.5) ) ; plt . ylim (0 ,2.2) ;
plt . show ()

(b)

1.0
0.8

Basic reproductive ratio

Fraction of compartment value

(a)

S
I
R

0.6
0.4
0.2
0.0

0

20

40

60

2.0
1.5
1.0
0.5
0.00

80 100 120 140 160
Days

20

40

60

80 100 120 140 160
Days

Figure 5.3.1: A stochastic realisation of the SIR model, c.f. example 5.3. Subplot
(a) shows a resulting epidemic curve, i.e. a plot of the number of susceptibles, infectives and removed as a function of time. Subplot (b) depicts the
corresponding basic reproductive ratio.

5.4 Deterministic integration
We now illustrate the usage of PyRoss for deterministic sampling of epidemics.
import numpy as np
import pyross
import matplotlib . pyplot as plt
M = 1
Ni = 1000* np . ones ( M )

# the SIR model has no age structure
# so there is only one age group

54

5 Applications
N = np . sum ( Ni )
group

# and the total population is the size of this age

beta
gIa
gIs
alpha
fsa

#
#
#
#
#

=
=
=
=
=

0.2
0.1
0.1
0
1

Ia0 = np . array ([0])
Is0 = np . array ([1])
R0 = np . array ([0])
initially
S0 = N -( Ia0 + Is0 + R0 )
from S + Ia + Is + R

infection rate
recovery rate of asymptomatic infectives
recovery rate of symptomatic infectives
fraction of asymptomatic infectives
self - isolation of symtomatic infectives
# the SIR model has only one kind of infective
# we take these to be symptomatic
# and assume there are no removed individuals
# so that the initial susceptibles are obtained
= N

# there is no contact structure
def contactMatrix ( t ) :
return np . identity ( M )
# duration of simulation and data file
Tf = 160; Nt =160;
# instantiate model
parameters = { ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô fsa ‚Äô: fsa }
model = pyross . deterministic . SIR ( parameters , M , Ni )
# simulate model
data = model . simulate ( S0 , Ia0 , Is0 , contactMatrix , Tf , Nt )
# plot the compartments
pyross . utils . plotSIR ( data )
# plot the basic reproductive ratio as a function of time
C = np . identity ( M ) ; contactMatrix = pyross . contactMatrix . SIR (0.25* C , 0.25* C ,
0.25* C , 0.25* C )
r0de = contactMatrix . b asi cR ep r odu ct ive Ra tio ( data , state = ‚Äô dynamic ‚Äô)
plt . plot ( r0de , ‚Äô* ‚Äô , color = ‚Äô# A60628 ‚Äô)

55

5 Applications

Figure 5.4.1: A deterministic realisation of the SIR model, c.f. example 5.4. The
left panel shows a resulting epidemic curve, i.e. a plot of the number of susceptibles, infectives and removed as a function of time. The right panel depicts
the corresponding basic reproductive ratio.

5.5 Bayesian inference and forecasting
In this example, a trajectory of an SIIR model with two age groups is generated using pyross
.stochastic. Based on the first 20 datapoints of the trajectory, pyross.inference is then used
to infer the parameters of the time series. Finally, using pyross.forecast, predictions based
the inferred parameters are made and compared to the original SIIR trajectory.
import numpy as np
import matplotlib . pyplot as plt
import pyross
# 1. Define model
# number of age groups and total population
M = 2
# the population has two age groups
N = 5 e4
# and this is the total population
# exact
beta =
gIa
=
gIs
=
alpha =
fsa
=

parameters of reference trajectory
0.02
# infection rate
1./7
# removal rate of asymptomatic infectives
1./7
# removal rate of asymptomatic infectives
0.2
# fraction of asymptomatic infectives
0.8
# self - isolation of symtomatic infectives

# set the age structure
fi = np . array ([0.25 , 0.75])
Ni = N * fi

# fraction of population in age age group

# set up initial condition
Ia0 = np . array ([10 , 10]) # each age group has asymptomatic infectives
Is0 = np . array ([10 , 10])
# and also symptomatic infectives

56

5 Applications
R0
S0

= np . array ([0 , 0]) # there are no removed individuals initially
= Ni - ( Ia0 + Is0 + R0 ) # initial number of susceptibles

# set the contact matrix
C = np . array ([[18. , 9.] , [3. , 12.]])
contactMatrix = lambda t : C
# 2. Use pyross stochastic to generate reference trajectory
Tf = 100; Nf = Tf +1 # reference trajectory is 100 days long
parameters = { ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô fsa ‚Äô: fsa }
sto_model = pyross . stochastic . SIR ( parameters , M , Ni )
data = sto_model . simulate ( S0 , Ia0 , Is0 , contactMatrix , Tf , Nf )
data_array = data [ ‚ÄôX ‚Äô]
# 3. Run inference on the first 20 days
# create array with first 20 days of data
Tf_inf = 20; Nf_inf = Tf_inf + 1
data_inf = ( data_array / N ) [: Nf_inf ]
# parameters for inference
ftol = 1e -6
steps = 101
estimator = pyross . inference . SIR ( parameters , M , fi , int ( N ) , steps )
# initial guesses , bounds , and initial standard deviation for solver
alpha_g = 0.15
alpha_std = 0.2
alpha_bounds = (1 e -3 , 0.5)
beta_g = 0.05
beta_std = 0.1
beta_bounds = (1 e -3 , 1)
gIa_g = 0.13
gIa_std = 0.1
gIa_bounds = (1 e -3 , 1)
gIs_g = 0.15
gIs_std = 0.1
gIs_bounds = (1 e -3 , 1)
guess = np . array ([ alpha_g , beta_g , gIa_g , gIs_g ])
stds = np . array ([ alpha_std , beta_std , gIa_std , gIs_std ])
bounds = np . array ([ alpha_bounds , beta_bounds , gIa_bounds , gIs_bounds ])
keys = [ ‚Äô alpha ‚Äô , ‚Äô beta ‚Äô , ‚Äô gIa ‚Äô , ‚Äô gIs ‚Äô]
params = estimator . infer_parameters ( keys , guess , stds , bounds , data_inf ,
Tf_inf , Nf_inf , contactMatrix ,
global_max_iter =20 , global_ftol_factor
=10 ,
verbose = True )
print ( params )
# for forecasting we also need the covariance matrix
hess = estimator . compute_hessian ( keys , params , guess , stds ,
data_inf , Tf_inf , Nf_inf , contactMatrix )

57

5 Applications
cov = np . linalg . inv ( hess )
# 4. Run forecast using inferred parameters and their covariance
# instantiate model
parameters = { ‚Äô alpha ‚Äô: params [0] , ‚Äô beta ‚Äô: params [1] ,
‚Äô gIa ‚Äô: params [2] , ‚Äô gIs ‚Äô: params [3] , ‚Äô fsa ‚Äô: fsa , ‚Äô cov ‚Äô: cov }
model_forecast = pyross . forecast . SIR ( parameters , M , Ni )
# initial condition for forecast is final state from inference
S0_fc = data_inf [ -1 ,: M ]* N
Ia0_fc = data_inf [ -1 , M :2* M ]* N
Is0_fc = data_inf [ -1 ,2* M :]* N
# run forecast
Tf_fc = Tf - Tf_inf ; Nf_fc = Tf_fc +1 # simulation time for forecast
Ns = 500 # number of forecasting samples
result_fc = model_forecast . simulate ( S0_fc , Ia0_fc , Is0_fc ,
contactMatrix , Tf_fc , Nf_fc , Ns = Ns )
trajectories_fc = result_fc [ ‚ÄôX ‚Äô]
t_fc = result_fc [ ‚Äôt ‚Äô] + Tf_inf
# 5. Visualise result : plot fraction of symptomatic infectives
traj_ref = np . sum ( data_array [: ,2* M :] , axis = -1) # reference trajectory
trajs_fc = np . sum ( trajectories_fc [: ,2* M :] , axis =1) # predictions
mean_fc = np . mean ( trajs_fc , axis =0) # mean prediction
fig , ax = plt . subplots (1 ,1 , figsize =(7 ,5) )
ax . axvspan (0 , Tf_inf , label = ‚Äô Range used for inference ‚Äô ,
alpha =0.3 , color = ‚Äô dodgerblue ‚Äô)
for i , e in enumerate ( trajs_fc ) : # plot all forecasting trajectories
ax . plot ( t_fc , e /N , alpha =0.1)
ax . plot ( traj_ref /N , lw =3 , color = ‚Äô# A60628 ‚Äô , label = ‚Äô Reference trajectory ‚Äô)
ax . plot ( t_fc , mean_fc /N ,
ls = ‚Äô -- ‚Äô , color = ‚Äô limegreen ‚Äô , label = ‚Äô Mean prediction ‚Äô , lw =3)
ax . set_xlim (0 , np . max ( t_fc ) )
ax . set_xlabel ( r ‚Äô Days ‚Äô)
ax . set_ylabel ( ‚Äô Fraction of symptomatic infectives ‚Äô)
ax . legend ( loc = ‚Äô upper right ‚Äô , fontsize =12)
plt . grid () ; plt . show ()
plt . close ( fig )

58

5 Applications

Fraction of symptomatic infectives

0.175

Reference trajectory
Mean prediction
Range used for inference

0.150
0.125
0.100
0.075
0.050
0.025
0.000
0

20

40

Days

60

80

100

Figure 5.5.1: Bayesian inference and forecasting. Example 5.5 creates a trajectory
(solid red line), estimates the model parameters based on the beginning of the
trajectory (blue shaded region), and uses the estimated parameters to make
predictions for the future time evolution (thin colored lines, with mean given
by a thick dashed line).

5.6 Effect of event-driven NPI
In this example, an event-driven protocol is defined: Once the number of symptomatic
infectives exceeds a threshold, the contact matrix is reduced to the home contact; then,
once the number of infectives falls below another threshold, the original contact matrix is
restored. For an SEkIkIkR model with 16 age groups based on the UK age structure, and
UK contact matrices, we run this protocol in two variations: First, we allow every event to
happen at most one time; in the second run, we allow events to repeat. Note that while
this example employs UK age groups and contact structure, the model parameters are not
fitted to real epidemiological data.
import numpy as np
import matplotlib . pyplot as plt
import pyross
# 1. Load age structure and contact matrices of the UK
M =16

# number of age classes

# load age structure

59

5 Applications
my_data = np . genfromtxt ( ‚Äô ../ data / age_structures / UK . csv ‚Äô ,
delimiter = ‚Äô , ‚Äô , skip_header =1)
aM , aF = my_data [: , 1] , my_data [: , 2]
Ni0 = aM + aF
Ni = Ni0 [: M ] # consider first M age groups in data
N = np . sum ( Ni ) # total population is sum over all age groups
# get individual contact matrices
CH , CW , CS , CO = pyross . contactMatrix . UK ()
# without interventions , the contact matrix is the sum of those
C = CH + CW + CS + CO
# 2. Define model
# parameters
alpha = 0.3
beta = 0.0165
gE
= 1/2.72
kI
= 4;
kE
= 4;
gIa = 1./7
gIs = 1./17.76
fsa = 0.8

#
#
#
#
#
#
#
#

fraction of symptomatics who self - isolate
probability of infection on contact
recovery rate of exposeds
# of stages of I class
# of stages of E class
recovery rate of asymptomatic infectives
recovery rate of symptomatic infectives
the self - isolation parameter

# set up initial condition
S0 = np . zeros ( M )
I0 = np . zeros (( kI , M ) ) ;
E0 = np . zeros (( kE , M ) ) ;
for i in range ( kI ) :
I0 [i , 6:13]=14; I0 [i , 2:6]=13
for i in range ( kE ) :
E0 [i , 0:16]=14
for i in range ( M ) :
S0 [ i ] = Ni [ i ] - np . sum ( I0 [: , i ]) - np . sum ( E0 [: , i ])
I0 = np . reshape ( I0 , kI * M ) / kI ;
E0 = np . reshape ( E0 , kE * M ) / kE ;
# 3. Define events and corresponding contact matrices
l o c k d o wn_threshold_1 = 1 e6
l o c k d o wn_threshold_2 = 2000
#
events = []
contactMatrices = []
# Note that the event functions take a vector argument
# " xt " instead of a tuple (S , E0 , Ia , Is ) .
# When defining the event functions for the SEkIkIkR
# model , the following correspondence has to be used :
# S == xt [
: M]
# E == xt [1* M
:(1+ kE ) * M ]
# Ia == xt [(1+ kE ) * M
:(1+ kE + kI ) * M ]
# Is == xt [(1+ kE + kI ) * M :(1+ kE + kI + kI ) * M ]
# ( For any model , the order for the event functions is
# exactly the same as in the arguments of model . simulation )
# This is a dummy event which will never occur ;

60

5 Applications
# it is used to set the initial contact matrix
def event0 (t , xt ) :
return t + 1
event0 . direction = +1
events . append ( event0 )
contactMatrices . append ( C )
# Lockdown on
def event1 (t , xt ) :
return np . sum ( xt [(1+ kE + kI ) * M :(1+ kE +2* kI ) * M ]) - lockdown_threshold_1
event1 . direction = +1 # need to pass threshold from below for event
events . append ( event1 )
contactMatrices . append ( CH ) # only home contact matrix
# Lockdown off
def event2 (t , xt ) :
return np . sum ( xt [(1+ kE + kI ) * M :(1+ kE +2* kI ) * M ]) - lockdown_threshold_2
event2 . direction = -1 # need to pass threshold from above for event
events . append ( event2 )
contactMatrices . append ( C )
# 4. Run pyross . control simulation twice : Once with events only
#
occuring once , and once with events possibly several times
# instantiate model
parameters = { ‚Äô beta ‚Äô: beta , ‚Äô gE ‚Äô: gE , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs ,
‚Äô kI ‚Äô: kI , ‚Äô kE ‚Äô : kE , ‚Äô fsa ‚Äô: fsa , ‚Äô alpha ‚Äô: alpha }
model = pyross . control . SEkIkIkR ( parameters , M , Ni )
# Run 1: each event only occurs once
Tf = 2*365 # 2 years
Nt = ( Tf +1) *10 # return 10 datapoints per day
result_1 = model . simulate ( S0 , E0 , 0* I0 , I0 ,
events = events , contactMatrices = contactMatrices ,
Tf = Tf , Nf = Nt , events_repeat = False )
# Run 2: events can repeat
Tf = 8*365 # 8 years
Nt = ( Tf +1) *10 # return 10 datapoints per day
result_2 = model . simulate ( S0 , E0 , 0* I0 , I0 ,
events = events , contactMatrices = contactMatrices ,
Tf = Tf , Nf = Nt , events_repeat = True )
# 5. Visualise results
def plot_result ( result , title = None ) :
t_arr = result [ ‚Äôt ‚Äô]
traj = result [ ‚ÄôX ‚Äô]
Is = model . Is ( result )
Is = np . sum ( Is , axis = -1)
events_occured = result [ ‚Äô events_occured ‚Äô]
#
fig , ax = plt . subplots (1 ,1)
if title != None :
ax . set_title ( title )
ax . axhline ( lockdown_threshold_1 , label = ‚Äô Threshold event 1 ‚Äô ,
ls = ‚Äô -- ‚Äô , color = ‚Äô dodgerblue ‚Äô)

61

5 Applications
ax . axhline ( lockdown_threshold_2 , label = ‚Äô Threshold event 2 ‚Äô ,
ls = ‚Äô -- ‚Äô , color = ‚Äô limegreen ‚Äô)
for i , e in enumerate ( events_occured [::2]) :
if 2* i + 1 < len ( events_occured ) :
if i == 0:
label = ‚Äô NPI ‚Äô
else :
label = ‚Äô ‚Äô
ax . axvspan ( e [0] , events_occured [2* i +1][0] ,
label = label ,
alpha =0.15 , color = ‚Äô crimson ‚Äô)
ax . plot ( t_arr , Is , color = ‚Äô# A60628 ‚Äô , label = r ‚Äô $I_s$ ‚Äô)
ax . set_xlim ( np . min ( t_arr ) , np . max ( t_arr ) )
ax . set_ylabel ( ‚Äô Compartment population ‚Äô) ; ax . set_xlabel ( r ‚Äô Days ‚Äô)
ax . legend ( loc = ‚Äô upper right ‚Äô , fontsize =12)
plt . grid () ; plt . show () ; plt . close ( fig )
plot_result ( result_1 , title = ‚Äô Each event occurs once ‚Äô)
plot_result ( result_2 , title = ‚Äô Events can repeat ‚Äô)

62

5 Applications

Each event occurs once

(a) 1e6

Is
Threshold event 1
Threshold event 2
NPI

Compartment population

8
6
4
2
0

0

100

200

300

400

500

600

700

Events can repeat

(b) 1e6
1.2

Compartment population

Days

1.0
0.8

Is
Threshold event 1
Threshold event 2
NPI

0.6
0.4
0.2
0.0

0

500

1000

1500
Days

2000

2500

Figure 5.6.1: Effect of event-driven NPI on model dynamics. In example 5.6, an
event-driven protocol is defined. Once the number of symptomatic infectives
exceeds a threshold, the contact matrix is reduced to the home contacts; once
the number of infectives falls below another threshold, the original contact
matrix is restored. Subfigures (a) and (b) use the same events, but while in
(a) each event can only occur once, in (b) events can occur several times.

5.7 Optimising parameters of NPI
In the present example, an intervention protocol is optimised. We consider the SIIR model
with two age groups, with fictitious parameters and a fictitious contact matrix. The protocol
consists of two durations, namely
‚Ä¢ the duration T1 of a full lockdown (implemented in this toy model by reducing the
initial contact matrix via a prefactor 1/4), and

63

5 Applications
‚Ä¢ the duration T2 a subsequent partial lockdown (implemented in this toy model by
reducing the initial contact matrix via a prefactor 3/4).
For illustrative purposes we choose the cost function
 

Z
T2
1 tf
C = exp Œ∫ T1 +
dt Is (t),
+
5
œÑ 0

(5.7.1)

where tf = 1000 days is the final time of the simulation, and Is (t) is the total number of
symptomatic infectives at time t. The first term in equation (5.7.1) can be thought of as a
cost for social distancing, while the second terms models a cost of infection. The time scale
œÑ determines the relative importance of the two terms, and in our example we use œÑ = 1.
We additionally set C = ‚àû if at any time Is (t) > 2000, which serves as a hard constraint
that every protocol must keep the number of infectives below a threshold. The rate Œ∫ in the
first term of equation (5.7.1) determines the exponential increase in cost per time during
lockdown, and in the present example we minimise the total cost as a function of (T1 , T2 ),
considering three distinct scenarios: i) low cost of social distancing (Œ∫ = 0.01/day), ii)
intermediate cost of social distancing (Œ∫ = 0.1/day), and iii) high cost of social distancing
(Œ∫ = 1/day). Finally, we compare the time series corresponding to these optimal protocols.
import numpy as np
import matplotlib . pyplot as plt
import pyross
from multiprocessing import Pool
import cma
import time
from functools import partial
# 1. Define model
# number of age groups and total population
M = 2
# the population has two age groups
N = 5 e4
# and this is the total population
# model
beta =
gIa
=
gIs
=
alpha =
fsa
=

parameters
0.02
1./7
1./7
0.2
0.8

#
#
#
#
#

infection rate
removal rate of asymptomatic infectives
removal rate of asymptomatic infectives
fraction of asymptomatic infectives
the self - isolation parameter

# set the age structure
fi = np . array ([0.25 , 0.75])
Ni = N * fi
# set
Ia0 =
Is0 =
R0 =
S0 =

# fraction of population in age age group

up initial condition
np . array ([10 , 10]) # each age group has asymptomatic infectives
np . array ([10 , 10])
# and also symptomatic infectives
np . array ([0 , 0]) # there are no removed individuals initially
Ni - ( Ia0 + Is0 + R0 ) # initial number of susceptibles

64

5 Applications
# 2. Define function that generates two - step release protocol
def get_events ( protocol = [50 ,100]) :
end_phase_1 , end_phase_2 = protocol
C = np . array ([[18. , 9.] , [3. , 12.]])
events = []; contactMatrices = []
# Note that the event functions take a vector argument
# " xt " instead of a tuple (S , Ia , Is ) .
# When defining the event functions for the SIR
# model , the following correspondence has to be used :
# S == xt [ : M ]
# Ia == xt [1* M :2* M ]
# Is == xt [2* M :3* M ]
# ( For any model , the order for the event functions is
# exactly the same as in the arguments of model . simulation )
#
# This is a dummy event which will never occur ;
# it is used to set the initial contact matrix
events . append ( lambda t , xt : 1. )
contactMatrices . append ( C )
# Event 1: contact matrix reduced by a factor of 4 once
# number of symptomatic infectives exceeds a threshold
# (" start of full lockdown ")
l o c kdown_ thres hold_o n = 1900
def event1 (t , xt ) :
return np . sum ( xt [2* M :3* M ]) - l ockdo wn_thr eshol d_on
event1 . direction = +1 # need to pass threshold from below for event
events . append ( event1 ) ; contactMatrices . append ( 0.25* C )
# Event 2: contact matrix at 75% of original contact matrix after
# a given time (" start of partial lockdown ") .
def event2 (t , xt ) :
return t - end_phase_1
events . append ( event2 ) ; contactMatrices . append ( 0.75* C )
# Event 3: original contact matrix is restored after a given time
# (" end of partial lockdown ") .
def event3 (t , xt ) :
return t - end_phase_2
events . append ( event3 ) ; contactMatrices . append ( C )
return events , contactMatrices
# 3. Define cost function
m a x i m a l_value_for_Is = 2000
def e v a lua te_ co st_ fu nct io n ( t_arr , traj , protocol , events_occured ,
sdc_prefactor =1. ,
sdc_rate =1/7.) :
infinity = 1 e300 # using np . inf would be more proper , but will
# result in warnings throughout the minimization once a protocol
# is probed that violates one of the hard constraints .
#
# hard constraints :
# - times of protocol need to be non - negative
if ( np . array ( protocol ) < 0) . any () : return infinity
# - second stage of intervention needs to end after first stage ends
if protocol [0] > protocol [1]: return infinity
# - second stage of intervention needs to end before 700 days
if protocol [1] > 700: return infinity
# - number of symptomatic infectives should

65

5 Applications
#
never exceed a given maximal value
if np . max ( np . sum ( traj [2* M :3* M ] , axis =0 ) ) > maximal_value_for_Is :
return infinity
# Evaluate results of protocol .
# Which phases have occured in the simulation ?
h ave_lockdown_start = False
h ave_lockdown_end_0 = False
h ave_lockdown_end_1 = False
for i , e in enumerate ( events_occured ) :
if e [1] == 1:
lockdown_start = e [0]
have_lockdown_start = True
elif e [1] == 2:
lockdown_end_0 = e [0]
have_lockdown_end_0 = True
elif e [1] == 3:
lockdown_end_1 = e [0]
have_lockdown_end_1 = True
# calculate cost function
cost = 0.
# cost of social distancing
if have_lockdown_start :
if have_lockdown_end_0 :
cost += sdc_prefactor * np . exp ( sdc_rate * \
( lockdown_end_0 - lockdown_start ) )
else :
cost += infinity
#
if have_lockdown_end_0 and have_lockdown_end_1 :
cost *= np . exp (0.2* sdc_rate *( lockdown_end_1 - lockdown_end_0 ) )
# cost of infection
cost += np . trapz ( np . sum ( traj [2* M :3* M ] , axis = 0 ) , t_arr )
return cost
# 4. Define function that evaluates the cost of a given protocol
def e v a l ua t e _ c o s t _ o f _p r o t o c o l ( model , protocol ,
verbose = False , return_trajectory = False ,
sdc_prefactor =10. ,
sdc_rate =1/7.) :
# define events corresponding to given protocol
events , contactMatrices = get_events ( protocol )
# run simulation
Tf = 1000; Nt = ( Tf +1) *10
result = model . simulate ( S0 , Ia0 , Is0 ,
events = events , contactMatrices = contactMatrices ,
Tf = Tf , Nf = Nt )
# evaluate cost
cost = ev alu at e_c os t_f unc ti on ( t_arr = result [ ‚Äôt ‚Äô] ,
traj = result [ ‚ÄôX ‚Äô ]. T ,
protocol = protocol ,
events_occured = result [ ‚Äô events_occured ‚Äô] ,
sdc_prefactor = sdc_prefactor ,
sdc_rate = sdc_rate )
if return_trajectory :

66

5 Applications
return cost , result [ ‚Äôt ‚Äô] , result [ ‚ÄôX ‚Äô] , result [ ‚Äô events_occured ‚Äô]
else :
return cost
# 5. Define minimiser
def mi nimizing_function ( sdc_prefactor , sdc_rate ,
protocol ) :
# This is the function that will be minimised by the cma - es algorithm
costs = e v a l ua t e _ c o s t _ o f _p r o t o c o l ( model = model ,
protocol = protocol ,
sdc_prefactor = sdc_prefactor ,
sdc_rate = sdc_rate ,
return_trajectory = False )
return costs
def f i nd_opt imal_ protoc ol ( initial_guess , sdc_prefactor , sdc_rate ,
model ,
verbose = True , initial_variance =5.) :
func = partial ( minimizing_function , sdc_prefactor , sdc_rate )
# set parameters for minimisation based on cma - es algorithm
number_of_threads = 4
number_iterations = 1000
p = Pool ( number_of_threads )
options = cma . CMAOptions ()
options [ ‚Äô popsize ‚Äô] = 12
# run minimisation
start_time = time . time ()
optim = cma . CMAEvolutionStrategy ( initial_guess , initial_variance ,
options )
iteration = 0
while not optim . stop () and iteration < number_iterations :
positions = optim . ask ()
values = p . map ( func , positions )
optim . tell ( positions , values )
optim . disp ()
iteration += 1
end_time = time . time ()
if verbose :
print ( " Time : " , end_time - start_time )
print ( " Value : " , optim . best . f )
print ( " Parameters : " , optim . best . x )
return optim . best . x
# 6. Find optimal protocol for three different scenarios
# Initialise model
parameters = { ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô fsa ‚Äô: fsa }
model = pyross . control . SIR ( parameters , M , Ni )
initial_guess =[70 ,200] # use same initial guess for all minimisations
sdc_prefactor = 1. # means that social distancing cost and
# cost of infection have the same weight in our model
# Low , intermediate , and high cost rate for social distancing :
sdc_rates = [1 e -2 ,1 e -1 ,1.]
optim al_protocols = []
for i , sdc_rate in enumerate ( sdc_rates ) :

67

5 Applications
optimal_protocol = fi nd_o p timal_ proto col ( initial_guess = initial_guess ,
sdc_prefactor = sdc_prefactor ,
sdc_rate = sdc_rate ,
model = model )
optimal_protocols . append ( optimal_protocol )
# 7. Visualise results
def plot_result ( protocol , model ,
title = ‚Äô Optimised intervention parameters ‚Äô ,
t_max = None ) :
#
cost , t_arr , traj , events_occured = e v a lu a t e _ c o s t _ of _ p r o t o c o l (
model = model ,
protocol = protocol ,
return_trajectory = True )
Is = np . sum ( traj [: ,2* M :] , axis = -1)
fig , ax = plt . subplots (1 ,1 , figsize =(7 ,5) )
ax . set_title ( title )
ax . axhline ( maximal_value_for_Is , color = ‚Äô red ‚Äô , ls = ‚Äô -- ‚Äô ,
label = r ‚Äô Constraint ‚Äô)
ax . axvspan ( events_occured [0][0] , events_occured [1][0] ,
color = ‚Äô crimson ‚Äô , label = ‚Äô Intervention 1 ‚Äô , alpha =0.2)
ax . axvspan ( events_occured [1][0] , events_occured [2][0] ,
color = ‚Äô orange ‚Äô , label = ‚Äô Intervention 2 ‚Äô , alpha =0.2)
ax . plot ( t_arr , Is )
if t_max == None :
ax . set_xlim ( np . min ( t_arr ) , np . max ( t_arr ) )
else :
ax . set_xlim ( np . min ( t_arr ) , t_max )
ax . set_ylabel ( ‚Äô Symptomatic infectives ‚Äô)
ax . set_xlabel ( r ‚Äô time [ days ] ‚Äô)
ax . legend ( loc = ‚Äô upper right ‚Äô , fontsize =12 , framealpha =1.)
plt . show () ; plt . close ( fig )
o p t i m a l _ pr ot o co l_ la b el s = [ ‚Äô Low cost of social distancing ‚Äô ,
‚Äô Intermediate cost of social distancing ‚Äô ,
‚Äô High cost of social distancing ‚Äô]
t_max = [700 ,250 ,250]
for i , optimal_protocol in enumerate ( optimal_protocols ) :
plot_result ( protocol = optimal_protocol , model = model , t_max = t_max [ i ] ,
title = op t im al _p r ot oc ol _ la be l s [ i ])

68

5 Applications

Symptomatic infectives

(a)

2000
1750
1500
1250
1000
750
500
250
00

Symptomatic infectives

(b)

Symptomatic infectives

(c)

2000
1750
1500
1250
1000
750
500
250
00

2000
1750
1500
1250
1000
750
500
250
00

Low cost of social distancing

Constraint
Intervention 1
Intervention 2
100

200

300

time [days]

400

500

600

700

Intermediate cost of social distancing

Constraint
Intervention 1
Intervention 2

50

100

time [days]

150

200

250

High cost of social distancing

Constraint
Intervention 1
Intervention 2
50

100

time [days]

150

200

250

Figure 5.7.1: Optimisation of NPI protocol parameters, c.f. example 5.7. The protocol consists of two durations, namely the time of a full lockdown (initial
contact matrix reduced via a prefactor 1/4), and a subsequent partial lockdown (initial contact matrix reduced via a prefactor 3/4). The cost of a
protocol is comprised of a i) cost for social distancing (= reducing the entries of the contact matrix), and ii) a cost of infection. As a hard constraint,
the protocol must keep the number of infectives below a defined threshold,
69
shown as horizontal dashed line. The optimal protocol minimises the total
cost. Subplots (a), (b), (c), show three results of optimisation for the same
system, depending on the cost of social distancing.

5 Applications

5.8 Model sensitivity
Here we illustrate the usage of PyRoss to study model sensitivity. We use four different
models, SIR, SEIR, SIR with stages, and SEIR with stages. The models predict similar
epidemic curve before the lockdown, while the they show distinct behavior after lockdown.
We show that the addition of an exposed Ei compartment (to give an age-structured SEIR
model) makes the infectious number grows beyond the lockdown for the time scale of the
incubation. Note that while this example employs UK age groups and contact structure,
the model parameters are not fitted to real epidemiological data.
import numpy as np
import pyross
import matplotlib . pyplot as plt
# # population and age classes
M =16 # # number of age classes
my_data = np . genfromtxt ( ‚Äô India -2019. csv ‚Äô , delimiter = ‚Äô , ‚Äô , skip_header =1)
Ni = ( my_data [: , 1]+ my_data [: , 2]) [0: M ]
# Get individual contact matrices
CH , CW , CS , CO = pyross . contactMatrix . India ()
# Generate contact matrix
generator = pyross . contactMatrix . Cont actMa trixFu nctio n ( CH , CW , CS , CO )
Tf =42; Nf =600
times = [21 , Tf ] # temporal boundaries between different contact - behaviour
aW , aS , aO = 0.0 , 0.0 , 0.0
# prefactors for CW , CS , CO :
interventions = [[1.0 ,1.0 ,1.0] ,
# before first time
[ aW , aS , aO ] ,
# between first and second time
]
# generate corresponding contact matrix function
contactMatrix = generator . i nt erv en tio ns_ te mpo ra l ( times = times , interventions =
interventions )
# ## SIR
beta = 0.01646692
# probability of infection on contact
gIa
= 1./7
# removal rate of asymptomatic infectives
gIs
= 1./7
# removal rate of symptomatic infectives
alpha = 0.
# asymptomatic fraction
fsa
= 1
# suppresion of contact by symptomatics
# initial conditions
Is_0 = np . zeros (( M ) ) ; Is_0 [6:13]=14; Is_0 [2:6]=13
Ia_0 = np . zeros (( M ) )
R_0 = np . zeros (( M ) )
S_0 = Ni - ( Ia_0 + Is_0 + R_0 )
parameters = { ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô fsa ‚Äô: fsa }
model = pyross . deterministic . SIR ( parameters , M , Ni )
dataSIR = model . simulate ( S_0 , Ia_0 , Is_0 , contactMatrix , Tf , Nf )
I1 = model . Is ( dataSIR )
# ## SEIR
beta = 0.027

# probability of infection on contact

70

5 Applications
gIa
= 1./7
# removal rate of asymptomatic infectives
gE
= 1/2.72
# removal rate of exposeds
gIs
= 1./7
# removal rate of symptomatic infectives
alpha = 0.
# asymptomatic fraction
fsa
= 1
# suppresion of contact by symptomatics
Is_0 = np . zeros (( M ) ) ; Is_0 [6:13]=14; Is_0 [2:6]=13
Ia_0 = np . zeros (( M ) )
E_0 = np . zeros (( M ) ) ;
R_0 = np . zeros (( M ) )
S_0 = Ni - ( Ia_0 + Is_0 + R_0 )
param ={ ‚Äô alpha ‚Äô: alpha , ‚Äô beta ‚Äô: beta , ‚Äô gIa ‚Äô: gIa , ‚Äô gIs ‚Äô: gIs , ‚Äô gE ‚Äô: gE , ‚Äô fsa ‚Äô: fsa }
model = pyross . deterministic . SEIR ( param , M , Ni )
dataSEIR = model . simulate ( S_0 , E_0 , Ia_0 , Is_0 , contactMatrix , Tf , Nf )
I2 = model . Is ( dataSEIR )
# SIR with stages ( SIkR )
beta = 0.01324
# probability of infection on contact
gI
= 1./7
# removal rate of infectives
gE
= 1/2.72
# removal rate of exposeds
kI
= 32;
# # of stages of I class
I0 = np . zeros (( kI , M ) ) ;
for i in range ( kI ) :
I0 [i , 6:13]=14; I0 [i , 2:6]=13
S0 = np . zeros ( M )
for i in range ( M ) :
S0 [ i ] = Ni [ i ] - np . sum ( I0 [: , i ])
I0 = np . reshape ( I0 , kI * M ) / kI
parameters = { ‚Äô beta ‚Äô: beta , ‚Äô gI ‚Äô: gI , ‚Äô kI ‚Äô: kI }
model = pyross . deterministic . SIkR ( parameters , M , Ni )
dataSIkR = model . simulate ( S0 , I0 , contactMatrix , Tf , Nf )
I3 = model . I ( dataSIkR )
# SEIR with stages ( SEkIkR )
beta = 0.0188
# probability of infection on contact
gI
= 1./7
# removal rate of infectives
gE
= 1/2.72
# removal rate of exposeds
kI
= 32;
# # of stages of I class
kE
= 2;
# # of stages of E class
S0 = np . zeros ( M )
I0 = np . zeros (( kI , M ) ) ;
E0 = np . zeros (( kE , M ) ) ;
for i in range ( kI ) :
I0 [i , 6:13]=14; I0 [i , 2:6]=13
for i in range ( kE ) :
E0 [i , 0:16]=14
for i in range ( M ) :
S0 [ i ] = Ni [ i ] - np . sum ( I0 [: , i ]) - np . sum ( E0 [: , i ])
I0 = np . reshape ( I0 , kI * M ) / kI ;
E0 = np . reshape ( E0 , kE * M ) / kE ;
parameters = { ‚Äô beta ‚Äô: beta , ‚Äô gE ‚Äô: gE , ‚Äô gI ‚Äô: gI , ‚Äô kI ‚Äô: kI , ‚Äô kE ‚Äô : kE }
model = pyross . deterministic . SEkIkR ( parameters , M , Ni )
data = model . simulate ( S0 , E0 , I0 , contactMatrix , Tf , Nf ) ; I4 = model . I ( data )
asI1 , asI2 , asI3 , asI4 = I1 . sum ( axis =1) , I2 . sum ( axis =1) , I3 . sum ( axis =1) , I4 . sum (
axis =1) # sum over all ages

71

5 Applications

plt . plot (t , asI1 , ‚Äô - ‚Äô , lw = lwd , color = ‚Äô# A60628 ‚Äô , label = ‚Äô SIR ‚Äô)
plt . plot (t , asI3 , ‚Äô - ‚Äô , lw = lwd , color = ‚Äô #348 ABD ‚Äô , label = ‚Äô SIkR ‚Äô)
plt . plot (t , asI2 , ‚Äô - ‚Äô , lw = lwd , color = ‚Äô goldenrod ‚Äô , label = ‚Äô SEIR ‚Äô)
plt . plot (t , asI4 , ‚Äô - ‚Äô , lw = lwd , color = ‚Äô forestgreen ‚Äô , label = ‚Äô SEkIkR ‚Äô)
plt . xlabel ( ‚Äô Days ‚Äô) ; plt . ylabel ( ‚Äô Infected individuals ‚Äô) ;

Figure 5.8.1: Model-dependence of dynamics after lockdown. In example 5.8, the
models SIR, SEIR, SIR with stages, and SEIR with stages, are considered.
Parameters are chosen such that the initial grow rates are comparable. Initially, all models use the full contact matrix, which is the sum of home, work,
school, and other contacts. At a fixed time, a lockdown is modeled by retaining only the home contacts. This plot illustrates the resulting different model
dynamics at the initial phase of the lockdown.

72

6 Conclusion
This report has presented an overview of PyRoss, a Python library that integrates compartment models of epidemics with Bayesian inference and optimization tools.
The current focus of PyRoss, and hence of this report, is on well-mixed, age-structured
models with a modest number of contact channels (home, school, workplace, other). However, PyRoss allows these channels to be expanded indefinitely in principle, so that more
complex contact information relating to particular working or social environments can be
incorporated as available.
Likewise PyRoss allows the disease stages themselves to be subdivided at will. This
enables the statistics of objective medical states, such as hospitalization and intensive care
or ventilator use, to be modelled. By also allowing an indefinitely expandable number
of compartments per disease stage, the residence time distribution in such stages can be
varied from the exponential decay of simple compartment models to the sharply-peaked
distribution that underlies time-since-infection models [10‚Äì15]. Certain other mathematical
limitations can be overcome similarly.
NPIs are viewed within PyRoss as strategies to influence contact matrices, generally in a
time-dependent fashion, through variations in contact rate, or transmission rate at contact,
or both. These interventions can be represented in as much social detail as is resolved by
the contact matrices themselves.
A Bayesian system of inference for model parameters, and for forecasting with error
estimation, is fully integrated into PyRoss. The former is a crucial feature which allows
comparison between models based on evidence. This can guide a principled expansion in
the number of compartments up to a level of granularity justified by the data, and can
warn when this has gone too far. The approach guards against over-fitting of historic data,
leading to precise but inaccurate forecasting ‚Äì a risk faced by parameter-rich, data-poor
models in any field of science.
One can expect robust inference from historic data to prove crucial for forecasting the future course of an epidemic, particularly where sequenced or nuanced NPIs are involved. Accordingly, PyRoss‚Äôs Bayesian parameter estimation tools allow the fitting of time-dependent
contact-matrix parameters representing NPIs. Prior estimates (supplied perhaps by expert
judgement) of the effect of an NPI on contact statistics can therefore be continuously improved, after the NPI is implemented, by feeding the observed results back into the system
(Fig. 2.0.1). Observed outcomes for one NPI (such as sudden lockdown) can inform the
prediction of others (such as a sequential, age-stratified unlock).
Within PyRoss, given a user-defined cost function that encodes their harm, NPIs can be

73

6 Conclusion
optimized and ranked by minimization of the chosen cost function. The actual choice of cost
functions is, of course, morally and politically problematic. However, there are many other
areas of planning where saving life is weighed against economic cost, including decisions
about where and whether to build a new hospital, or indeed a new road.
The principles of compartment modelling embraced by PyRoss, when constrained by
a disciplined approach to parameter and uncertainty estimation, are, we believe, more
powerful than is widely assumed, but of course not all-powerful. Known challenges include
situations in which the well-mixed approximation does not hold at small scales, such as the
fact that isolation by household can allow rapid disease spread within each household while
preventing it at societal level. Redesign of the compartment structure to reflect a different
‚Äòunit of infection‚Äô, such as a household, may help in some such cases.
In contrast, there is no problem of principle in extending compartment models to societies
that are locally well mixed but heterogeneous at larger scales. Different contact matrices
can be assigned at regional level and/or to micro-locations such as specific workplaces or
social venues. Once such geo-social compartments are resolved, the transition rates between
them are controlled by human mobility which can itself be modelled by jumps into and out
of compartments representing journeys (within which infection can of course occur). NPIs
can then separately target either the locationally specific contact matrices, or the transfer of
people between locations. In a forthcoming report we will describe PyRossGeo, an extension
of PyRoss along these lines.
This report has focussed on the design principles and capabilities of PyRoss, illustrated
by very simple examples of its use. We have not deployed it directly here to address aspects
of the current COVID-19 crisis, but for an example of its use in doing so, see [16]. (Note
that since that paper was written, the capabilities of PyRoss have advanced dramatically.)
The PyRoss library is open-source. We positively encourage its use by other scientists,
whether seasoned epidemic modellers or those new to the field. We hope it can contribute
to a stronger scientific platform for evidence-based decision making as the current pandemic
continues, and also before the next one.

74

6 Conclusion

Acknowledgement
The work described in this report was completed in the six weeks spanning April to midMay 2020 as a contribution to the Rapid Assistance in Modelling the Pandemic (RAMP)
initiative, coordinated by the Royal Society. The GitLab platform enabled seamless collaboration under lockdown conditions. We are grateful to the numerous developers who
contribute to the open-source platform on which PyRoss is built and without which it
would not exist. We acknowledge advice from Graeme Ackland, Daan Frenkel, Julia Gog,
Chris Rogers, and Richard Wilkinson. We thank the code review team of RAMP‚Äôs Rapid
Review Group at Oxford for their scrutiny of the PyRoss library and for their suggestions
for improvement; RAMP‚Äôs Red Team at Edinburgh further code review and stress testing;
and those who opened issues and offered suggestions on GitHub. Remaining defects in
the PyRoss library and in this report are the responsibility of the authors. This work was
funded in part by the European Research Council under the EU‚Äôs Horizon 2020 Program,
Grant No. 740269; by the Royal Society through a Research Professorship held by MEC,
and by an Early Career Grant to RA from the Isaac Newton Trust.

75

Bibliography
[1] R. M. Anderson, B. Anderson, and R. M. May. Infectious diseases of humans: dynamics
and control. Oxford university press, 1992.
[2] M. J. Keeling and P. Rohani. Modeling infectious diseases in humans and animals.
Princeton University Press, 2011.
[3] N. T. J. Bailey. The mathematical theory of infectious diseases and its applications.
Charles Griffin & Company Ltd, 5a Crendon Street, High Wycombe, Bucks HP13
6LE., 1975.
[4] D. Anderson and R. Watson. On the spread of a disease with gamma distributed latent
and infectious periods. Biometrika, 67(1):191‚Äì198, 1980.
[5] H. J. Wearing, P. Rohani, and M. J. Keeling. Appropriate models for the management
of infectious diseases. PLoS medicine, 2(7), 2005.
[6] O. Krylova and D. J. D. Earn. Effects of the infectious period distribution on predicted
transitions in childhood disease dynamics. Journal of The Royal Society Interface,
10(84):20130098, 2013.
[7] A. L. Lloyd. Realistic distributions of infectious periods in epidemic models: changing
patterns of persistence and dynamics. Theoretical population biology, 60(1):59‚Äì71, 2001.
[8] H. Barbosa, M. Barthelemy, G. Ghoshal, et al. Human mobility: Models and applications. Physics Reports, 734:1‚Äì74, 2018.
[9] S. M. Jenness, S. M. Goodreau, and M. Morris. Epimodel: an r package for mathematical modeling of infectious disease over networks. Journal of statistical software,
84, 2018.
[10] W. O. Kermack and A. G. McKendrick. A contribution to the mathematical theory
of epidemics. Proceedings of the royal society of london. Series A, Containing papers
of a mathematical and physical character, 115(772):700‚Äì721, 1927.
[11] J. Reddingius. Notes on the mathematical theory of epidemics. Acta biotheoretica,
20(3-4):125‚Äì157, 1971.

76

Bibliography
[12] L. Sattenspiel, K. Dietz, et al. A structured epidemic model incorporating geographic
mobility among regions. Mathematical biosciences, 128(1):71‚Äì92, 1995.
[13] F. Hoppensteadt. An age dependent epidemic model. Journal of the Franklin Institute,
297(5):325‚Äì333, 1974.
[14] O. Diekmann, J. A. P. Heesterbeek, and M. G. Roberts. The construction of nextgeneration matrices for compartmental epidemic models. J. Royal Soc. Int., 7(47):873‚Äì
885, 2010.
[15] H. R. Thieme and C. Castillo-Chavez. How may infection-age-dependent infectivity
affect the dynamics of HIV/AIDS? SIAM Journal on Applied Mathematics, 53(5):1447‚Äì
1479, 1993.
[16] Rajesh Singh and R Adhikari. Age-structured impact of social distancing on the covid19 epidemic in india. arXiv preprint arXiv:2003.12055, 2020.
[17] D. J. C. MacKay. Information theory, inference and learning algorithms. Cambridge
University Press, 2003.
[18] D. J. C. MacKay. Bayesian interpolation. Neural computation, 4(3):415‚Äì447, 1992.
[19] N. M. Ferguson et al. Impact of non-pharmaceutical interventions (npis) to reduce
covid-19 mortality and healthcare demand. London: Imperial College COVID-19 Response Team, March, 16, 2020.
[20] S. Towers and Z. Feng. Social contact patterns and control strategies for influenza in
the elderly. Math. Biosci., 240(2):241‚Äì249, 2012.
[21] N. M. Ferguson et al. Strategies for mitigating an influenza pandemic.
442(7101):448‚Äì452, 2006.

Nature,

[22] H. W. Hethcote. The mathematics of infectious diseases. SIAM review, 42(4):599‚Äì653,
2000.
[23] J. Glasser, Z. Feng, A. Moylan, S. Del Valle, and C. Castillo-Chavez. Mixing in
age-structured population models of infectious diseases. Mathematical Biosciences,
235(1):1‚Äì7, 2012.
[24] K. Prem, A. R. Cook, and M. Jit. Projecting social contact matrices in 152 countries
using contact surveys and demographic data. PLoS Comp. Bio, 13(9):e1005697, 2017.
[25] R. Ross. An application of the theory of probabilities to the study of a priori pathometry. Proceedings of the Royal Society of London, 92(638):204‚Äì230, 1916.

77

Bibliography
[26] S. Busenberg and C. Castillo-Chavez. A general solution of the problem of mixing of
subpopulations and its application to risk-and age-structured epidemic models for the
spread of aids. Mathematical Medicine and Biology: A Journal of the IMA, 8(1):1‚Äì29,
1991.
[27] J. Wallinga, Peter T., and M. Kretzschmar. Using data on social contacts to estimate
age-specific transmission parameters for respiratory-spread infectious agents. American
journal of epidemiology, 164(10):936‚Äì944, 2006.
[28] R. F. Pawula. Approximation of the linear boltzmann equation by the fokker-planck
equation. Phys. Rev., 162:186‚Äì188, Oct 1967.
[29] C. W. Gardiner. Handbook of stochastic methods. Springer Berlin, 1985.
[30] N. G. Van Kampen. Stochastic processes in physics and chemistry, volume 1. Elsevier,
1992.
[31] M. Komorowski, B. Finkenstaedt, C. V Harper, and D. A Rand. Bayesian inference of
biochemical kinetic parameters using the linear noise expansion. BMC Bioinformatics,
10(343), 2009.
[32] R. Singh, D. Ghosh, and R. Adhikari. Fast bayesian inference of the multivariate
ornstein-uhlenbeck process. Phys. Rev. E, 98:012136, Jul 2018.
[33] D. Maclaurin, D. Duvenaud, and R. P. Adams. Autograd: Effortless gradients in
numpy. In ICML 2015 AutoML Workshop, volume 238, 2015.
[34] https://github.com/kbarbary/nestle.
[35] J. Skilling. Nested sampling for general bayesian computation. Bayesian analysis,
1(4):833‚Äì859, 2006.
[36] James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary,
Dougal Maclaurin, and Skye Wanderman-Milne. JAX: composable transformations of
Python+NumPy programs, 2018.
[37] D. T. Gillespie. Exact stochastic simulation of coupled chemical reactions. The Journal
of Physical Chemistry, 81(25):2340‚Äì2361, December 1977.
[38] D. T. Gillespie. Approximate accelerated stochastic simulation of chemically reacting
systems. The Journal of Chemical Physics, 115(4):1716‚Äì1733, July 2001.
[39] Y. Cao, D. T. Gillespie, and L. R. Petzold. Efficient step size selection for the tauleaping simulation method. The Journal of Chemical Physics, 124(4):044109, January
2006.

78

Bibliography
[40] G. Wanner and E. Hairer. Solving ordinary differential equations II: Stiff and
differential-algebraic problems. Springer Berlin Heidelberg, 1996.
[41] E. Hairer, S. P N√∏rsett, and G. Wanner. Solving ordinary differential equations I:
Nonstiff problems, 1993.
[42] H. P. Langtangen and L. Wang. Odespy. https://github.com/hplgit/odespy, 2014.
[43] P. Virtanen, R. Gommers, T. E. Oliphant, et al. Scipy 1.0: fundamental algorithms
for scientific computing in python. Nature methods, 17(3):261‚Äì272, 2020.
[44] https://www.populationpyramid.net/.
[45] Z. Feng and H. R. Thieme. Endemic models with arbitrarily distributed periods of
infection i: Fundamental properties of the model. SIAM Journal on Applied Mathematics, 61(3):803‚Äì833, 2000.
[46] R. Pastor-Satorras, C. Castellano, P. Van Mieghem, and A. Vespignani. Epidemic
processes in complex networks. Reviews of modern physics, 87(3):925, 2015.
[47] M. Y. Li and J. S Muldowney. Global stability for the seir model in epidemiology.
Mathematical biosciences, 125(2):155‚Äì164, 1995.
[48] J. A. P. Heesterbeek. A brief history of R0 and a recipe for its calculation. Acta
biotheoretica, 50(3):189‚Äì204, 2002.
[49] S. Townley, D. Carslake, O. Kellie-Smith, D. Mccarthy, and D. Hodgson. Predicting
transient amplification in perturbed ecological systems. Journal of Applied Ecology,
44(6):1243‚Äì1251, 2007.
[50] I. Stott, D. J. Hodgson, and S. Townley. Beyond sensitivity: Nonlinear perturbation
analysis of transient dynamics. Methods in Ecology and Evolution, 3(4):673‚Äì684, 2012.
[51] M. Asllani, R. Lambiotte, and T. Carletti. Structure and dynamical behavior of nonnormal networks. Science Advances, 4(12):1‚Äì9, 2018.
[52] M. Asllani and T. Carletti. Topological resilience in non-normal networked systems.
Physical Review E, 97(4):1‚Äì12, 2018.
[53] L. N. Trefethen and M. Embree. Spectra and pseudospectra: the behavior of nonnormal
matrices and operators. Princeton University Press, 2005.

79

Appendix: Simple versus Complicated
Models
Let us imagine an alternative universe which contains a country resembling the UK, called
Simulana, for which the CovidSim model, with a specific parameter set as selected in [19],
describes the disease dynamics as well as one could wish. The government of Simulana
allow the epidemic to run its course without NPIs. Suppose that the only data available
to modellers in Simulana are time-resolved national aggregate statistics (S(t), I(t), R(t))
for the number of susceptibles, infecteds, and removeds. To forecast the epidemic, the
modellers adopt an age-unstructured SIkR model, with k, the number of infected subcompartments discussed above, set to k = 5. We emphasise that this is an utterly basic
model. Nonetheless, by fitting to the available data up to (say) the point where S = I,
Simulana‚Äôs modellers are able to predict its remaining course reasonably well, as shown in
Figure 6.0.1. Note that only the maximum a posteriori (MAP) prediction is shown although
PyRoss can deliver the full posterior distribution if required.
These predictions raise the following question: Unless the specific CovidSim parameters
that correctly describe epidemics in Simulana are disclosed upfront by revelation, is CovidSim in general much better at predicting epidemics there than, say, SI5R?
Interpreting this question in a strictly Bayesian sense of ‚Äòwhich model has more evidence‚Äô,
we suspect the answer is ‚Äòno‚Äô ‚Äì although to confirm this quantitatively would require a more
precise delineation of CovidSim‚Äôs free parameters than we currently have. This is because
the Bayesian ‚ÄòOccam factors‚Äô penalize models with parameters that are unconstrained by
the data available: the evidence for these models is small, whereas parsimonious models
always have larger evidence if equally capable of fitting the data.
But even if the question is interpreted less formally, we might also suspect a negative
answer. Given the limited medical data available in Simulana, it is not clear that this can
constrain CovidSim‚Äôs parameters sufficiently to give forecasts that are any more reliable
than those of much simpler models. This is despite the fact that using CovidSim the
epidemic in Simulana‚Äôs could be forecast perfectly in principle if the correct parameters
were known.
In the above example, the modellers of Simulana received only aggregate patient data;
alternatively they might receive data stratified by age, geography etc.. In this case the
shortcomings of SI5R for Simulana would soon be revealed by the Bayesian approach.
However, a generalized compartment model might well still beat CovidSim at ‚Äòpredicting
its own future‚Äô. Of particular promise are models whose compartments broadly aligned

80

Bibliography

Figure 6.0.1: Predictions from an unstructured SI5R model in Simulana. Simulana
is an imagined country where epidemics are correctly described by the CovidSim algorithm of [19] with some particular parameter set.
with the granularity of the data available, creating inbuilt parsimony.
It is very important to recognize that the above paragraphs contain no specific criticism
of CovidSim itself, or any other particular model. Instead they express a more general
concern about basing predictions on any model whose parameters have proliferated beyond
the ability of data to estimate them. Such concerns apply not only for epidemics but across
many other disciplines. They are one of the reasons so many scientists today prefer a
Bayesian approach to model and parameter selection, as offered by PyRoss for compartment
models.

81

