Polynomial Invariant Theory and Shape Enumerator of Self-Dual Codes
in the NRT-Metric
Welington Santos âˆ— Marcelo Muniz Silva Alves â€ 

arXiv:1904.04333v1 [cs.IT] 8 Apr 2019

Abstract
In this paper we consider self-dual NRT-codes, that is, self-dual codes in the metric space endowed with the
Niederreiter-Rosenbloom-Tsfasman (NRT-metric). We use polynomial invariant theory to describe the shape
enumerator [13] of a binary self-dual, doubly even self-dual, and doubly-doubly even self dual NRT-code C âŠ†
Mn,2 (F2 ). Motivated by these results we describe the number of invariant polinomials that we must find to
describe the shape enumerator of a self-dual NRT-code of Mn,s (F2 ). We define the ordered flip of a matrix
A âˆˆ Mk,ns (Fq ) and present some constructions of self-dual NRT-codes over Fq . We further give an application
of ordered flip to the classification of bidimensional self-dual NRT-codes.

1

Introduction

In classical coding theory, an [n, k]-linear code C is a subspace of the metric space Fsq , endowed with the Hamming
metric, which is defined by dH (u, v) := |{i such that ui 6= vi }| for u, v âˆˆ C âŠ† Fsq . An important tool in this
setting is the dual code C âŠ¥ of a linear code C âŠ† Fsq with respect to usual (euclidean) inner product on Fsq .
One of the most important theorems in coding theory is MacWilliamsâ€™ Theorem (1962), which is known as the
â€œMacWilliams Identitiesâ€, which relates the weight enumerator of a linear code and its dual code. A remarkable
theorem that is due to Gleason [17] shows that the weight enumerator of a binary doubly-even self-dual code is
a polynomial in others two polynomials, to name, the weight enumerator of the Hamming code of length 8 and
the Golay code of length 24. During the past few years Sloane et al. presented some generalizations of Gleasonâ€™s
Theorem to other families of codes [8, 18, 20, 21]. A technique that can be used to derive those generalizations is
the polynomial invariant theory, and in special the well-known Molienâ€™s series of a finite group of matrices [7].
Coding theory has also been developed with respect to alternative metrics. One of the most studied of those
metrics is the NRT-metric, which was introduced to study array codes that are subspaces of the linear space of all
n Ã— s matrices Mn,s (Fq ) with entries from a finite field. The NRT-metric space was introduced by Rosenbloom
and Tsfasman in [27] by considering a generalization of Reed-Solomon codes on the space of all n Ã— s matrices
Mn,s (Fq ); in this same paper the authors pointed out that this metric models transmission over a set of parallel
channels subject to fading. Since then several coding-theoretic questions with respect to this metric have been
investigated, such as MacWilliams Identities [9] and MDS codes [9, 11, 28]. Independently, Niederreiter [10]
worked with a maximization problem in finite vector spaces which turned out to be equivalent to coding theory
problems in NRT spaces, as was shown by Brualdi, Graves and Lawrence [6].
Dougherty and Skriganov showed in [9] that the weight enumerators of mutually NRT-dual codes may not
be related by any sort of MacWilliams Identities, in general, since there are examples of nonequivalent codes
which have the same weight enumerators but whose duals have distinct weight enumerators. However, in the same
paper they considered orbits of linear groups preserving the NRT-weight and showed that the weight enumerator
âˆ—
W. Santos is with the Programa de PÃ³s-GraduaÃ§Ã£o em MatemÃ¡tica, Universidade Federal do ParanÃ¡, Caixa Postal 19081, 81531990, Curitiba-PR Brazil. His study was financed in part by the CoordenaÃ§Ã£o de AperfeiÃ§oamento de Pessoal de NÃ­vel Superior- Brasil
(CAPES)-Finance Code 001. Email: wsantos.math@gmail.com
â€ 
Marcelo Muniz S. Alves is with the Departamento de MatemÃ¡tica, Universidade Federal do ParanÃ¡, Caixa Postal 19081, 81531-990,
Curitiba-PR Brazil. This work was partially supported by CNPq-Conselho Nacional de Desenvolvimento CientÃ­fico e TecnolÃ³gico, research
project number 306583/2016-0. Email: marcelomsa@ufpr.br

1

associated with such orbits (called H-enumerator) satisfies a MacWilliams type identity for mutually NRT-dual
codes.
Recently, Barg et al. [2, 4, 12, 13] introduced the definition of shapes of codewords and a shape enumerator
for NRT-codes. The shape enumerator coincides with the H-enumerator. Park and Barg in [13] obtained the
same MacWilliams Identity of [9] with a new proof based on a multivariate Tutte polynomial of a NRT-code and
centered in the concept of shape of a codeword.
In this contribution, we consider binary self-dual codes of Mn,s (F2 ), and we use polynomial invariant theory
and the MacWilliams Identity of [9, 13] to describe the shape enumerator of those codes. In particular, for binary
self-dual codes of Mn,2 (F2 ) we completely describe their shape enumerator; the same is done for binary doublyeven self-dual codes, and for binary doubly-doubly-even self dual codes of Mn,2 (F2 ). We describe the number of
invariant polinomials that we must find to describe the shape enumerator of a self-dual NRT-code of Mn,2 (F2 ). We
define the concept of ordered flip of a matrix A âˆˆ Mk,ns (Fq ) and present some constructions of self-dual codes
of Mn,s (Fq ) extending results for M1,s (Fq ) of [22]. Finally, we present an application of the ordered flip to the
classification of bidimensional self-dual codes.
This work is strutured as follows. In Sect. 2, we recall NRT-codes, the shape enumerator and the MacWilliams
Identity of [9, 13]. In Sect. 3, we recall polynomial invariant theory and Molienâ€™s Theorem [19, 23, 30]. In Sect.
4, we describe the shape enumerator of binary self-dual, doubly even self-dual, and doubly-doubly even self dual
NRT-codes of Mn,2 (F2 ). In Sect. 5, we describe the Molienâ€™s series of the invariant group of binary self-dual
NRT-codes of Mn,s (Fq ). In Sect. 6, we give some constructions of self-dual NRT-codes of Mn,s (Fq ) and an
application of the flip concept.

2

Codes and Niederreiter-Rosenbloom-Tsfasman Metric

Let Mn,s (Fq ) be the Fq -vector space of n Ã— s matrices with entries in Fq . Given an n Ã— s matrix v,
ï£¹
ï£®
v11 v12 Â· Â· Â· v1s
ï£¯ v21 v22 Â· Â· Â· v2s ï£º
ï£º
ï£¯
v=ï£¯ .
.. ï£º ,
..
..
ï£° ..
.
. ï£»
.
vn1 vn2 Â· Â· Â·

vns

its i-th row will be denoted by vi and we will write v = [v1 ; v2 ; Â· Â· Â· ; vn ]. Via this notation the NiederreiterRosenbloom-Tsfasman weight or, for short, the NRT-weigth of v is defined by the following formula:
Ï(v) :=

n
X

Ï(vi )

i=1

where Ï(vi ) := max {0 â‰¤ j â‰¤ s ; vij 6= 0}.
The canonical metric associated to the NRT- weight, dÏ (u, v) = Ï(u âˆ’ v), is called the NRT-metric.
Now let v = [v1 ; v2 ; Â· Â· Â· ; vn ] and u = [u1 ; u2 ; Â· Â· Â· ; un ] be two elements of Mn,s (Fq ). We define the inner
product h, iN on the space Mn,s (Fq ) endowed with the NRT-metric by
hv, uiN = hu, viN :=

n
X

hvi , ui iN

i=1

with
hvi , ui iN = hui , vi iN := vi1 uis + vi2 uisâˆ’1 + . . . + vsâˆ’12 ui2 + vis ui1 =

s
X

vij uis+1âˆ’j .

j=1

The space (Mns (Fq ), Ï) is called NRT-space and an [ns, k]-linear NRT-code is a linear subspace C âŠ† (Mns (Fq ), Ï)
of dimension k.

2

Definition 1. The dual code of an k-dimensional linear NRT-code C âŠ† Mn,s (Fq ) is defined to be the kâŠ¥ dimensional linear NRT-code C âŠ¥ âŠ† Mn,s (Fq ) given by
C âŠ¥ := {u âˆˆ Mn,s (Fq ) : hu, viN = 0 for all v âˆˆ C}.
A NRT-code C is said to be a self-orthogonal NRT-code if C âŠ† C âŠ¥ and self dual NRT-code if C = C âŠ¥ . Moreover,
the dimensions of the codes C and C âŠ¥ are related by the following equation: if k = dim(C) and kâŠ¥ = dim(C âŠ¥ )
then
k + kâŠ¥ = ns.
(2.1)

2.1

The Geometry of NRT-metric

Two NRT linear codes C and C â€² in Mn,s (Fq ) are equivalent if there is a linear isometry Ï† of Mn,s (Fq ) such that
Ï†(C) = C â€² . The group GL (Mn,s (Fq )) of linear isometries of an NRT space Mn,s (Fq ) was described in [3] (also
independently in [9]) and is isomorphic to the semidirect product of (Ts )n and Sn , where Ts is the group of all upper triangular matrices of Ms,s (Fq ) with non-zero diagonal elements, (Ts )n denotes the direct product of n copies
of Ts , and Sn is the symmetric group of order n. An element of Sn acts on v = [v1 ; v2 ; Â· Â· Â· ; vn ] by permuting
rows, and an element (M1 , M2 , . . . , Mn ) of Tsn sends v = [v1 ; v2 ; Â· Â· Â· ; vn ] to [v1 M1T ; v2 MnT ; Â· Â· Â· ; vn MnT ].
It is clear that if v = [v1 ; v2 ; Â· Â· Â· ; vn ] and u = [u1 ; u2 ; Â· Â· Â· ; un ] are two elements of Mn,s (Fq ) that lie in the
same GL (Mn,s (Fq ))-orbit then these matrices have the same NRT-weight. The converse will not hold in general,
since GL(Mn,s (Fq )) is not transitive on spheres. In order to parametrize the GL(Mn,s (Fq ))-orbits, which were
already studied in [9], Barg and Purkayastha [2] define a new parameter of the matrix v = [v1 ; v2 ; Â· Â· Â· ; vn ] âˆˆ
Mn,s (Fq ) which is called the shape of v.
Definition 2. Let v âˆˆ Mn,s (Fq ) be a matrix written as v = [v1 ; v2 ; Â· Â· Â· ; vn ], where vi = (vi1 , . . . , vis ) for
i = 1, . . . , n. The shape of v with respect to the NRT-weight is an s-vector e = (e1 , . . . , es ), where
ej = |{i such that 1 6 i 6 n and Ï(vi ) = j}|.
P
Also define e0 := n âˆ’ |e|, where |e| := sj=1 ej .

The action of GL(Mn,s (Fq )) on matrices of a fixed shape is transitive, and then the shape is an invariant for
this action. The NRT- weight can be also defined in terms of shapes: if e = (e1 , . . . , es ) is the shape of the matrix
v = [v1 ; v2 ; Â· Â· Â· ; vn ] âˆˆ Mn,s (Fq ) then
Ï(v) :=

s
X

jej .

j=1

2.2

The shape enumerator and a MacWilliams Identity

The NRT weight is a special case of poset weight as introduced by Brualdi, Graves and Lawrence in [6]. There is
a notion of dual code for every poset code but only in rare cases does the weight enumerator of the code determine
the enumerator of its dual; precisely, this is the case if and only if the poset is hierarchical [16], and an NRT weight
is associated to a hierarchical poset only when n = 1 or s = 1 (which corresponds to the Hamming weight).
Nevertheless, analogues of those identities do hold when one considers other kinds of enumerator polynomials. In
[9], Dougherty and Skriganov defined a generalized weight enumerator for a NRT-linear code, the H-enumerator,
which counts the number of codewords in each GL(Mn,s (Fq ))-orbit. In the same paper it was shown that the Henumerator of mutually dual codes satisfies a MacWilliams-type identity, which we will state next in the version
presented in [13], using the concept of shape vector.
A shape vector e defines a partition of n into a sum of s + 1 parts. We will denote by âˆ†s,n := {e âˆˆ Ns :
e0 + e1 + e2 + . . . + es 6 n} such partitions (recall that e0 = n âˆ’ |e|). In the language of shapes, the description
of GL(Mn,s (Fq ))-orbits is as follows
Proposition 3. ([9], Proposition 2.2 (ii)) The GL(Mn,s (Fq ))-orbits of a nonzero matrix u âˆˆ Mn,s (Fq ) is the set
of all vectors v âˆˆ Mn,s (Fq ) which have the same shape as u.
3

Definition 4. Let C âŠ† Mn,s (Fq ) be a NRT-linear code. The shape enumerator of C is the polynomial of
C[z0 , z1 , . . . , zs ] defined by
X
(2.2)
Ae z0e0 z1e2 . . . zses ,
HC (z0 , z1 , . . . , zs ) =
eâˆˆâˆ†s,n

where Ae = |{v âˆˆ C such that shape(v) = e}|.
The shape enumerator of a NRT-code C is a homogeneous polynomial HC (Z) with s + 1 variables which
coincides with the H-enumerator introduced in [9]. In order to state the MacWilliams identity shown in [9] we
need to introduce new notation.
The group GL(s + 1, C) of invertible (s + 1) Ã— (s + 1) matrices acts on the ring C[z0 , z1 , . . . , zs ] by
ï£¶
ï£«
s
s
X
X
as,j zj ï£¸ .
A Â· f (z0 , z1 , . . . , zs ) = f ï£­
a0,j zj , . . . ,
(2.3)
j=0

j=0

We may describe the action in a more concise manner. Consider the â€œvector of variablesâ€ Z = (z0 , z1 , . . . , zs )t .
The previous equation may be rewritten as
A Â· f (Z) = f (AZ).
Using this notation, the next result presents the MacWilliams identity for the shape enumerator.
Theorem 5. [13] The shape enumerator of mutually dual NRT-linear codes C and C âŠ¥ âŠ† Mn,s (Fq ) are related
by
1
HC (Î˜s Z),
HC âŠ¥ (Z) =
|C|
where Î˜s = (Î¸lk ) âˆˆ Ms+1,s+1 (Fq ) , 0 6 l, k 6 s, has the following entries
ï£±
1
if l = 0,
ï£´
ï£´
ï£² lâˆ’1
q (q âˆ’ 1) if 0 < l 6 s âˆ’ k,
.
Î¸lk =
âˆ’q lâˆ’1
if l + k = s + 1,
ï£´
ï£´
ï£³
0
if l + k > s + 1.

3

3.1

Polynomial Invariant Theory

Invariant Homogeneous Polynomial Basis

Let G be a finite subgroup of GL(n, C) and consider its action on the polynomial ring C[x1 , . . . , xn ] defined as in
(2.3).
We recall that f (x1 , . . . , xn ) is called an invariant of G, or a G-invariant, if for every A âˆˆ G
A Â· f (x1 , . . . , xn ) = f (x1 , . . . , xn ).
Clearly if f , g are invariants of G so are f + g and f g, it means that the set of invariants form a ring which
will be denoted by J (G).
It is well-known that every invariant polynomial can be written as a sum of homogeneous invariant polynomials. So given a finite group G < Mn,n (C) it is enought to characterize all homogeneous polynomials that are
invariant over G to describe the invariant ring J (G) of G.
However, a convenient description of J (G) is a set of homogeneous invariants B = {f1 , . . . , fl } such that
every polynomial in J (G) is a polynomial in f1 , . . . , fl . Then in this case B = {f1 , . . . , fl } is called a polynomial
basis for J (G). If l > n there will be equations, which are called syzygies, relating f1 , . . . , fl .
A finite polynomial basis of J (G) always exists when G is finite, this was shown by E. Noetherâ€™s Theorem
[18, 29, 30]. Find invariant polynomials is fairly easy using the following theorem.
4

Theorem 6. (Reynolds operator) Let f âˆˆ C[x1 , . . . , xn ] be a polynomial and G < GL(n, C) a finite group. Then
X
h(x1 , . . . , xn ) =
A Â· f (x1 , . . . , xn )
AâˆˆG

is an invariant of G, that is, h âˆˆ J (G).
Definition 7. Given a finite group G < GL(n, C), a good polynomial basis for J (G) consists of homogeneous
invariants f1 , . . . , fl (l â‰¥ n) such that f1 , . . . fn are algebraically independent and
J (G) = C[f1 , . . . , fn ]

if

l = n,

or, if l > n,
J (G) = C[f1 , . . . , fn ] âŠ• fn+1 C[f1 , . . . , fn ] âŠ• Â· Â· Â· âŠ• fl C[f1 , . . . , fn ].
This means that when l = n any G-invariant can be written as a polynomial in f1 , . . . , fn and, if l > n, as such
a polynomial plus fn+1 times another such polynomial and so on. The polynomials f1 , . . . , fn are called primary
invariants and fn+1 , . . . , fl are secondary invariants.
Theorem 8. (Hochster and Eagon [23]) A good polynomial basis exists for the invariants of any finite group of
complex n Ã— n matrices.
There are some criteria in literature that help to find out when a set of polynomials is algebraically independent.
In this work we use a useful tool that is know as the Jacobian criterion.
Theorem 9. (Jacobian criterion [14, 15]) f1 , . . . , fl âˆˆ C[x1 , . . . , xn ] are algebraically independent if only if the
Jacobian matrix is full rank. In particular, if m = n, f1 , . . . , fl are algebraically dependent if only if the Jacobian
determinant det(J(f1 , . . . , fl )) 6= 0.

3.2

Molienâ€™s Theorem

A fundamental problem is to know, or at least estimate, how many algebraically independent invariants are required
to form a polynomial basis of J (G). The next two theorems tell us how many linearly independent homogeneous
invariants exist for each degree t.
Theorem 10. (Molien [7]) Given a finite group G < GL(n, C) the number of linearly independent invariants
over G of the first degree is
1 X
trace(A).
|G|
AâˆˆG

Theorem 11. (Molien [7]) Let G < GL(n, C) be a finite group. Then, the number of linearly independent
invariants of G of degree t is the coefficient of Î»t in the expansion of
1
1 X
.
Î¦G (Î») =
|G|
det(I âˆ’ Î»A)
AâˆˆG

Î¦G (Î») is called the Molien series of G.
The Molien series of a finite group G < GL(n, C) can be written as
Î¦G (Î») =

det(A)
1 X
.
|G|
det(A âˆ’ Î»I)
AâˆˆG

Another important fact about the Molien series of a finite group G < GL(n, C) is that it can be written down
by inspection from the degrees of a good polynomial basis, that is, if B = {f1 , . . . , fl } is a good polynomial basis
of J (G) such that d1 = deg f1 , . . . , dl = deg fl then the Molien series of G can be written as
1
,
di
1 (1 âˆ’ Î» )

Î¦G (Î») = Qn

5

if

l = n,

(3.1)

or
1+
Î¦G (Î») = Qn

Pn

i=1

dj
j=l+1 Î»
(1 âˆ’ Î»di )

if

l > n.

(3.2)

On the other hand, the converse is not true. It is not always true when the Molien series has been put into the
forms (3.1) or (3.2) then a good polynomial basis for J (G) can be found with degrees matching the powers of Î»
in Î¦(Î»). This was shown by an example, due to Stanley [30, Ex 3.8].

4

Invariant Theory and the shape enumerator

In this section, we investigate the shape enumerator HC of binary self-dual NRT-code C âŠ† Mn,s (F2 ).

4.1

Invariant Ring for Self-dual NRT-Codes of Mn,2 (F2 )

We know from Theorem 5 that the shape enumerators of mutually dual linear codes C and C âŠ¥ âŠ† Mn,2 (Fq ) are
related by the equation
1
(4.1)
HC âŠ¥ (Z) = d HC (Î˜2 Z),
2
where
ï£®
ï£¹
1
1
2
Î˜2 = ï£° 1
1 âˆ’2 ï£» .
1 âˆ’1
0

If we assume that C is a linear self-dual NRT-code of dimension k, that is, C = C âŠ¥ and k = kâŠ¥ , then we
conclude that k = n, so Equation (4.1) can be rewritten as
HC (Z) =

1
HC (Î˜2 Z).
2n

Since by definition HC (Z) is a homogeneous polynomial of degree n, the last expression for HC (Z) may be
rewritten as


Î˜2
Z ,
HC (Z) = HC
2
2
which means that the polynomial HC is invariant by T = Î˜22 . Moreover, as T 2 = Î˜22
= I3 , the shape
enumerator HC is an element of J (G1 ) where G1 is the finite group of order 2 generated by T , G1 = hT i =
{I, T }. We will try construct a good polynomial basis for J (G1 ).
From Molienâ€™s Theorem the number of algebraically independent invariants of degree t over the group G1 is
equal to the coefficient of Î»t in
Î¦G1 (Î») =

det(A)
1 X
.
2
det(A âˆ’ Î»I3 )
AâˆˆG1

Letâ€™s calculate Î¦G1 (Î»). First note that
T :=
So the Molienâ€™s series of G1 is given by
Î¦G1 (Î») =

ï£®

Î˜2 ï£°
=
2

1
2
1
2
1
2

1
2
1
2
âˆ’ 21

ï£¹
1
âˆ’1 ï£» .
0

(4.2)

1 X
det(A)
1
=
.
2
2
det(A âˆ’ Î»I3 )
(1 âˆ’ Î») (1 âˆ’ Î»2 )
AâˆˆG1

It means that to find a good polynomial basis for G1 we should look for one invariant of degree two and two
invariants of degree one.
6

Since the shape enumerator of any NRT-code C âŠ† Mn,2 (F2 ) has degree n, we will start looking for shape
enumerators of self-dual NRT-codes in M1,2 (F2 ) = {(0, 0), (1, 0), (0, 1), (1, 1)}. In M1,2 (F2 ) there exist just five
linear codes, namely: The trivial codes C0 := {(0, 0)}, C4 := M1,2 (F2 ) and the non-trivial codes:
C1,1 := {(0, 0), (0, 1)};
C1,2 := {(0, 0), (1, 0)};
C1,3 := {(0, 0), (1, 1)};
It is clear that all except the trivial codes are self-dual codes, and their shape enumerators are
HC1,1 (z0 , z1 , z2 ) = z0 + z2 ;
HC1,2 (z0 , z1 , z2 ) = z0 + z1 ;
HC1,3 (z0 , z1 , z2 ) = z0 + z2 .
Note that HC1,2 (z0 , z1 , z2 ) = HC1,3 (z0 , z1 , z2 ) and this was already expected once that there exists a linear
isometry between C1,2 and C1,3 . We choose Ï†1 (z0 , z1 , z2 ) = z0 + z2 and Ï†2 (z0 , z1 , z2 ) = z0 + z1 ; it is obvious
that Ï†1 , Ï†2 are algebraically independent and invariant under G1 .
Now to find an invariant polynomial of degree two we will consider a self-dual NRT-code in M2,2 (F2 ) and
compute its shape enumerator. Let

 
 
 

0 0
1 0
0 1
1 1
C2,1 :=
,
,
,
.
0 0
1 0
0 1
1 1
C2,1 is a self-dual code and its shape enumerator is HC2,1 (z0 , z1 , z2 ) = z02 + z12 + 2z22 . Define Ï†3 (z0 , z1 , z3 ) =
z02 + z12 + 2z22 , so Ï†3 (z0 , z1 , z3 ) is invariant under G1 . Moreover, applying Theorem 9, we can check that the set
{Ï†1 , Ï†2 , Ï†3 } is algebraically independent. In short, we just proved the following theorem.
Theorem 12. Let C âŠ† Mn,2 (F2 ) be a self-dual NRT-code. Then, the shape enumerator of C is an invariant
polynomial under the action of G1 = hT i where T is the matrix given in (4.2). Moreover, the invariant ring of
the group G1 is C[Ï†1 , Ï†2 , Ï†3 ] where Ï†1 (z0 , z1 , z2 ) = z0 + z2 , Ï†2 (z0 , z1 , z2 ) = z0 + z1 , and Ï†3 (z0 , z1 , z2 ) =
z02 + z12 + 2z22 .
In words, Theorem 12 means that the shape enumerator of any linear self-dual NRT-code C âŠ† M atn,2 (F2 ) is a
polynomial in Ï†1 , Ï†2 and Ï†3 .

4.2

Invariant Ring for Doubly-Even Self-Dual NRT-Codes of Mn,2 (F2 )

Let now C âŠ† Mn,2 (F2 ) be a doubly-even self-dual NRT-code, i.e., a self-dual NRT-code C whose every codeword
has even weight. From the definition of shape enumerator of C it follows that HC (z0 , z1 , z2 ) âˆˆ C[z0 , z1 , z2 ] is
such that z1 has always even degree. So in this case
HC (z0 , z1 , z2 ) = HC (z0 , âˆ’z1 , z2 ).
Thats is, the polynomial HC is invariant by
ï£®

ï£¹
1
0 0
A := ï£° 0 âˆ’1 0 ï£» .
0
0 1

Since C is a self-dual NRT-code, we already know that HC is invariant by the matrix T given in (4.2). Finally,
the shape enumerator of C is invariant under the group G2 := hT, Ai. It is possible to check that
G2 = {I, A, T, AT, T A, T AT }
7

(4.3)

and the order of G2 is g = 6. The Molienâ€™s series of G2 is given by
Î¦(Î») =

det(A)
1
1 X
=
.
6
det(A âˆ’ Î»I3 )
(1 âˆ’ Î»)(1 âˆ’ Î»2 )(1 âˆ’ Î»3 )
AâˆˆG2

It suggests that we should search for one invariant of degree one, one invariant of degree two and one invariant
of degree three in order to determine a polynomial basis of invariants. The code C1,1 = {(0, 0), (0, 1)} is such that
C1,1 is a self-dual NRT-code and all its codewords has even weight. Moreover, HC1,1 (z0 , z1 , z2 ) = z0 + z2 is a
G2 -invariant. Now consider C2,2 âŠ† M2,2 (F2 ) given by

 
 
 

0 0
1 0
0 1
1 1
C2,2 =
,
,
,
.
0 0
1 0
0 1
1 1

C2,2 is a self-dual NRT-code and all its codewords have even weight. Furthermore, the shape enumerator of C2,2
is the polynomial HC2 (z0 , z1 , z2 ) = z02 + z12 + 2z22 which is, of course, an invariant polynomial of the group
G2 . Putting p1 and p2 as p1 (z0 , z1 , z2 ) = z0 + z2 and p2 (z0 , z1 , z2 ) = z02 + z12 + 2z22 we have an algebraically
independent set {p1 , p2 }. So, we just need do find another polynomial p3 (z0 , z1 , z2 ) such that p3 is algebraically
independent of p1 and p2 .
Define C3,3 âŠ† M3,2 (F2 ) by
ï£±ï£®
ï£¹ ï£®
ï£¹ ï£®
ï£¹ ï£®
ï£¹ ï£®
ï£¹ ï£®
ï£¹ ï£®
ï£¹ ï£®
ï£¹ï£¼
0 0
1 1
1 0
1 1
0 1
1 0
0 1 ï£½
ï£² 0 0
C3,3 := ï£° 0 0 ï£» , ï£° 1 0 ï£» , ï£° 1 1 ï£» , ï£° 0 0 ï£» , ï£° 0 1 ï£» , ï£° 1 1 ï£» , ï£° 1 0 ï£» , ï£° 0 1 ï£»
ï£³
ï£¾
0 0
1 0
0 1
1 0
1 1
1 1
0 0
0 1

C3,3 is a self-dual NRT-code and all its codewords has even weight. Moreover, the shape enumerator of C3,3
is the polynomial HC3,3 (z0 , z1 , z2 ) = z03 + 4z23 + 3z12 z0 that is invariant under G2 . Defining p3 (z0 , z1 , z2 ) =
HC3,3 (z0 , z1 , z2 ) the {p1 , p2 , p3 } is algebraically independent by Theorem 9.
Summing up, we have just proved the following.

Theorem 13. Let C âŠ† Mn,2 (F2 ) be a self-dual NRT-code such that all its codewords has even weight. Then, the
shape enumerator of C is an invariant polynomial for the group G2 given in (4.3). Moreover, the invariant ring
of G2 is C[p1 , p2 , p3 ] where the polynomials p1 , p2 and p3 are given by p1 (z0 , z1 , z2 ) = z0 + z2 , p2 (z0 , z1 , z2 ) =
z02 + z12 + 2z22 , and p3 (z0 , z1 , z2 ) = z03 + 4z23 + 3z12 z0 .
In other words, if C âŠ† Mn,2 (F2 ) is a self-dual NRT-code whose codewords has even weight then its shape
enumerator is a polynomial in p1 , p2 and p3 .

4.3

Invariant Ring for Doubly-Doubly-Even Self-Dual NRT-Codes of Mn,2 (F2 )

Let C âŠ† Mn,2 (F2 ) be a self-dual NRT-code whose every codeword has an even number of rows with weight one
and an even number of rows with weight two. In this case, by definition of shape enumerator, HC (z0 , z1 , z2 ) is
such that z1 and z2 are always of degree even, therefore, it is true that HC (z0 , z1 , z2 ) = HC (z0 , âˆ’z1 , âˆ’z2 ). This
implies that HC (z0 , z1 , z2 ) the shape enumerator of C is invariant under the action of the matrix
ï£®
ï£¹
1
0
0
B := ï£° 0 âˆ’1
0 ï£».
0
0 âˆ’1
Since C is a self-dual NRT-code it follows also that HC is invariant by the matrix T defined in (4.2), and therefore
the polynomial HC is invariant under the action of the group
G3 := hT, Bi.
We can check that G3 = {I, B, T, BT, T B, T BT, BT B, (BT )2 , (T B)2 , (T B)3 , B(T B)2 , (T B)2 T } and
1 X
trace(Ai ) = 0.
|G3 |
Ai âˆˆG3

8

(4.4)

Therefore, Theorem 10 assure us that there are no G3 -invariants of degree one. We can write the Molienâ€™s series
of G3 as


12 + 12Î»4
1
Î¦G3 (Î») =
12 (1 âˆ’ Î»2 )2 (1 âˆ’ Î»6 )
1
Î»4
=
+
,
(1 âˆ’ Î»2 )2 (1 âˆ’ Î»6 ) (1 âˆ’ Î»2 )2 (1 âˆ’ Î»6 )
which suggests that in order obtain a good polynomial basis for J (G3 ) we should search for three primary invariants Ï†1 , Ï†2 and Ï†3 of degree 2, 2, 6 respectively and one secondary invariant Ï†4 of degree 4.
Unfortunately, there exists only one linear code C âŠ† M2,2 (F2 ) such that the required properties are satisfied,
namely C2,2 of the previous section, so we can take Ï†1 as Ï†1 (z0 , z1 , z2 ) = z02 + z12 + 2z22 . By averaging z02 under
the group G3 , using the Theorem 6, we obtain the invariant Ï†2 (z0 , z1 , z2 ) = 5z02 âˆ’ 2z0 z1 + z12 + 8z22 + 8z2 z1 .
Now, we will work to find an invariant of degree six. Averaging z1 z2 over the group G3 , using Theorem 6,
we obtain an homogeneous invariant Ï†â‹†3 of degree two, namely Ï†â‹†3 (z0 , z1 , z2 ) = 2z02 âˆ’ 2z12 + 8z1 z2 . The set
{Ï†1 , Ï†2 , Ï†â‹†3 } is algebraically independent. Let Ï†3 âˆˆ C[z0 , z1 , z2 ] be the polynomial given by Ï†3 = (Ï†â‹†3 )3 , so
deg Ï†3 = 6 and {Ï†1 , Ï†2 , Ï†3 } is algebraically independent since {Ï†1 , Ï†2 , Ï†â‹†3 } is algebraically independent. We can
use Magma Computer Algebra program [31] to find the secondary invariant Ï†4 .
Theorem 14. Let C âŠ† Mn,2 (F2 ) be a self-dual NRT-code such that all its codewords has an even number of rows
with weight one, and an even number of rows with weight two. Then, the shape enumerator of C is an invariant
polynomial for the group G3 given in (4.4). Moreover, the invariant ring of G3 is C[Ï†1 , Ï†2 , Ï†3 ] âŠ• Ï†4 C[Ï†1 , Ï†2 , Ï†3 ]
where the polynomials Ï†1 , Ï†2 and Ï†3 are Ï†1 (z0 , z1 , z2 ) = z02 + z12 + 2z22 , Ï†2 (z0 , z1 , z2 ) = 5z02 âˆ’ 2z0 z1 + z12 +
2
8z22 + 8z2 z1 , Ï†3 (z0 , z1 , z2 ) = 2z02 âˆ’ 2z12 + 8z1 z2 .

5

The General case of Self-dual NRT-Codes of Mn,s (F2)

For the purpose of studying the shape enumerator of a self dual NRT-code C âŠ† Mn,s (F2 ) we will first look closely
at the matrix Î˜s given in Theorem 5.
Theorem 15. The matrix Î˜s given by Î˜s = (Î¸l,k )l,k=0,...,s
ï£±
1 if
ï£´
ï£´
ï£²
2kâˆ’1 if
Î¸l,k :=
âˆ’2kâˆ’1 if
ï£´
ï£´
ï£³
0 if

where
k = 0,
0 < k 6 s âˆ’ l,
l + k = s + 1,
l + k > s + 1,

satisfies the following properties:

a) Î˜2s = 2s Is+1 ;
 s
2 2 if s is even
b) trace(Î˜s ) =
;
0
if s is odd
(
s+1 s(s+1)
if s is
(âˆ’1) 2 2 2
c) det(Î˜s ) :=
s s(s+1)
(âˆ’1) 2 2 2
if s is

odd

;

even

Proof. Item a) is immediate and also is a fact already noticed in [9]. So we will prove items b) and c).
b) By the definition of Î˜ we have that trace(Î˜s ) =

s
X

Î¸ii where

i=0

ï£±
ï£´
ï£´
ï£²

1 if
if
Î¸ii :=
iâˆ’1 if
âˆ’2
ï£´
ï£´
ï£³
0 if
2iâˆ’1

9

i=0
0<i6sâˆ’i
.
2i = s + 1
2i > s + 1

So for an even s the trace of Î˜s becomes
s
X

trace(Î˜s ) =

s

Î¸ii = 1 +

2
X

2iâˆ’1 + 0

i=1

i=0
s
2

= 2 .

On the other hand, for a odd s the trace of Î˜s will be
trace(Î˜s ) =

s
X

sâˆ’1

Î¸ii = 1 +

i=0

= 1 + (2

2
X

Î¸ii + Î¸ s+1 , s+1 +
2

i=1

sâˆ’1
2

âˆ’ 1) âˆ’ 2

sâˆ’1
2

2

s
X

Î¸ii

i= s+1
+1
2

+0

= 0,
and we have just proved that
trace(Î˜s ) =



s

if s
if s

22
0

is even,
is odd.

c) Setting Î˜0 = 1 and applying Laplace expansion along the last column of Î˜s we find that
det(Î˜s ) = 2sâˆ’1 (âˆ’1)s det(Î˜sâˆ’1 ) âˆ’ 2sâˆ’1 (âˆ’1)s+1 det(Î˜sâˆ’1 ) = 2s (âˆ’1)s det(Î˜sâˆ’1 ).

(5.1)

for every s â‰¥ 1.
This equation yields the two equalities below:
det(Î˜2t+2 ) = 22t+2 det(Î˜2t+1 ),
2t+1

det(Î˜2t+1 ) = âˆ’2

det(Î˜2t )

(5.2)
(5.3)

for every t â‰¥ 0. Using (5.2) and (5.3), and taking s = 2t we obtain, by induction on t, that the equality
s

det(Î˜s ) = (âˆ’1) 2 2

s(s+1)
2

(5.4)

holds for any even number s. Now it follows from the previous equation and from (5.3) that
det(Î˜s ) = (âˆ’1)

s+1
2

2

s(s+1)
2

(5.5)

for any odd number s, concluding the proof of c).

Theorem 16. Let mÎ˜s and and PÎ˜s be the minimal and characteristic polynomials respectively of the matrix Î˜s
s
s
given in Theorem 15. Then mÎ˜s and PÎ˜s are given by mÎ˜s (Î») = (Î» âˆ’ 2 2 )(Î» + 2 2 ) and
(
s s+2
s s
(Î» âˆ’ 2 2 ) 2 (Î» + 2 2 ) 2
if s is even
pÎ˜s (Î») =
s s+1
s s+1
2
2
2
2
(Î» âˆ’ 2 ) (Î» + 2 )
if s is odd
Proof. Item a) of Theorem 15 says that
s

s

0 = Î˜2s âˆ’ 2s Is+1 = (Î˜s âˆ’ 2 2 Is+1 )(Î˜s + 2 2 Is+1 )
s

s

and it follows that mÎ˜s (Î») = (Î»âˆ’2 2 )(Î»+2 2 ) is the minimal polynomial of Î˜s , since mÎ˜s is a monic polynomial
of degree two such that mÎ˜s (Î˜s ) = 0 and obviously no polynomial of degree one vanishes on Î˜s . Therefore the
characteristic polynomial of Î˜s decomposes as a product
s

s

pÎ˜s (Î») = (Î» âˆ’ 2 2 )r1 (Î» + 2 2 )r2 ,
10

(5.6)

s

s

where r1 and r2 are the multiplicities of the eigenvalues Î²1 = 2 2 and Î²2 = âˆ’2 2 and, in particular, r1 + r2 = s + 1.
From (5.6) it follows that
s
s
(5.7)
trace(Î˜s ) = r1 (2 2 ) + r2 (âˆ’2 2 ),
and therefore for every s â‰¥ 1 we have the system of equations
ï£±
ï£² r1 + r2 =
s+1
trace(Î˜s )
ï£³ r1 âˆ’ r2 =
s
22
If s is an odd number then trace(Î˜s ) = 0 by item b) of Theorem 15 and, in this case, the above system has
r1 = r2 = s+1
2 as unique solution. Therefore in the case of an odd s the characteristic polynomial of Î˜s is
s

pÎ˜s (Î») = (Î» âˆ’ 2 2 )

s+1
2

s

(Î» + 2 2 )

s+1
2

.

s
2

If s is even then trace(Î˜s ) = 2 and the corresponding system has solution r1 =
the characteristic polynomial of Î˜s is
s

We have just proved that pÎ˜s (Î») =

5.1

(

pÎ˜s (Î») = (Î» âˆ’ 2 2 )
s

s+2

s+2
2

s

s

s+2
2 , r2

= 2s . In this case

s

(Î» + 2 2 ) 2 .

s

(Î» âˆ’ 2 2 ) 2 (Î» + 2 2 ) 2
s s+1
s s+1
(Î» âˆ’ 2 2 ) 2 (Î» + 2 2 ) 2

if s
if s

is even
is odd

Self-dual NRT-Codes in Mn,s (F2 ) with odd s

The main purpose of this subsection is to use the properties of the shape enumerator of a self-dual NRT-code
C âŠ† Mn,s (F2 ) and the properties of the matrix Î˜s to understand how the shape enumerator behaves.
We recall that Theorem 5 says that for a self-dual NRT-code C âŠ† Mn,s (F2 ) its H-enumerator HC satisfies the
equation


Î˜s
HC (z0 , . . . , zs ) = HC
.
s (z0 , . . . , zs )
22
In polynomial invariant theory language, this is equivalent to saying that HC is invariant by
Î˜s
s .
22
So HC will be invariant under the group G = hT i. Note also that by item a) of Theorem 15
 2
Î˜s
Î˜2
2
T =
= ss = Is+1 ,
s
2
22
T =

(5.8)

and the group G is given by G = hT i = {Is+1 , T }.
Let us calculate the Molienâ€™s series of G which tells us what kind of invariants we should look for. We can use
the properties c) of Theorem 15 and Theorem 16, since s is odd the Molienâ€™s series of G can be written as
Î¦G (Î») =
=
=

=

det(A)
1 X
2
det(A âˆ’ Î»Is+1 )
AâˆˆG
"
#
s+1
1
1
(âˆ’1) 2
s+1
s+1 +
2 (âˆ’1) s+1
(1 âˆ’ Î»)s+1
2 (1 âˆ’ Î») 2 (1 + Î») 2
(1 âˆ’ Î»)

s+1
2

+ (1 + Î»)

s+1
2

s+1

2(1 + Î») 2 (1 âˆ’ Î»)s+1
s+1
s+1
2  s+1 
2  s+1 
X
X
k
2
2
Î» +
(âˆ’Î»)k
k
k
k=0

k=0

2(1 âˆ’ Î»)

s+1
2

(1 âˆ’ Î»2 )
11

s+1
2

.

Consider the subcase of

s+1
2

even, that is,

s+1
2

= 2t for some t â‰¥ 0. The Molienâ€™s series of G can be rewritten as
2t  
X
2t

2t  
X
2t
Î» +
(âˆ’Î»)k
k
k

k=0

Î¦G (Î») =

k

k=0

2(1 âˆ’ Î»)2t (1 âˆ’ Î»2 )2t
t  
X
2t 2l
2
Î»
2l
l=0
.
2(1 âˆ’ Î»)2t (1 âˆ’ Î»2 )2t

=
hence in this case

Î¦G (Î») =

t  
X
2t
l=0

2l

Î»2l

(1 âˆ’ Î»)2t (1 âˆ’ Î»2 )2t

.

(5.9)

Note that the term (1âˆ’Î»)2t in the denominator indicates that to form a good basis we should look for s+1
2 invariants
of degree one, but by Theorem 10 and item b) of Theorem 15 there are no invariant polynomial under G of degree
one. So we are not using all the information about the shape enumerator of C.
Since the dimension of C is k = ns
2 and s is an odd number we must have n even, which implies that HC will
be invariant by âˆ’I, so HC is invariant under the action of the group
G1 := {âˆ’I, I, âˆ’T, T }.
It is easy to see that the Molien series of G1 can be written as
Î¦G1 (Î») =

1
(Î¦G (Î») + Î¦G (âˆ’Î»))
2

and, so

Î¦G1 (Î») =

=

=

ï£®

t  
X
2t

t  
X
2t

ï£¹

ï£º
ï£¯
Î»2l
Î»2l
ï£º
ï£¯
2l
2l
1ï£¯
ï£º
l=0
l=0
+
ï£º
ï£¯
2 ï£¯ (1 âˆ’ Î»)2t (1 âˆ’ Î»2 )2t
(1 + Î»)2t (1 âˆ’ Î»2 )2t ï£º
ï£»
ï£°

" t   #
t  
X
2t 2l X 2t 2l
Î» 2
Î»
2l
2l
1
l=0

2
"

l=0

(1 âˆ’ Î»2 )4t
#2
t  
X
2t 2l
Î»
2l
l=0
.
(1 âˆ’ Î»2 )4t

s+1
Now, if we consider the subcase where s+1
2 is odd, 2 = 2t + 1, for some t â‰¥ 0, then proceeding in the same
way as in the even case one obtains the following expression for the Molienâ€™s series:

Î¦G1 (Î») =

"


t 
X
2t + 1
l=0

2l

Î»

(1 âˆ’ Î»2 )4t+2

In short, we have proved the following result:

12

2l

#2

.

Theorem 17. Let C âŠ† Mn,s (F2 ) be a self-dual NRT-code and suppose that s is an odd number. The shape
enumerator of C will be an invariant polynomial under the group G1 := {I, âˆ’I, T, âˆ’T } where T is given by (5.8)
and the Molienâ€™s series of G1 is
ï£± ï£®
ï£¹2
t  
ï£´
X
ï£´
2t
ï£´
2l
ï£¯
ï£´ ï£°
Î» ï£º
ï£»
ï£´
ï£´
2l
ï£´
ï£´
l=0
ï£²
if s+1
2 = 2t, t = 0, 1, . . .
(1âˆ’Î»2 )4t
ï£®
.
ï£¹
Î¦G1 (Î») =
2


t
ï£´
X 2t + 1
ï£´
ï£´
2l
ï£¯
ï£º
ï£´
Î» ï£»
ï£°
ï£´
ï£´
2l
ï£´ l=0
ï£´
ï£³
if s+1
2 = 2t + 1, t = 0, 1, . . .
(1âˆ’Î»2 )4t+2
Thus, Theorem 17 gives us an expectation of how many algebraically independent invariants we must find to form
a base of invariants for J (G1 ).
Note that in the case s = 1 we have s+1
2 = 1 = 2(0) + 1 and so the Molienâ€™s series of G1 is given by
" 0   #
X 1
Î»2l
2l
1
=
,
Î¦G1 (Î») = l=0
2
2
(1 âˆ’ Î» )
(1 âˆ’ Î»2 )2

which agrees with [18], where it was shown by MacWilliams et al. that the Hamming weight enumerator of a
binary self-dual code is a polynomial in two polynomials p1 (x, y) and p2 (x, y) where deg p1 = deg p2 = 2. This
fact was expected since the Hamming metric coincides with the NRT-metric in the case where s = 1 and the shape
enumerator is the Hamming weight enumerator.

5.2

Self-dual NRT-Codes in Mn,s (F2 ) with even s

Following the same steps as in the previous subsection we can prove an analogous result for the case of an s even.
Theorem 18. Let C âŠ† Mn,s (F2 ) be a self-dual NRT-code, such that s is an even number. The shape enumerator
of C will be an invariant polynomial under the group G := {I, T } where T is given by (5.8) and the Molienâ€™s
series of G1 is
ï£±
t  
X
ï£´
2t 2l
ï£´
ï£´
Î»
ï£´
ï£´
ï£´
2l
ï£´
ï£² l=0
if 2s = 2t, t = 1, . . .
(1âˆ’Î»2 )2t (1âˆ’Î»)2t+1
Î¦G (Î») =
.

t 
X
ï£´
2t
+
1
ï£´
2l
ï£´
Î»
ï£´
ï£´
ï£´
2l
ï£´
ï£³ l=0
if s = 2t + 1, t = 0, 1, . . .
(1âˆ’Î»2 )2t+1 (1âˆ’Î»)2t+2

2

Theorem 18 gives us an expectation of how many algebraically independent invariants we must find to form a base
of invariants for J (G).
Note that for s = 2 we have 2s = 1 = 2(0) + 1 and, so the Molienâ€™s series of G is given by

Î¦G (Î») =

0  
X
1 2l
Î»
2l
l=0

(1

âˆ’ Î»2 )(1

âˆ’

Î»)2

=

1
(1 âˆ’

Î»2 )(1

âˆ’ Î»)2

,

which matches the result that we found in Section 3.1.

6

Construction of Self-Dual Codes in the NRT-Metric

In this last section we present some constructions of self-dual codes in NRT spaces. The first one utilizes a self-dual
code in Hamming space as its starting point.
13

6.1

Self-Dual Codes in NRT Spaces from Self-Dual codes in Hamming Spaces

Definition 19. Given a vector v = (v1 , . . . , vsâˆ’1 , vs ) âˆˆ Fsq the flip of v, denoted by flip(v), is the vector flip(v) =
(vs , vsâˆ’1 , . . . , v1 ) âˆˆ Fsq .
Remark 20. Let flip : Fsq âˆ’â†’ Fsq be the function taking v âˆˆ Fsq to its flip. Then
a) For any s âˆˆ N, flip : Fsq âˆ’â†’ Fsq is a linear operator.
b) If s = 1 then flip â‰¡ I where I denotes the identity operator.
c) If h, iH is the standard inner product on Fsq and v, u âˆˆ Fsq , then hflip(v), flip(u)iH = hv, uiH .
In the next theorem we present a construction of a self-orthogonal NRT-code that is derived from a code
C âŠ† Fsq over the Hamming space with the standard inner product h, iH .
Theorem 21. Let C âŠ† Fsq be an [s, k]-linear code over the Hamming space and let C âŠ¥ its dual code with respect
to the standard inner product. Then, the code Co âŠ† M1,2s (Fq ) given by
Co := {(v, flip(u)) such that v âˆˆ C and u âˆˆ C âŠ¥ }
is a [2s, k + kâŠ¥ ]-self orthogonal code with respect to the NRT-metric where kâŠ¥ = dim(C âŠ¥ ).
Proof. Indeed, let (v1 , flip(u1 )) , (v2 , flip(u2 )) âˆˆ Co where v1 , v2 âˆˆ C and u1 , u2 âˆˆ C âŠ¥ . Then
h(v1 , flip(u1 )) , (v2 , flip(u2 ))iN

= hv1 , u2 iH + hflip(u1 ), flip(v2 )iH
= hv1 , u2 iH + hu1 , v2 iH
= 0,

which means that Co âŠ† (Co )âŠ¥ . Itâ€™s easy to check that dim Co = k + kâŠ¥ .
Example 22. Let C âŠ† F22 be the [2, 1]-linear code given by C := {(0, 0), (1, 0)} than its dual code C âŠ¥ is given
by C âŠ¥ = {(0, 0), (0, 1)} and, the code Co âŠ† M1,4 (F2 ) of Theorem 21 is the following [4, 2]-self orthogonal
NRT-code
Co := {(0, 0, 0, 0), (0, 0, 1, 0), (1, 0, 0, 0), (1, 0, 1, 0)}.
Note that if we consider Co as an [4, 2]-code over the Hamming space F42 , Co is not a self-orthogonal code since
(1, 0, 0, 0) âˆˆ Co but (1, 0, 0, 0) âˆˆ
/ Co . Note also that Co is not a self-dual NRT-code since (0, 1, 0, 1) âˆˆ
/ Co but
(0, 1, 0, 1) âˆˆ CoâŠ¥ .
Theorem 23. Let C âŠ† Fsq be an [s, k]-self orthogonal code over the Hamming space. Then, the code
Cort := {(v, flip(v)) âˆˆ M1,2s (Fq ) such that v âˆˆ C}
is an [2s, k]-self orthogonal code with respect to the NRT-metric.
Proof. Let v = (v, flip(v)), u = (u, flip(u)) âˆˆ Cort with v, u âˆˆ C. Then
hv, uiN = h(v, flip(v)), (u, flip(u))iN = 2hv, uiH = 0
since v, u âˆˆ C and C is a self-orthogonal code over the Hamming space. Clearly, dim Cort = k, so Cort is an
[2s, k]-self orthogonal NRT-code.
Example 24. Let C be the [3, 1]-self orthogonal code given by C = {(0, 0, 0), (1, 1, 0)} over the Hamming space
F32 and, so the code Cort âŠ† M1,6 (F2 ) of Theorem 23 is the following [6, 1]-self orthogonal NRT-code
Cort = {(0, 0, 0, 0, 0, 0), (1, 1, 0, 0, 1, 1)}.

14

Theorem 25. Let C âŠ† Fsq be an [s, k]-self dual code over the Hamming space. Then, the code CN âŠ† M1,2s (Fq )
given by
CN := {(v, flip(v â€² )) such that v, v â€² âˆˆ C}
is an [2s, 2k]-self dual with respect to the NRT-metric.
Proof. Let v = (v1 , flip(v1â€² )), u = (u1 , flip(uâ€²1 )) âˆˆ CN with v1 , v1â€² , u1 , uâ€²1 âˆˆ C. Then,
hv, uiN = h(v1 , flip(v1â€² )), (u1 , flip(uâ€²1 ))iN = hv1 , u1 iH + hv1â€² , uâ€²1 iH = 0
since v1 , v1â€² , u1 , uâ€²1 âˆˆ C and C is a self-dual code over the Hamming space. So CN is a self orthogonal NRT-code.
CN will be a self-dual NRT-code if dim(CN ) = 2k. Let Î² := {v1 , . . . vk } be a basis of C. Since flip : Fsq âˆ’â†’ Fsq
is a linear isomorphism the set f lip(Î²) := {flip(v1 ), . . . , flip(vk )} is a basis of f lip(C). Define
Î²N := {(v1 , 0), . . . , (vk , 0), (0, flip(v1 )), . . . , (0, flip(vk ))}
where 0 denotes the vector (0, . . . , 0) âˆˆ Fsq . This is a basis for CN which has 2k elements, and it follows that CN
is a [2s, 2k]-NRT self dual code.
Example 26. Let C be the [2, 1]-self dual code given by C := {(0, 0), (1, 1)} over the Hamming space F22 the
code CN âŠ† M1,4 (F2 ) of Theorem 25 will be the following [4, 2]-self dual NRT code
CN = {(0, 0, 0, 0), (0, 0, 1, 1), (1, 1, 0, 0), (1, 1, 1, 1)}.
Example 27. Consider the [8, 4]-Extended Hamming code HÌ‚3 . It is well knowm that HÌ‚3 is a self-dual code over the
Hamming space F82 and thus the construction of Theorem 25 applied to HÌ‚3 will give us an code CN âŠ† M1,16 (F2 ),
which is an [16, 8]- self dual NRT code.

6.2

Constructions of NRT self-dual codes via generator matrices

In this subsection we will present some constructions of self-dual NRT-codes starting from other self-dual NRTcodes. These constructions are inspired by the those introduced by Marka et al. in [22], where some constructions
of self-dual NRT-codes for n = 1 are given. In order to describe NRT codes by generator matrices we will order
lexicographically the entries of an element v âˆˆ Mn,s (Fq ), identifying the matrix v = [v1 ; v2 ; Â· Â· Â· ; vn ] âˆˆ Mn,s (Fq )
with a row vector (v1 | v2 | . . . | vn ) âˆˆ M1,ns (Fq ).
Definition 28. A generator matrix for an [ns, k]-linear code C âŠ† Mn,s (Fq ) in the N RT -space is a matrix
G âˆˆ Mk,ns (Fq ) whose rows form a basis of C. A generator matrix G âˆˆ Mk,ns (Fq ) of an [ns, k]- linear NRT-code
C âŠ† Mn,s (Fq ) can be written as


G = G1 G2 Â· Â· Â· Gnâˆ’1 Gn

where each Gi is an k Ã— s matrix for i = 1, . . . , n.

The main point in the constructions given in [22] is the definition of a flip of a matrix A âˆˆ Mn,s (Fq ), which is
given by
Definition 29. Let A = (ai,j ) âˆˆ Mn,s (Fq ). Then, the flip of A denoted by Flip(A) is defined by
Flip(A) = (aik ),
where k = s âˆ’ j + 1 for 1 6 i 6 n and 1 6 j 6 s. We denote the transpose of Flip(A) as Ao .
Example 30. Let A âˆˆ Mn,s (Fq ) given by
ï£®
a1,1
a1,2
ï£¯ a2,1
a2,2
ï£¯
ï£¯
..
.
..
A=ï£¯
.
ï£¯
ï£° anâˆ’1,1 anâˆ’1,2
an,1
an,2

Â·Â·Â·
Â·Â·Â·
..
.
Â·Â·Â·
Â·Â·Â·
15

a1,sâˆ’1
a2,sâˆ’1
..
.

a1,s
a2,s
..
.

anâˆ’1,sâˆ’1 anâˆ’1,s
an,sâˆ’1
an,s

ï£¹

ï£º
ï£º
ï£º
ï£º.
ï£º
ï£»

Then, Flip(A) and Ao are given respectively by
ï£®
a1,s
a1,sâˆ’1 Â· Â· Â·
a1,2
a1,1
ï£¯ a2,s
a
Â·
Â·
Â·
a
a
2,sâˆ’1
2,2
2,1
ï£¯
ï£¯
..
..
..
..
..
F lip(A) = ï£¯
.
.
.
.
.
ï£¯
ï£° anâˆ’1,s anâˆ’1,sâˆ’1 Â· Â· Â· anâˆ’1,2 anâˆ’1,1
an,s
an,sâˆ’1 Â· Â· Â·
an,2
an,1

ï£®

ï£¹

ï£¯
ï£º
ï£¯
ï£º
ï£¯
ï£º
o
,
A
=
ï£¯
ï£º
ï£¯
ï£º
ï£°
ï£»

a1,s
a2,s
a1,sâˆ’1 a2,sâˆ’1
..
..
.
.
a1,2
a2,2
a1,1
a2,1

Â·Â·Â·
Â·Â·Â·
..
.
Â·Â·Â·
Â·Â·Â·

anâˆ’1,s
an,s
anâˆ’1,sâˆ’1 an,sâˆ’1
..
..
.
.
anâˆ’1,2
an,2
anâˆ’1,1
an,1

ï£¹

ï£º
ï£º
ï£º
ï£º.
ï£º
ï£»

Note that by the definition of the NRT-metric, in the case n = 1, a code C âŠ† M1,s (Fq ) is an [ns, k]-self
orthogonal NRT-code if and only if GGo = 0 where G is any generator matrix of the code C.
In order to define self-dual NRT-codes by generator matrices, we introduce the ordered flip of a matrix A âˆˆ
Mk,ns (Fq ).


Definition 31. Let A = A1 A2 Â· Â· Â· Anâˆ’1 An be an k Ã— nsmatrix. The ordered flip of A is the matrix
OFlip(A) := Flip(A1 ) Flip(A2 ) Â· Â· Â· Flip(Anâˆ’1 ) Flip(An ) . We denote the transpose of OFlip(A) by
Aod . Note that
ï£®
ï£¹
Ao1
ï£¯ Ao ï£º
2 ï£º
ï£¯
ï£¯ .. ï£º
od
T
A = [OFlip(A)] = ï£¯ . ï£º .
ï£¯ o
ï£º
ï£° Anâˆ’1 ï£»
Aon
The definition of ordered flip and NRT-metric implies the following remark.

Remark 32. Let C âŠ† Mn,s (Fq ) be an [ns, k]-linear NRT-code. Then, C is a self orthogonal NRT-code if and only
if GGod = 0 where G is a generator matrix of C.
(i)

(i)

Theorem 33. Let Ci be an [ns, ki ]-self orthogonal NRT-code for i = 1, 2 and G(i) = [G1 | . . . |Gn ] be a
generator matrix of Ci . Then, the matrix G âˆˆ Mk1 +k2 ,2ns (Fq ) defined by
#
"
(1)
(1)
0
Â· Â· Â· Gn
0
G1
G=
(2)
(2)
0
G1
Â·Â·Â·
0
Gn
is a generator matrix of an [2ns, k1 + k2 ]-self orthogonal NRT-code C N .
Proof. We will prove that GGod = 0. Indeed, by definition of ordered flip we have

OF lip(G) =

"

(1)

F lip(G1 )
0
Â·Â·Â·
(2)
F lip(G1 ) Â· Â· Â·
0

(1)

F lip(Gn )
0
(2)
0
F lip(Gn )

and therefore
(1)

(1)

(2)

#

ï£®

, God

ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
=ï£¯
ï£¯
ï£¯
ï£¯
ï£°

(1)

(G1 )o
0
(2) o
0
(G1 )
(1) o
(G2 )
0
..
..
.
.
(1) o
(Gn )
0
(2) o
0
(Gn )

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

(2)

(1) o
o
(2)
(2) o
GGod = G1 (G1 )o + . . . + G(1)
n (Gn ) + [G1 (G1 ) + . . . + Gn (Gn ) ]
od
= G1 God
1 + G2 G2 = 0,

given that C1 and C2 are self-dual NRT-codes. Now it follows from Remark 32 that C N is a self orthogonal
NRT-code. It is easy to see that the rows of G form a basis of C N , so dim C N = k1 + k2 and hence C N is an
[2ns, k1 + k2 ]-self orthogonal NRT-code.

16



(i) = [G(i) | . . . |G(i) ] be a generator
Corollary 34. Let Ci be an ns, ns
n
1
2 -self dual NRT-code for i = 1, 2 and G
matrix of Ci . Then, the matrix G âˆˆ Mns,2ns (Fq ) defined by
#
"
(1)
(1)
0
Â· Â· Â· Gn
0
G1
G=
(2)
(2)
0
G1
Â·Â·Â·
0
Gn
is a generator matrix of an [2ns, ns]-self dual NRT-code C N .
Example 35. In Example 26, given the Hamming self-dual code C = {(0, 0), (1, 1)}, we obtain the self-dual
NRT-code CN âŠ† M1,4 (F2 ) which a generator matrix given by


1 1 0 0
(1)
G =
.
0 0 1 1
Applying the construction of Theorem 33 we obtain the [8, 4]-self-dual
generator matrix
ï£®
1 1 0 0 0 0 0
ï£¯ 0 0 1 1 0 0 0
G := ï£¯
ï£° 0 0 0 0 1 1 0
0 0 0 0 0 0 1

NRT-code C N1 âŠ† M2,4 (F2 ) defined by the
ï£¹
0
0 ï£º
ï£º.
0 ï£»
1

Example 36. Applying again the construction to the linear self dual NRT-code C N1 âŠ† M2,4 (F2 ) of Example 35
we obtain the [16, 8]-self dual NRT-code C N2 given by the generator matrix
ï£¹
ï£®
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ï£¯ 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 ï£º
ï£º
ï£¯
ï£¯ 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 ï£º
ï£º
ï£¯
ï£¯ 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 ï£º
ï£º
G := ï£¯
ï£¯ 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 ï£º.
ï£º
ï£¯
ï£¯ 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 ï£º
ï£º
ï£¯
ï£° 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 ï£»
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1

Theorem 37. Let Ci âˆˆ Mni si (Fq ) be an [ni si , ki ]-self orthogonal NRT-code for 1 6 i 6 t such that k =
(i)
(i)
k1 + . . . + kt 6 nÌ„sÌ„, where nÌ„ := max{ni } and sÌ„ := max{si }. Let also G(i) = [G1 | . . . |Gni ] be a generator
matrix of Ci . Then the matrix G âˆˆ Mk,sÌ„(n1 +...+nt ) (Fq ) defined by
ï£¹
ï£® (1)
e(1) . . . G
e(1)
e
G
0
0
.
.
.
0
.
.
.
0
0
.
.
.
0
G
n
1
2
ï£º
ï£¯ 1
e(2) G
e(2) . . . G
e(2)
ï£¯ 0
G
0
...
0
...
0
0
...
0 ï£º
n2
1
2
G=ï£¯
..
..
..
..
..
..
..
..
..
..
..
.. ï£º
ï£º
ï£¯ ..
.
.
.
.
.
.
.
.
.
.
.
. ï£»
ï£° .
0

0

...

0

0

0

...

0

e(t) G
e(t) . . . G
e(t)
... G
nt
1
2

e(i) âˆˆ Mk sÌ„ (Fq ),
is a generator matrix of an [sÌ„(n1 +. . .+nt), k]-self orthogonal NRT-code Câ‹† , where the matrices G
i
ji
(i)
(i)
(i)
(i)
e
e
1 6 i 6 t and 1 6 ji 6 ni are given by Gji = [Gji ] if si = sÌ„ or Gji = [Gji | 0] if si < sÌ„, where
0 âˆˆ Mki sÌ„âˆ’si (Fq ) is the null matrix.

Corollary 38. Let Ci be an [ns, ki ]-self orthogonal NRT-code for 1 6 i 6 t such that k = k1 + . . . + kt 6 ns
(i)
(i)
and G(i) = [G1 | . . . |Gn ] be a generator matrix of Ci . Then the matrix G âˆˆ Mk,tns (Fq ) defined by
ï£¹
ï£® (1)
(1)
(1)
G2
. . . Gn
0
0
...
0
...
0
0
...
0
G1
ï£º
ï£¯
(2)
(2)
(2)
ï£¯ 0
0
...
0
G1
G2
. . . Gn . . .
0
0
...
0 ï£º
G=ï£¯
..
..
..
..
..
..
..
..
..
..
..
.. ï£º
ï£º
ï£¯ ..
.
.
.
.
.
.
.
.
.
.
.
. ï£»
ï£° .
0

0

...

0

0

0

...

is a generator matrix of a [tns, k]-self orthogonal NRT-code Câ‹† .
17

0

(t)

. . . G1

(t)

G2

(t)

. . . Gn

In particular, we can apply the preceding Corollary to construct a self-dual NRT-code Câ‹† equivalent to the code
C N obtined by the constructions in Theorem 33 is the folowing


(1) = [G(1) | . . . |G(1) ] be a generator
Corollary 39. Let C1 , C2 be two ns, ns
n
1
2 -self dual NRT-codes and let G
(2)

(2)

matrix of C1 , and G(2) = [G1 | . . . |Gn ] be a generator matrix of C2 . Then, the matrix G âˆˆ Mns,2ns (Fq ) defined
by
#
"
(1)
(1)
. . . Gn
0
...
0
G1
G=
(2)
(2)
0
...
0
G1
. . . Gn

is a generator matrix for an [2ns, ns]-self dual NRT-code Câ‹† .
Example 40. Let C N1 be the [8, 4]-Self dual NRT-code of Example 35. Then, by the construction of Theorem 39
the following matrix
ï£¹
ï£®
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ï£¯ 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 ï£º
ï£º
ï£¯
ï£¯ 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 ï£º
ï£º
ï£¯
ï£¯ 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 ï£º
ï£º
ï£¯
G := ï£¯
ï£º
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
ï£º
ï£¯
ï£¯ 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 ï£º
ï£º
ï£¯
ï£° 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 ï£»
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
is a generator matrix for a [16, 8]-self dual NRT-code Câ‹† that is equivalent to the code C N2 of Example 36.

6.3

An application of the ordered flip concept

In [1], Alves gave an analogue for NRT-codes of the well-known standard form of generator matrices for codes in
spaces with the Hamming space. In particular, for bidimensional codes it was shown the following result.
Theorem 41. Let C âŠ† Mn,s (Fq ) be an [ns, 2]-linear NRT-code. Then, C has a generator matrix of the form
G = [G1 |G2 | . . . |Gn ]
where each Gi is an 2 Ã— s matrix of one of the following types: Null matrix,
where ei âˆˆ Fsq denotes the i-th canonical vector, 1 6 i 6 j and Î» 6= 0.



ei
0

 
 

 
ei
ei + Î»ej
0
,
,
,
ei
ej
ej

The definition of ordered flip and Theorem 41 can be used to find all possible generator matrices of a bidimensional self-dual NRT-code. In fact, if C âŠ† Mn,s (Fq ) is an [ns, k]-self dual bidimensional NRT-code then
2 = dim(C) = ns
2 and so ns = 4, which implies that one of the following cases holds.
i) n = 1, s = 4 and an [4, 2]-Self dual NRT-code C âŠ† M1,4 (Fq ) has as a generator matrix one of the matrices

 
 
 

1 0 0 0
1 0 0 0
0 1 0 0
0 0 1 0
,
,
,
,
0 1 0 0
0 0 1 0
0 0 0 1
0 0 0 1

 
 
 

1 0 Î» 0
1 Î» 0 0
0 1 0 Î»
0 0 1 Î»
,
,
,
.
0 0 1 0
0 1 0 0
0 0 0 1
0 0 0 1
ii) n = 2, s = 2 and an [4, 2]-Self dual NRT-code C âŠ† M2,2 (Fq ) has as a generator matrix one of the matrices
 
1
,
0

 
0
0 1 1 0
,
0 0 1 0
0
 

0 1
0 1 1+Î» 0
,
1
0
0 0
0 0


1 0 0 0
0 0 1 0

 
0
,
0
 
0 1
1
,
0
0 1
 
1
1+Î»
,
1
0

 
0 1
,
0 0
 
1 0
1 0
,
0 0
1 0
 
1
1+Î» 0
,
1
0
0

0 0 0
0 0 1

1 0 0
0 1 0

0 0
0 1

1
0

0
0

0 1
0 1

0
0

18

0
0




,
,

0 0 1+Î»
1
0 0



.

iii) n = 4, s = 1 and in this case the NRT-metric and the Hamming metric are equivalent. The classification of
self-dual codes in this case is given by Pless in [25].

References
A standard form for generator matrices with respect to the
[1] M. M. S. Alves,
Niederreiter-Rosenbloom-Tsfasman metric, IEEE Information Theory Workshop, Vol.1, pp. 486-489,
2011.
[2] A. Barg, P. Purkayastha, Bounds on ordered codes and orthogonal arrays, Moscow Mathematical Journal,
vol. 9, pp. 211-243, 2009.
[3] K. Lee, The automorphism group of a linear space with the Rosenbloom-Tsfasman metric, European Journa
of Combinatories, vol. 24, pp. 607-6017, 2003.
[4] W. Park, A. Barg, Linear ordered codes, shape enumarators and parallel channels, Forty-Eighth Annual
Allerton Conference, pp. 361-368, 2010.
[5] M. Beecken, J. Mittmann, and N. Saxena, Algebraic independence and blackbox identity testing, Information
and Computation, vol. 222, pp. 137-148, 2011.
[6] R. A. Brualdi, J. S. Graves and K. M. Lawrence, Codes with a poset metric, Discrete Mathematics, vol. 147,
pp. 57-72, 1995.
[7] T. Molien, Ueber die invarianten der linear substitutions gruppe, Sitzungaber KÃ¯Â¿ 12 ning, Akad. Wiss, pp.
1152-1156, 1857.
[8] E. M. Rains, N. J. A. Slone, Self-dual codes, In: Handbook of coding theory, North Holland, 1995.
[9] S. T. Dougherty, M. M. Skriganov, MacWilliams duality and the Rosenbloom-Tsfasman metric, Moscow
Mathematical Journal, vol. 2, pp. 81-97, 2002.
[10] H. Niederreiter, A combinatorial problem for vectors spaces over finite fields, Discrete Math, vol. 96, pp.
221-228, 1991.
[11] S. Dougherty and K. Shiromoto, Maximum distance codes in M atN,S (Z(K)) with a Non-Hamming metric
and uniform distributions, Designs Codes Cryptography, vol. 33, pp. 45-61, 2004.
[12] A. Barg, M. Firer, Translation association schemes, poset metric, and the shape enumerator of codes, IEEE
International Symposium on Information Theory Proceedings, pp. 101-105, 2012.
[13] A. Barg, W. Park, On linear ordered codes, Moscow Mathematical Journal, vol. 15, pp. 679-702, 2015.
[14] S. Lefschetz, Algebraic Geometry, Princeton University Press, Princeton, N. J., 1953, 2nd edn., 1964.
[15] R. Ehrenborg, G. C. Rota, Apolarity and canonical forms for homogeneous polynomials, European Journal
of Combinatorics, vol.12, pp. 157-181, 1993.
[16] H. K. Kim and D. Y. Oh, A classification of posets admitting the MacWilliams identity, IEEE Transactions
on Information Theory, vol. 51, pp. 1424-1431, 2005.
[17] A. M. Gleason, Weight polynomials of self-dual codes and the MacWilliams identities , in: Actes, Proceeding
of the congrÃ¯Â¿ 12 s international de mathÃ¯Â¿ 21 matiques, Nice, vol. 3, pp. 211-215, 1971
[18] F. J. MacWilliams, C. L. Mallows and N. J. A. Sloane, Generalizations of Gleasonâ€™s Theorem on weight
enumerators of self-dual codes IEEE Transactions on Information Theory, vol. 18, pp. 796-805, 1972.
[19] N. J. A. Sloane, The classical groups, Princeton University Press, Pinceton, N. J., 1946.
19

[20] G. Nebe, E. M. Rains, and N. J. A. Sloane, The invariants of the Cifford groups, Designs, Codes and Cryptography, vol. 24, pp 99-121, 2001.
[21] G. Nebe, E. M. Rains, N. J. A. Sloane, Codes and invariant theory, Mathematische Nachrichten, vol. 274-275,
pp. 104-116, 2004.
[22] V. Marka, R. S. Selvaraj and I. Gnanasudha, Self-dual codes in the Rosenbloom-Tsfasman metric, Mathematical Communications, vol. 22, pp. 75-87, 2017.
[23] M. Hochater and J.A. Eagon, Cohen-Macaulay rings, invariant theory, and the generic perfection of
determinantal loci, American Journal of Mathematics, vol. 93, pp. 1020-1058, 1971.
[24] W. J. Martin and D. R. Stinson, Association schemes for ordered orthogonal arrays and (T,M,S)-nets, Canadian Journal of Mathematics, vol 51, pp 326-346, 1999.
[25] V. Pless, A Classification of self-orthogonal codes over GF (2), Discrete Mathematics, vol. 3, pp. 209-246,
1972.
[26] E. Noether, Der endlichkeitssatz der invarianten endlicher gruppen, Mathematische Annalen, vol. 77, pp.
89-92, 1916.
[27] M. Yu. Rosenbloom, M. A. Tsfasman, Codes for the m-metric, Problemy Peredachi Informatsii, vol. 33,
pp. 55-63 (Russian), 1997. MR 98c:94023. English translation in Problems Inform. Transmission, vol. 33,
pp.45-52, 1997.
[28] M. M. Skriganov, Coding theory and uniform distributions, St. Petersburg Mathematical Journal, vol. 13, pp.
310-337, 2002.
[29] R. P. Stanley, Invariants of finite groups and their applications to combinatorics , American Mathematical
Society, vol. 1, pp. 475-511 , 1979.
[30] R. P. Stanley, Hilbert function of graded algebras, Advances in Math, vol. 28, pp. 57-83, 1978.
[31] W. Bosma, J. Cannon, and C. Playoust, The Magma algebra system. I. The user language, Journal of Symbolic Computation, vol. 24, pp. 235-265, 1997.

20

