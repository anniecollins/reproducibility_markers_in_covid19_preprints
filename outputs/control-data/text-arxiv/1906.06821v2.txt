1

A Survey of Optimization Methods from
a Machine Learning Perspective

arXiv:1906.06821v2 [cs.LG] 23 Oct 2019

Shiliang Sun, Zehui Cao, Han Zhu, and Jing Zhao

Abstract‚ÄîMachine learning develops rapidly, which has made
many theoretical breakthroughs and is widely applied in various
fields. Optimization, as an important part of machine learning,
has attracted much attention of researchers. With the exponential
growth of data amount and the increase of model complexity,
optimization methods in machine learning face more and more
challenges. A lot of work on solving optimization problems or
improving optimization methods in machine learning has been
proposed successively. The systematic retrospect and summary
of the optimization methods from the perspective of machine
learning are of great significance, which can offer guidance
for both developments of optimization and machine learning
research. In this paper, we first describe the optimization
problems in machine learning. Then, we introduce the principles
and progresses of commonly used optimization methods. Next,
we summarize the applications and developments of optimization
methods in some popular machine learning fields. Finally, we
explore and give some challenges and open problems for the
optimization in machine learning.
Index Terms‚ÄîMachine learning, optimization method, deep
neural network, reinforcement learning, approximate Bayesian
inference.

I. I NTRODUCTION

R

ECENTLY, machine learning has grown at a remarkable
rate, attracting a great number of researchers and
practitioners. It has become one of the most popular research
directions and plays a significant role in many fields, such
as machine translation, speech recognition, image recognition,
recommendation system, etc. Optimization is one of the core
components of machine learning. The essence of most machine
learning algorithms is to build an optimization model and learn
the parameters in the objective function from the given data.
In the era of immense data, the effectiveness and efficiency of
the numerical optimization algorithms dramatically influence
the popularization and application of the machine learning
models. In order to promote the development of machine
learning, a series of effective optimization methods were put
forward, which have improved the performance and efficiency
of machine learning methods.
From the perspective of the gradient information in optimization, popular optimization methods can be divided into
three categories: first-order optimization methods, which are
represented by the widely used stochastic gradient methods;
This work was supported by NSFC Project 61370175 and Shanghai Sailing
Program 17YF1404600.
Shiliang Sun, Zehui Cao, Han Zhu, and Jing Zhao are with
School of Computer Science and Technology, East China Normal
University, 3663 North Zhongshan Road, Shanghai 200062, P. R.
China. E-mail: slsun@cs.ecnu.edu.cn, shiliangsun@gmail.com (Shiliang Sun);
jzhao@cs.ecnu.edu.cn, jzhao2011@gmail.com (Jing Zhao)

high-order optimization methods, in which Newton‚Äôs method
is a typical example; and heuristic derivative-free optimization
methods, in which the coordinate descent method is a
representative.
As the representative of first-order optimization methods,
the stochastic gradient descent method [1], [2], as well as
its variants, has been widely used in recent years and is
evolving at a high speed. However, many users pay little
attention to the characteristics or application scope of these
methods. They often adopt them as black box optimizers,
which may limit the functionality of the optimization methods.
In this paper, we comprehensively introduce the fundamental
optimization methods. Particularly, we systematically explain
their advantages and disadvantages, their application scope,
and the characteristics of their parameters. We hope that the
targeted introduction will help users to choose the first-order
optimization methods more conveniently and make parameter
adjustment more reasonable in the learning process.
Compared with first-order optimization methods, highorder methods [3], [4], [5] converge at a faster speed in
which the curvature information makes the search direction
more effective. High-order optimizations attract widespread
attention but face more challenges. The difficulty in highorder methods lies in the operation and storage of the inverse
matrix of the Hessian matrix. To solve this problem, many
variants based on Newton‚Äôs method have been developed, most
of which try to approximate the Hessian matrix through some
techniques [6], [7]. In subsequent studies, the stochastic quasiNewton method and its variants are introduced to extend highorder methods to large-scale data [8], [9], [10].
Derivative-free optimization methods [11], [12] are mainly
used in the case that the derivative of the objective function
may not exist or be difficult to calculate. There are two
main ideas in derivative-free optimization methods. One is
adopting a heuristic search based on empirical rules, and the
other is fitting the objective function with samples. Derivativefree optimization methods can also work in conjunction with
gradient-based methods.
Most machine learning problems, once formulated, can
be solved as optimization problems. Optimization in the
fields of deep neural network, reinforcement learning, meta
learning, variational inference and Markov chain Monte
Carlo encounters different difficulties and challenges. The
optimization methods developed in the specific machine
learning fields are different, which can be inspiring to the
development of general optimization methods.
Deep neural networks (DNNs) have shown great success
in pattern recognition and machine learning. There are two

2

very popular NNs, i.e., convolutional neural networks (CNNs)
[13] and recurrent neural networks (RNNs), which play
important roles in various fields of machine learning. CNNs
are feedforward neural networks with convolution calculation.
CNNs have been successfully used in many fields such as
image processing [14], [15], video processing [16] and natural
language processing (NLP) [17], [18]. RNNs are a kind of
sequential model and very active in NLP [19], [20], [21],
[22]. Besides, RNNs are also popular in the fields of image
processing [23], [24] and video processing [25]. In the field of
constrained optimization, RNNs can achieve excellent results
[26], [27], [28], [29]. In these works, the parameters of
weights in RNNs can be learned by analytical methods, and
these methods can find the optimal solution according to the
trajectory of the state solution. Stochastic gradient-based
algorithms are widely used in deep neural networks [30], [31],
[32], [33]. However, various problems are emerging when
employing stochastic gradient-based algorithms. For example,
the learning rate will be oscillating in the later training stage
of some adaptive methods [34], [35], which may lead to
the problem of non-converging. Thus, further optimization
algorithms based on variance reduction were proposed to
improve the convergence rate [36], [37]. Moreover, combining
the stochastic gradient descent and the characteristics of its
variants is a possible direction to improve the optimization.
Especially, switching an adaptive algorithm to the stochastic
gradient descent method can improve the accuracy and
convergence speed of the algorithm [38].
Reinforcement learning (RL) is a branch of machine
learning, for which an agent interacts with the environment
by trial-and-error mechanism and learns an optimal policy
by maximizing cumulative rewards [39]. Deep reinforcement
learning combines the RL and deep learning techniques,
and enables the RL agent to have a good perception of its
environment. Recent research has shown that deep learning can
be applied to learn a useful representation for reinforcement
learning problems [40], [41], [42], [43], [44]. Stochastic
optimization algorithms are commonly used in RL and deep
RL models.
Meta learning [45], [46] has recently become very popular
in the field of machine learning. The goal of meta learning
is to design a model that can efficiently adapt to the new
environment with as few samples as possible. The application
of meta learning in supervised learning can solve the few-shot
learning problems [47]. In general, meta learning methods can
be summarized into the following three types [48]: metricbased methods [49], [50], [51], [52], model-based methods
[53], [54] and optimization-based methods [55], [56], [47]. We
will describe the details of optimization-based meta learning
methods in the subsequent sections.
Variational inference is a useful approximation method
which aims to approximate the posterior distributions in
Bayesian machine learning. It can be considered as an
optimization problem. For example, mean-field variational
inference uses coordinate ascent to solve this optimization
problem [57]. As the amount of data increases continuously,
it is not friendly to use the traditional optimization method
to handle the variational inference. Thus, the stochastic

variational inference was proposed, which introduced natural
gradients and extended the variational inference to large-scale
data [58].
Optimization methods have a significative influence on
various fields of machine learning. For example, [5] proposed
the transformer network using Adam optimization [33], which
is applied to machine translation tasks. [59] proposed superresolution generative adversarial network for image super
resolution, which is also optimized by Adam. [60] proposed
Actor-Critic using trust region optimization to solve the deep
reinforcement learning on Atari games as well as the MuJoCo
environments.
The stochastic optimization method can also be applied to
Markov chain Monte Carlo (MCMC) sampling to improve
efficiency. In this kind of application, stochastic gradient
Hamiltonian Monte Carlo (HMC) is a representative method
[61] where the stochastic gradient accelerates the step of
gradient update when handling large-scale samples. The noise
introduced by the stochastic gradient can be characterized by
introducing Gaussian noise and friction terms. Additionally,
the deviation caused by HMC discretization can be eliminated
by the friction term, and thus the Metropolis-Hasting step can
be omitted. The hyper-parameter settings in the HMC will
affect the performance of the model. There are some efficient
ways to automatically adjust the hyperparameters and improve
the performance of the sampler.
The development of optimization brings a lot of contributions to the progress of machine learning. However, there
are still many challenges and open problems for optimization
problems in machine learning. 1) How to improve optimization
performance with insufficient data in deep neural networks is a
tricky problem. If there are not enough samples in the training
of deep neural networks, it is prone to cause the problem of
high variances and overfitting [62]. In addition, non-convex
optimization has been one of the difficulties in deep neural
networks, which makes the optimization tend to get a locally
optimal solution rather than the global optimal solution. 2) For
sequential models, the samples are often truncated by batches
when the sequence is too long, which will cause deviation.
How to analyze the deviation of stochastic optimization in
this case and correct it is vital. 3) The stochastic variational
inference is graceful and practical, and it is probably a
good choice to develop methods of applying high-order
gradient information to stochastic variational inference. 4) It
may be a great idea to introduce the stochastic technique
to the conjugate gradient method to obtain an elegant and
powerful optimization algorithm. The detailed techniques to
make improvements in the stochastic conjugate gradient is an
interesting and challenging problem.
The purpose of this paper is to summarize and analyze
classical and modern optimization methods from a machine
learning perspective. The remainder of this paper is organized
as follows. Section II summarizes the machine learning
problems from the perspective of optimization. Section III
discusses the classical optimization algorithms and their latest
developments in machine learning. Particularly, the recent
popular optimization methods including the first and second
order optimization algorithms are emphatically introduced.

3

Section IV describes the developments and applications of
optimization methods in some specific machine learning fields.
Section V presents the challenges and open problems in the
optimization methods. Finally, we conclude the whole paper.
II. M ACHINE L EARNING F ORMULATED AS O PTIMIZATION
Almost all machine learning algorithms can be formulated
as an optimization problem to find the extremum of an objective function. Building models and constructing reasonable
objective functions are the first step in machine learning
methods. With the determined objective function, appropriate
numerical or analytical optimization methods are usually used
to solve the optimization problem.
According to the modeling purpose and the problem to
be solved, machine learning algorithms can be divided into
supervised learning, semi-supervised learning, unsupervised
learning, and reinforcement learning. Particularly, supervised
learning is further divided into the classification problem (e.g.,
sentence classification [17], [63], image classification [64],
[65], [66], etc.) and regression problem; unsupervised learning
is divided into clustering and dimension reduction [67], [68],
[69], among others.
A. Optimization Problems in Supervised Learning
For supervised learning, the goal is to find an optimal
mapping function f (x) to minimize the loss function of the
training samples,
N
1 X
min
L(y i , f (xi , Œ∏)),
Œ∏ N
i=1

(1)

where N is the number of training samples, Œ∏ is the parameter
of the mapping function, xi is the feature vector of the ith
samples, y i is the corresponding label, and L is the loss
function.
There are many kinds of loss functions in supervised
learning, such as the square of Euclidean distance, crossentropy, contrast loss, hinge loss, information gain and so on.
For regression problems, the simplest way is using the square
of Euclidean distance as the loss function, that is, minimizing
square errors on training samples. But the generalization
performance of this kind of empirical loss is not necessarily
good. Another typical form is structured risk minimization,
whose representative method is the support vector machine. On
the objective function, regularization items are usually added
to alleviate overfitting, e.g., in terms of L2 norm,
N
1 X
L(y i , f (xi , Œ∏)) + Œª k Œ∏ k22 .
min
Œ∏ N
i=1

(2)

where Œª is the compromise parameter, which can be determined through cross-validation.
B. Optimization Problems in Semi-supervised Learning
Semi-supervised learning (SSL) is the method between
supervised and unsupervised learning, which incorporates
labeled data and unlabeled data during the training process.

It can deal with different tasks including classification tasks
[70], [71], regression tasks [72], clustering tasks [73], [74] and
dimensionality reduction tasks [75], [76]. There are different
kinds of semi-supervised learning methods including selftraining, generative models, semi-supervised support vector
machines (S3VM) [77], graph-based methods, multi-learning
method and others. We take S3VM as an example to introduce
the optimization in semi-supervised learning.
S3VM is a learning model that can deal with binary
classification problems and only part of the training set in
this problem is labeled. Let Dl be labeled data which can
be represented as Dl = {{x1 , y 1 }, {x2 , y 2 }, ..., {xl , y l }},
and Du be unlabeled data which can be represented as
Du = {xl+1 , xl+2 , ..., xN } with N = l + u. In order to
use the information of unlabeled data, additional constraint
on the unlabeled data is added to the original objective of
SVM with slack variables Œ∂ i . Specifically, define «´j as the
misclassification error of the unlabeled instance if its true
label is positive and z j as the misclassification error of the
unlabeled instance
PNif its true label is negative. The constraint
means to make j=l+1 min(«´i , Œ∂ i ) as small as possible. Thus,
an S3VM problem can be described as
Ô£Æ
Ô£π
N
l
X
X
min k œâ k +C Ô£∞
Œ∂i +
min(«´i , z j )Ô£ª ,
i=1

j=l+1

subject to

y i (w ¬∑ xi + b) + Œ∂ i ‚â• 1, Œ∂ ‚â• 0, i = 1, ..., l,

w ¬∑ xj + b + «´j ‚â• 1, «´ ‚â• 0, j = l + 1, ..., N,
‚àí (w ¬∑ xj + b) + z j ‚â• 1, z j ‚â• 0,

(3)

where C is a penalty coefficient. The optimization problem
in S3VM is a mixed-integer problem which is difficult to
deal with [78]. There are various methods summarized in
[79] to deal with this problem, such as the branch and bound
techniques [80] and convex relaxation methods [81].
C. Optimization Problems in Unsupervised Learning
Clustering algorithms [67], [82], [83], [84] divide a group
of samples into multiple clusters ensuring that the differences
between the samples in the same cluster are as small as
possible, and samples in different clusters are as different as
possible. The optimization problem for the k-means clustering
algorithm is formulated as minimizing the following loss
function:
min
S

K X
X

k=1 x‚ààSk

kx ‚àí ¬µk k22 ,

(4)

where K is the number of clusters, x is the feature vector of
samples, ¬µk is the center of cluster k, and Sk is the sample set
of cluster k. The implication of this objective function is to
make the sum of variances of all clusters as small as possible.
The dimensionality reduction algorithm ensures that the
original information from data is retained as much as possible
after projecting them into the low-dimensional space. Principal
component analysis (PCA) [85], [86], [87] is a typical

4

algorithm of dimensionality reduction methods. The objective
of PCA is formulated to minimize the reconstruction error as
min

N
X
i=1

‚Ä≤

i

kx ‚àí

xi k22

i

where x =

D
X
j=1

zji ej , D ‚â´ D‚Ä≤ , (5)

where N represents the number of samples, xi is a Ddimensional vector, xi is the reconstruction of xi . z i =
i
{z1i , ..., zD
is the projection of xi in D‚Ä≤ -dimensional
‚Ä≤}
coordinates. ej is the standard orthogonal basis under D‚Ä≤ dimensional coordinates.
Another common optimization goal in probabilistic models
is to find an optimal probability density function of p(x),
which maximizes the logarithmic likelihood function (MLE)
of the training samples,
max

N
X

ln p(xi ; Œ∏).

(6)

i=1

In the framework of Bayesian methods, some prior distributions are often assumed on parameter Œ∏, which also has the
effect of alleviating overfitting.
D. Optimization Problems in Reinforcement Learning
Reinforcement learning [42], [88], [89], unlike supervised
learning and unsupervised learning, aims to find an optimal
strategy function, whose output varies with the environment.
For a deterministic strategy, the mapping function from state
s to action a is the learning target. For an uncertain strategy,
the probability of executing each action is the learning target.
In each state, the action is determined by a = œÄ(s), where
œÄ(s) is the policy function.
The optimization problem in reinforcement learning can
be formulated as maximizing the cumulative return after
executing a series of actions which are determined by the
policy function,
"‚àû
#
X
max VœÄ (s) where VœÄ (s) = E
Œ≥ k rt+k |St = s , (7)
œÄ

k=0

where VœÄ (s) is the value function of state s under policy œÄ, r
is the reward, and Œ≥ ‚àà [0, 1] is the discount factor.
E. Optimization for Machine Learning

Overall, the main steps of machine learning are to build a
model hypothesis, define the objective function, and solve the
maximum or minimum of the objective function to determine
the parameters of the model. In these three vital steps, the first
two steps are the modeling problems of machine learning, and
the third step is to solve the desired model by optimization
methods.
III. F UNDAMENTAL O PTIMIZATION M ETHODS AND
P ROGRESSES
From the perspective of gradient information, fundamental
optimization methods can be divided into first-order optimization methods, high-order optimization methods and derivativefree optimization methods. These methods have a long history
and are constantly evolving. They are progressing in many

practical applications and have achieved good performance.
Besides these fundamental methods, preconditioning is a useful technique for optimization methods. Applying reasonable
preconditioning can reduce the number of iterations and obtain
better spectral characteristics. These technologies have been
widely used in practice. For the convenience of researchers,
we summarize the existing common optimization toolkits in a
table at the end of this section.
A. First-Order Methods
In the field of machine learning, the most commonly
used first-order optimization methods are mainly based on
gradient descent. In this section, we introduce some of the
representative algorithms along with the development of the
gradient descent methods. At the same time, the classical
alternating direction method of multipliers and the FrankWolfe method in numerical optimization are also introduced.
1) Gradient Descent: The gradient descent method is the
earliest and most common optimization method. The idea of
the gradient descent method is that variables update iteratively
in the (opposite) direction of the gradients of the objective
function. The update is performed to gradually converge to
the optimal value of the objective function. The learning rate
Œ∑ determines the step size in each iteration, and thus influences
the number of iterations to reach the optimal value [90].
The steepest descent algorithm is a widely known algorithm.
The idea is to select an appropriate search direction in each
iteration so that the value of the objective function minimizes
the fastest. Gradient descent and steepest descent are not the
same, because the direction of the negative gradient does not
always descend fastest. Gradient descent is an example of
using the Euclidean norm in steepest descent [91].
Next, we give the formal expression of gradient descent
method. For a linear regression model, we assume that fŒ∏ (x)
is the function to be learned, L(Œ∏) is the loss function, and Œ∏
is the parameter to be optimized. The goal is to minimize the
loss function with
N
1 X i
L(Œ∏) =
(y ‚àí fŒ∏ (xi ))2 ,
(8)
2N i=1
fŒ∏ (x) =

D
X

Œ∏j xj ,

(9)

j=1

where N is the number of training samples, D is the number
of input features, xi is an independent variable with xi =
(xi1 , ..., xiD ) for i = 1, ..., N and y i is the target output. The
gradient descent alternates the following two steps until it
converges:
1) Derive L(Œ∏) for Œ∏j to get the gradient corresponding to
each Œ∏j :
N
1 X i
‚àÇL(Œ∏)
(y ‚àí fŒ∏ (xi ))xij .
=‚àí
‚àÇŒ∏j
N i=1

(10)

2) Update each Œ∏j in the negative gradient direction to
minimize the risk function:
N
‚Ä≤
1 X i
Œ∏j = Œ∏j + Œ∑ ¬∑
(y ‚àí fŒ∏ (xi ))xij .
(11)
N i=1

5

The gradient descent method is simple to implement. The
solution is global optimal when the objective function is
convex. It often converges at a slower speed if the variable
is closer to the optimal solution, and more careful iterations
need to be performed.
In the above linear regression example, note that all the
training data are used in each iteration step, so the gradient
descent method is also called the batch gradient descent. If
the number of samples is N and the dimension of x is D, the
computation complexity for each iteration will be O(N D). In
order to mitigate the cost of computation, some parallelization
methods were proposed [92], [93]. However, the cost is still
hard to accept when dealing with large-scale data. Thus, the
stochastic gradient descent method emerges.
2) Stochastic Gradient Descent: Since the batch gradient
descent has high computational complexity in each iteration
for large-scale data and does not allow online update,
stochastic gradient descent (SGD) was proposed [1]. The idea
of stochastic gradient descent is using one sample randomly to
update the gradient per iteration, instead of directly calculating
the exact value of the gradient. The stochastic gradient is
an unbiased estimate of the real gradient [1]. The cost
of the stochastic gradient descent algorithm is independent
of sample numbers and can achieve sublinear convergence
speed [37]. SGD reduces the update time for dealing with
large numbers of samples and removes a certain amount
of computational redundancy, which significantly accelerates
the calculation. In the strong convex problem, SGD can
achieve the optimal convergence speed [94], [95], [96], [36].
Meanwhile, it overcomes the disadvantage of batch gradient
descent that cannot be used for online learning.
The loss function (8) can be written as the following
equation:
N
N
1 X
1 X1 i
cost(Œ∏, (xi , y i )).
(y ‚àí fŒ∏ (xi ))2 =
N i=1 2
N i=1
(12)
If a random sample i is selected in SGD, the loss function
will be L‚àó (Œ∏):
1
L‚àó (Œ∏) = cost(Œ∏, (xi , y i )) = (y i ‚àí fŒ∏ (xi ))2 .
(13)
2
The gradient update in SGD uses the random sample i rather
than all samples in each iteration,

L(Œ∏) =

‚Ä≤

Œ∏ = Œ∏ + Œ∑(y i ‚àí fŒ∏ (xi ))xi .

(14)

Since SGD uses only one sample per iteration, the computation complexity for each iteration is O(D) where D is
the number of features. The update rate for each iteration of
SGD is much faster than that of batch gradient descent when
the number of samples N is large. SGD increases the overall
optimization efficiency at the expense of more iterations, but
the increased iteration number is insignificant compared with
the high computation complexity caused by large numbers
of samples. It is possible to use only thousands of samples
overall to get the optimal solution even when the sample
size is hundreds of thousands. Therefore, compared with
batch methods, SGD can effectively reduce the computational
complexity and accelerate convergence.

However, one problem in SGD is that the gradient direction
oscillates because of additional noise introduced by random
selection, and the search process is blind in the solution space.
Unlike batch gradient descent which always moves towards
the optimal value along the negative direction of the gradient,
the variance of gradients in SGD is large and the movement
direction in SGD is biased. So, a compromise between the two
methods, the mini-batch gradient descent method (MSGD),
was proposed [1].
The MSGD uses b independent identically distributed
samples (b is generally in 50 to 256 [90]) as the sample sets to
update the parameters in each iteration. It reduces the variance
of the gradients and makes the convergence more stable, which
helps to improve the optimization speed. For brevity, we will
call MSGD as SGD in the following sections.
As a common feature of stochastic optimization, SGD
has a better chance of finding the global optimal solution
for complex problems. The deterministic gradient in batch
gradient descent may cause the objective function to fall into a
local minimum for the multimodal problem. The fluctuation in
the SGD helps the objective function jump to another possible
minimum. However, the fluctuation in SGD always exists,
which may more or less slow down the process of converging.
There are still many details to be noted about the use of
SGD in the concrete optimization process [90], such as the
choice of a proper learning rate. A too small learning rate
will result in a slower convergence rate, while a too large
learning rate will hinder convergence, making loss function
fluctuate at the minimum. One way to solve this problem is to
set up a predefined list of learning rates or a certain threshold
and adjust the learning rate during the learning process [97],
[98]. However, these lists or thresholds need to be defined in
advance according to the characteristics of the dataset. It is also
inappropriate to use the same learning rate for all parameters.
If data are sparse and features occur at different frequencies, it
is not expected to update the corresponding variables with the
same learning rate. A higher learning rate is often expected
for less frequently occurring features [30], [33].
Besides the learning rate, how to avoid the objective
function being trapped in infinite numbers of the local
minimum is a common challenge. Some work has proved
that this difficulty does not come from the local minimum
values, but comes from the ‚Äúsaddle point‚Äù [99]. The slope
of a saddle point is positive in one direction and negative
in another direction, and gradient values in all directions are
zero. It is an important problem for SGD to escape from these
points. Some research about escaping from saddle points were
developed [100], [101].
3) Nesterov Accelerated Gradient Descent: Although SGD
is popular and widely used, its learning process is sometimes
prolonged. How to adjust the learning rate, how to speed up
the convergence, and how to prevent being trapped at a local
minimum during the search are worthwhile research directions.
Much work is presented to improve SGD. For example, the
momentum idea was proposed to be applied in SGD [102].
The concept of momentum is derived from the mechanics
of physics, which simulates the inertia of objects. The idea
of applying momentum in SGD is to preserve the influence

6

of the previous update direction on the next iteration to a
certain degree. The momentum method can speed up the
convergence when dealing with high curvature, small but
consistent gradients, or noisy gradients [103]. The momentum
algorithm introduces the variable v as the speed, which
represents the direction and the rate of the parameter‚Äôs
movement in the parameter space. The speed is set as the
average exponential decay of the negative gradient.
In the gradient descent method, the speed update is v =
Œ∑ ¬∑ (‚àí ‚àÇL(Œ∏)
‚àÇ(Œ∏) ) each time. Using the momentum algorithm, the
amount of the update v is not just the amount of gradient
descent calculated by Œ∑ ¬∑ (‚àí ‚àÇL(Œ∏)
‚àÇ(Œ∏) ). It also takes into account
the friction factor, which is represented as the previous update
v old multiplied by a momentum factor ranging between [0, 1].
Generally, the mass of the object is set to 1. The formulation
is expressed as
v = Œ∑ ¬∑ (‚àí

‚àÇL(Œ∏)
) + v old ¬∑ mtm,
‚àÇ(Œ∏)

(15)

where mtm is the momentum factor. If the current gradient
is parallel to the previous speed v old , the previous speed can
speed up this search. The proper momentum plays a role in
accelerating the convergence when the learning rate is small. If
the derivative decays to 0, it will continue to update v to reach
equilibrium and will be attenuated by friction. It is beneficial
for escaping from the local minimum in the training process
so that the search process can converge more quickly [102],
[104]. If the current gradient is opposite to the previous update
v old , the value v old will have a deceleration effect on this
search.
The momentum method with a proper momentum factor
plays a positive role in reducing the oscillation of convergence
when the learning rate is large. How to select the proper size
of the momentum factor is also a problem. If the momentum
factor is small, it is hard to obtain the effect of improving
convergence speed. If the momentum factor is large, the
current point may jump out of the optimal value point. Many
experiments have empirically verified the most appropriate
setting for the momentum factor is 0.9 [90].
Nesterov Accelerated Gradient Descent (NAG) makes further improvement over the traditional momentum method
[104], [105]. In Nesterov momentum, the momentum v old ¬∑
e The gradient of Œ∏e is used
mtm is added to Œ∏, denoted as Œ∏.
when updating. The detailed update formulae for parameters
Œ∏ are as follows:
Ô£±
Œ∏e = Œ∏ + v old ¬∑ mtm,
Ô£¥
Ô£¥
Ô£¥
Ô£≤

e
‚àÇL(Œ∏)
old
),
v
=
v
¬∑
mtm
+
Œ∑
¬∑
(‚àí
Ô£¥
‚àÇ(Œ∏)
Ô£¥
Ô£¥
Ô£≥ ‚Ä≤
Œ∏ = Œ∏ + v.

(16)

The improvement of Nesterov momentum over momentum
is reflected in updating the gradient of the future position
instead of the current position. From the update formula, we
can find that Nestorov momentum includes more gradient
information compared with the traditional momentum method.
Note that Nesterov momentum improves the convergence from

O( k1 ) (after k steps) to O( k12 ), when not using stochastic
optimization [105].
Another issue worth considering is how to determine the
size of the learning rate. It is more likely to occur the
oscillation if the search is closer to the optimal point. Thus, the
learning rate should be adjusted. The learning rate decay factor
d is commonly used in the SGD‚Äôs momentum method, which
makes the learning rate decrease with the iteration period
[106]. The formula of the learning rate decay is defined as
Œ∑0
,
(17)
1+d¬∑t
where Œ∑t is the learning rate at the tth iteration, Œ∑0 is the
original learning rate, and d is a decimal in [0, 1]. As can be
seen from the formula, the smaller the d is, the slower the
decay of the learning rate will be. The learning rate remains
unchanged when d = 0 and the learning rate decays fastest
when d = 1.
4) Adaptive Learning Rate Method: The manually regulated learning rate greatly influences the effect of the SGD
method. It is a tricky problem for setting an appropriate value
of the learning rate [30], [33], [107]. Some adaptive methods
were proposed to adjust the learning rate automatically. These
methods are free of parameter adjustment, fast to converge,
and often achieving not bad results. They are widely used in
deep neural networks to deal with optimization problems.
The most straightforward improvement to SGD is AdaGrad
[30]. AdaGrad adjusts the learning rate dynamically based on
the historical gradient in some previous iterations. The update
formulae are as follows:
Ô£±
‚àÇL(Œ∏t )
Ô£¥
,
Ô£¥ gt =
Ô£¥
Ô£¥
Ô£¥
r‚àÇŒ∏
Ô£≤
Xt
(18)
(gi )2 + «´,
Vt =
Ô£¥
i=1
Ô£¥
Ô£¥
Ô£¥
Ô£¥
Ô£≥ Œ∏t+1 = Œ∏t ‚àí Œ∑ gt ,
Vt
Œ∑t =

where gt is the gradient of parameter Œ∏ at iteration t, Vt is
the accumulate historical gradient of parameter Œ∏ at iteration
t, and Œ∏t is the value of parameter Œ∏ at iteration t.
The difference between AdaGrad and gradient descent is
that during the parameter update process, the learning rate
is no longer fixed, but is computed using all the historical
gradients accumulated up to this iteration. One main benefit
of AdaGrad is that it eliminates the need to tune the learning
rate manually. Most implementations use a default value of
0.01 for Œ∑ in (18).
Although AdaGrad adaptively adjusts the learning rate, it
still has two issues. 1) The algorithm still needs to set the
global learning rate Œ∑ manually. 2) As the training time
increases, the accumulated gradient will become larger and
larger, making the learning rate tend to zero, resulting in
ineffective parameter update.
AdaGrad was further improved to AdaDelta [31] and
RMSProp [32] for solving the problem that the learning
rate will eventually go to zero. The idea is to consider not
accumulating all historical gradients, but focusing only on
the gradients in a window over a period, and using the

7

exponential moving average to calculate the second-order
cumulative momentum,
p
Vt = Œ≤Vt‚àí1 + (1 ‚àí Œ≤)(gt )2 ,
(19)

where Œ≤ is the exponential decay parameter. Both RMSProp
and AdaDelta have been developed independently around the
same time, stemming from the need to resolve the radically
diminishing learning rates of AdaGrad.
Adaptive moment estimation (Adam) [33] is another advanced SGD method, which introduces an adaptive learning
rate for each parameter. It combines the adaptive learning
rate and momentum methods. In addition to storing an
exponentially decaying average of past squared gradients
Vt , like AdaDelta and RMSProp, Adam also keeps an
exponentially decaying average of past gradients mt , similar
to the momentum method:
mt = Œ≤1 mt‚àí1 + (1 ‚àí Œ≤1 )gt ,
Vt =

p
Œ≤2 Vt‚àí1 + (1 ‚àí Œ≤2 )(gt )2 ,

(20)
(21)

where Œ≤1 and Œ≤2 are exponential decay rates. The final update
formula for the parameter Œ∏ is
‚àö
1 ‚àí Œ≤2 mt
.
(22)
Œ∏t+1 = mt ‚àí Œ∑
1 ‚àí Œ≤1 Vt + «´

The default values of Œ≤1 , Œ≤2 , and «´ are suggested to set
to 0.9, 0.999, and 10‚àí8 , respectively. Adam works well in
practice and compares favorably to other adaptive learning rate
algorithms.
5) Variance Reduction Methods: Due to a large amount
of redundant information in the training samples, the SGD
methods are very popular since they were proposed. However,
the stochastic gradient method can only converge at a sublinear
rate and the variance of gradient is often very large. How
to reduce the variance and improve SGD to the linear
convergence has always been an important problem.
Stochastic Average Gradient The stochastic average
gradient (SAG) method [36] is a variance reduction method
proposed to improve the convergence speed. The SAG
algorithm maintains parameter d recording the sum of the N
latest gradients {gi } in memory where gi is calculated using
one sample i, i ‚àà {1, ..., N }. The detailed implementation is
to select a sample it to update d randomly, and use d to update
the parameter Œ∏ in iteration t:
Ô£±
d = d ‚àí gÃÇit + git (Œ∏t‚àí1 ),
Ô£¥
Ô£¥
Ô£≤
gÃÇit = git (Œ∏t‚àí1 ),
(23)
Ô£¥
Ô£¥
Ô£≥ Œ∏t = Œ∏t‚àí1 ‚àí Œ± d,
N
where the updated item d is calculated by replacing the old
gradient gÃÇit in d with the new gradient git (Œ∏t‚àí1 ) in iteration
t, Œ± is a constant representing the learning rate. Thus, each
update only needs to calculate the gradient of one sample, not
the gradients of all samples. The computational overhead is
no different from SGD, but the memory overhead is much
larger. This is a typical way of using space for saving time.
The SAG has been shown to be a linear convergence algorithm

[36], which is much faster than SGD, and has great advantages
over other stochastic gradient algorithms.
However, the SAG method is only applicable to the case
where the loss function is smooth and the objective function is
convex [36], [108], such as convex linear prediction problems.
In this case, the SAG achieves a faster convergence rate
than the SGD. In addition, under some specific problems, it
can even deliver better convergence than the standard batch
gradient descent.
Stochastic Variance Reduction Gradient Since the SAG
method is only applicable to smooth and convex functions
and needs to store the gradient of each sample, it is
inconvenient to be applied in non-convex neural networks. The
stochastic variance reduction gradient (SVRG) [37] method
was proposed to improve the performance of optimization in
the complex models.
The algorithm of SVRG maintains the interval average
gradient ¬µÃÉ by calculating the gradients of all samples in every
w iterations instead of in each iteration:
¬µÃÉ =

N
1 X
gi (Œ∏ÃÉ),
N i=1

(24)

where Œ∏ÃÉ is the interval update parameter. The interval
parameter ¬µÃÉ contains the average memory of all sample
gradients in the past time for each time interval w. SVRG
picks uniform it ‚àà {1, ..., N } randomly, and executes gradient
updates to the current parameters:
Œ∏t = Œ∏t‚àí1 ‚àí Œ∑ ¬∑ (git (Œ∏t‚àí1 ) ‚àí git (Œ∏ÃÉ) + ¬µÃÉ).

(25)

The gradient is calculated up to two times in each update. After
w iterations, perform Œ∏ÃÉ ‚Üê Œ∏w and start the next w iterations.
Through these update, Œ∏t and the interval update parameter Œ∏ÃÉ
will converge to the optimal Œ∏‚àó , and then ¬µÃÉ ‚Üí 0, and
git (Œ∏t‚àí1 ) ‚àí git (Œ∏ÃÉ) + ¬µÃÉ ‚Üí git (Œ∏t‚àí1 ) ‚àí git (Œ∏‚àó ) ‚Üí 0.

(26)

SVRG proposes a vital concept called variance reduction.
This concept is related to the convergence analysis of SGD,
in which it is necessary to assume that there is a constant
upper bound for the variance of the gradients. This constant
upper bound implies that the SGD cannot achieve linear
convergence. However, in SVRG, the upper bound of variance
can be continuously reduced due to the special update item
git (Œ∏t‚àí1 ) ‚àí git (Œ∏ÃÉ) + ¬µÃÉ , thus achieving linear convergence
[37].
The strategies of SAG and SVRG are related to variance
reduction. Compared with SAG, SVRG does not need to
maintain all gradients in memory, which means that memory
resources are saved, and it can be applied to complex problems
efficiently. Experiments have shown that the performance of
SVRG is remarkable on a non-convex neural network [37],
[109], [110]. There are also many variants of such linear
convergence stochastic optimization algorithms, such as the
SAGA algorithm [111].
6) Alternating Direction Method of Multipliers: Augmented Lagrangian multiplier method is a common method to
solve optimization problems with linear constraints. Compared
with the naive Lagrangian multiplier method, it makes

8

problems easier to solve by adding a penalty term to the
objective. Consider the following example,
min {Œ∏1 (x) + Œ∏2 (y)|Ax + By = b, x ‚àà X , y ‚àà Y} .

(27)

The augmented Lagrange function for problem (27) is
LŒ≤ (x, y, Œª) =Œ∏1 (x) + Œ∏2 (y) ‚àí Œª‚ä§ (Ax + By ‚àí b)
Œ≤
+ ||Ax + By ‚àí b||2 .
2

(28)

When solved by the augmented Lagrangian multiplier method,
its tth step iteration starts from the given Œªt , and the
optimization turns out to
(
(xt+1 , yt+1 ) = arg min {LŒ≤ (x, y, Œªt )|x ‚àà X , y ‚àà Y} ,
Œªt+1 = Œªt ‚àí Œ≤(Axt+1 + Byt+1 ‚àí b).

(29)

Separating the (x, y) sub-problem in (29), the augmented
Lagrange multiplier method can be relaxed to the following
alternating direction method of multipliers (ADMM) [112],
[113]. Its tth step iteration starts with the given (yt , Œªt ), and
the details of iterative optimization are as follows:
Ô£±


Œ≤
Ô£¥
‚ä§
2
Ô£¥
xt+1 = arg min Œ∏1 (x) ‚àí (Œªt ) Ax + ||Conx || |x ‚àà X ,
Ô£¥
Ô£¥
Ô£¥
2
Ô£≤


Œ≤
2
‚ä§
yt+1 = arg min Œ∏2 (y) ‚àí (Œªt ) By + ||Cony || |y ‚àà Y ,
Ô£¥
Ô£¥
Ô£¥
2
Ô£¥
Ô£¥
Ô£≥
Œªt+1 = Œªt ‚àí Œ≤(Axt+1 + Byt+1 ‚àí b),
(30)
where Conx = Ax + Byt ‚àí b and Cony = Axt+1 + By ‚àí b.
The penalty parameter Œ≤ has a certain impact on the
convergence rate of the ADMM. The larger Œ≤ is, the greater the
penalties for the constraint term. In general, a monotonically
increasing sequence of {Œ≤t } can be adopted instead of the
fixed Œ≤ [114]. Specifically, an auto-adjustment criterion that
automatically adjusts {Œ≤t } based on the current value of {xt }
during the iteration was proposed, and applied for solving
some convex optimization problems [115], [116].
The ADMM method uses the separable operators in the
convex optimization problem to divide a large problem into
multiple small problems that can be solved in a distributed
manner. In theory, the framework of ADMM can solve most of
the large-scale optimization problems. However, there are still
some problems in practical applications. For example, if we
use a stop criterion to determine whether convergence occurs,
the original residuals and dual residuals are both related to Œ≤,
and Œ≤ with a large value will lead to difficulty in meeting the
convergence conditions [117].
7) Frank-Wolfe Method: In 1956, Frank and Wolfe proposed an algorithm for solving linear constraint problems
[118]. The basic idea is to approximate the objective function
with a linear function, then solve the linear programming to
find the feasible descending direction, and finally make a onedimensional search along the direction in the feasible domain.
This method is also called the approximate linearization
method.

Here, we give a simple example of Frank-Wolfe method.
Consider the optimization problem,
Ô£±
Ô£≤ min f (x),
s.t. Ax = b,
(31)
Ô£≥
x ‚â• 0,

where A is an m √ó n full row rank matrix, and the feasible
region is S = {x|Ax = b, x ‚â• 0}. Expand f (x) linearly at
x0 , f (x) ‚âà f (x0 ) + ‚àáf (x0 )‚ä§ (x ‚àí x0 ), and substitute it into
equation (31). Then we have

min f (xt ) + ‚àáf (xt )‚ä§ (x ‚àí xt ),
(32)
s.t. x ‚àà S,
which is equivalent to


min ‚àáf (xt )‚ä§ x,
s.t. x ‚àà S.

(33)

Suppose there exist an optimal solution yt , and then there
must be
(
‚àáf (xt )‚ä§ yt < ‚àáf (xt )‚ä§ xt ,
(34)
‚àáf (xt )‚ä§ (yt ‚àí xt ) < 0.
So yt ‚àí xt is the decreasing direction of f (x) at xt . A fetch
step of Œªt updates the search point in a feasible direction. The
detailed operation is shown in Algorithm 1.
Algorithm 1 Frank-Wolfe Method [118], [119]
Input: x0 , Œµ ‚â• 0, t := 0
Output: x‚àó
yt ‚Üê min ‚àáf (xt )‚ä§ x
while |‚àáf (xt )‚ä§ (yt ‚àí xt )| > Œµ do
Œªt = arg min0‚â§Œª‚â§1 f (xt + Œª(yt ‚àí xt ))
xt+1 ‚âà xt + Œªt (yt ‚àí xt )
t := t + 1
yt ‚Üê min ‚àáf (xt )‚ä§ x
end while
x‚àó ‚âà xt
The algorithm satisfies the following convergence theorem
[118]:
(1) xt is the Kuhn-Tucker point of (31) when ‚àáf (xt )‚ä§ (yt ‚àí
xt ) = 0.
(2) Since yt is an optimal solution for problem (33), the
vector dt satisfies dt = yt ‚àí xt and is the feasible descending
direction of f at point xt when ‚àáf (xt )‚ä§ (yt ‚àí xt ) 6= 0.
The Frank-Wolfe algorithm is a first-order iterative method
for solving convex optimization problems with constrained
conditions. It consists of determining the feasible descent
direction and calculating the search step size. The algorithm
is characterized by fast convergence in early iterations and
slower in later phases. When the iterative point is close to
the optimal solution, the search direction and the gradient
direction of the objective function tend to be orthogonal. Such
a direction is not the best downward direction so that the
Frank-Wolfe algorithm can be improved and extended in terms
of the selection of the descending directions [120], [121],
[122].

9

8) Summary: We summarize the mentioned first-order
optimization methods in terms of properties, advantages, and
disadvantages in Table I.

optimization problem that minimizes the quadratic positive
definite function,
min F (Œ∏) =
Œ∏

B. High-Order Methods
The second-order methods can be used for addressing the
problem where an objective function is highly non-linear and
ill-conditioned. They work effectively by introducing curvature
information.
This section begins with introducing the conjugate gradient
method, which is a method that only needs first-order derivative information for well-defined quadratic programming, but
overcomes the shortcoming of the steepest descent method,
and avoids the disadvantages of Newton‚Äôs method of storing
and calculating the inverse Hessian matrix. But note that
when applying it to general optimization problems, the secondorder gradient is needed to get an approximation to quadratic
programming. Then, the classical quasi-Newton method using
second-order information is described. Although the convergence of the algorithm can be guaranteed, the computational
process is costly and thus rarely used for solving large machine
learning problems. In recent years, with the continuous
improvement of high-order optimization methods, more and
more high-order methods have been proposed to handle largescale data by using stochastic techniques [124], [125], [126].
From this perspective, we discuss several high-order methods
including the stochastic quasi-Newton method (integrating the
second-order information and the stochastic method) and their
variants. These algorithms allow us to use high-order methods
to process large-scale data.
1) Conjugate Gradient Method: The conjugate gradient
(CG) approach is a very interesting optimization method,
which is one of the most effective methods for solving largescale linear systems of equations. It can also be used for
solving nonlinear optimization problems [93]. As we know,
the first-order methods are simple but have a slow convergence
speed, and the second-order methods need a lot of resources.
Conjugate gradient optimization is an intermediate algorithm,
which can only utilize the first-order information for some
problems but ensures the convergence speed like high-order
methods.
Early in the 1960s, a conjugate gradient method for solving
a linear system was proposed, which is an alternative to Gaussian elimination [127]. Then in 1964, the conjugate gradient
method was extended to handle nonlinear optimization for
general functions [93]. For years, many different algorithms
have been presented based on this method, some of which
have been widely used in practice. The main features of these
algorithms are that they have faster convergence speed than
steepest descent. Next, we describe the conjugate gradient
method.
Consider a linear system,
AŒ∏ = b,

(35)

where A is an n √ó n symmetric, positive-definite matrix. The
matrix A and vector b are known, and we need to solve the
value of Œ∏. The problem (35) can also be considered as an

1 ‚ä§
Œ∏ AŒ∏ ‚àí bŒ∏ + c.
2

(36)

The above two equations have an identical unique solution. It
enables us to regard the conjugate gradient as a method for
solving optimization problems.
The gradient of F (Œ∏) can be obtained by simple calculation,
and it equals the residual of the linear system [93]: r(Œ∏) =
‚àáF (Œ∏) = AŒ∏ ‚àí b.
Definition 1: Conjugate: Given an n√ón symmetric positivedefinite matrix A, two non-zero vector di , dj are conjugate
with respect to A if
d‚ä§
i Adj = 0.

(37)

A set of non-zero vector {d1 , d2 , d3 , ...., dn } is said to be
conjugate with respect to A if any two unequal vectors are
conjugate with respect to A [93].
Next, we introduce the detailed derivation of the conjugate
n‚àí1
gradient method. Œ∏0 is a starting point, {dt }t=1
is a set of
conjugate directions. In general, one can generate the update
sequence {Œ∏1 , Œ∏2 , ...., Œ∏n } by a iteration formula:
Œ∏t+1 = Œ∏t + Œ∑t dt .

(38)

The step size Œ∑t can be obtained by a linear search, which
means choosing Œ∑t to minimize the object function f (¬∑) along
Œ∏t +Œ∑t dt . After some calculations (more details in [93], [128]),
the update formula of Œ∑t is
Œ∑t =

rt‚ä§ rt
.
d‚ä§
t Adt

(39)

The search direction dt is obtained by a linear combination of
the negative residual and the previous search direction,
dt = ‚àírt + Œ≤t dt‚àí1 ,

(40)

where rt can be updated by rt = rt‚àí1 + Œ∑t‚àí1 Adt‚àí1 . The
scalar Œ≤t is the update parameter, which can be determined
by satisfying the requirement that dt and dt‚àí1 are conjugate
with respect to A, i.e., d‚ä§
t Adt‚àí1 = 0. Multiplying both sides
of the equation (40) by d‚ä§
t‚àí1 A, one can obtain Œ≤t by
Œ≤t =

d‚ä§
t‚àí1 Art
.
‚ä§
dt‚àí1 Adt‚àí1

(41)

After several derivations of the above formula according to
[93], the simplified version of Œ≤t is
Œ≤t =

rt‚ä§ rt
.
‚ä§
rt‚àí1 rt‚àí1

(42)

The CG method, has a graceful property that generating a
new vector dt only using the previous vector dt‚àí1 , which does
not need to know all the previous vectors d0 , d1 , d2 . . . dt‚àí2 .
The linear conjugate gradient algorithm is shown in Algorithm
2.

10

TABLE I: Summary of First-Order Optimization Methods
Method

Properties

Advantages

Disadvantages

GD

Solve the optimal value along the
direction of the gradient descent. The
method converges at a linear rate.

The solution is global optimal when the
objective function is convex.

In each parameter update, gradients of
total samples need to be calculated, so
the calculation cost is high.

SGD [1]

The update parameters are calculated
using a randomly sampled mini-batch.
The method converges at a sublinear
rate.

The calculation time for each update
does not depend on the total number
of training samples, and a lot of
calculation cost is saved.

It is difficult to choose an appropriate
learning rate, and using the same
learning rate for all parameters is
not appropriate. The solution may be
trapped at the saddle point in some
cases.

NAG [105]

Accelerate the current gradient descent
by accumulating the previous gradient
as momentum and perform the gradient
update process with momentum.

When the gradient direction changes,
the momentum can slow the update
speed and reduce the oscillation; when
the gradient direction remains, the momentum can accelerate the parameter
update. Momentum helps to jump out
of locally optimal solution.

It is difficult to choose a suitable
learning rate.

AdaGrad [30]

The learning rate is adaptively adjusted
according to the sum of the squares of
all historical gradients.

In the early stage of training, the cumulative gradient is smaller, the learning
rate is larger, and learning speed is
faster. The method is suitable for
dealing with sparse gradient problems.
The learning rate of each parameter
adjusts adaptively.

As the training time increases, the accumulated gradient will become larger
and larger, making the learning rate
tend to zero, resulting in ineffective
parameter updates. A manual learning
rate is still needed. It is not suitable for
dealing with non-convex problems.

AdaDelta/
RMSProp
[32]

Change the way of total gradient
accumulation to exponential moving
average.

Improve the ineffective learning problem in the late stage of AdaGrad. It
is suitable for optimizing non-stationary
and non-convex problems.

In the late training stage, the update
process may be repeated around the
local minimum.

Adam [33]

Combine the adaptive methods and the
momentum method. Use the first-order
moment estimation and the secondorder moment estimation of the gradient to dynamically adjust the learning
rate of each parameter. Add the bias
correction.

The gradient descent process is relatively stable. It is suitable for most
non-convex optimization problems with
large data sets and high dimensional
space.

The method may not converge in some
cases.

SAG [36]

The old gradient of each sample and
the summation of gradients over all
samples are maintained in memory. For
each update, one sample is randomly
selected and the gradient sum is
recalculated and used as the update
direction.

The method is a linear convergence
algorithm, which is much faster than
SGD.

The method is only applicable to
smooth and convex functions and needs
to store the gradient of each sample. It
is inconvenient to be applied in nonconvex neural networks.

SVRG [37]

Instead of saving the gradient of each
sample, the average gradient is saved at
regular intervals. The gradient sum is
updated at each iteration by calculating
the gradients with respect to the old
parameters and the current parameters
for the randomly selected samples.

The method does not need to maintain
all gradients in memory, which saves
memory resources. It is a linear convergence algorithm.

To apply it to larger/deeper neural nets
whose training cost is a critical issue,
further investigation is still needed.

ADMM [123]

The method solves optimization problems with linear constraints by adding
a penalty term to the objective and
separating variables into sub-problems
which can be solved iteratively.

The method uses the separable operators in the convex optimization
problem to divide a large problem into
multiple small problems that can be
solved in a distributed manner. The
framework is practical in most largescale optimization problems.

The original residuals and dual residuals are both related to the penalty
parameter whose value is difficult to
determine.

Frank-Wolfe
[118]

The method approximates the objective function with a linear function,
solves the linear programming to find
the feasible descending direction, and
makes a one-dimensional search along
the direction in the feasible domain.

The method can solve optimization
problems with linear constraints, whose
convergence speed is fast in early
iterations.

The method converges slowly in later
phases. When the iterative point is close
to the optimal solution, the search direction and the gradient of the objective
function tend to be orthogonal. Such
a direction is not the best downward
direction.

[31],

11

Algorithm 2 Conjugate Gradient Method [128]

second-order gradient is not directly needed in the quasiNewton method, so it is sometimes more efficient than
Newton‚Äôs method. In the following section, we will introduce
several quasi-Newton methods, in which the Hessian matrix
and its inverse matrix are approximated by different methods.
Quasi-Newton Condition We first introduce the quasiNewton condition. Assuming that the objective function f can
be approximated by a quadratic function, we can extend f (Œ∏)
to Taylor series at Œ∏ = Œ∏t+1 , i.e.,

Input: A, b, Œ∏0
Output: The solution Œ∏‚àó
r0 = AŒ∏0 ‚àí b
d0 = ‚àír0 , t = 0
while Unsatisfied convergence condition do
r‚ä§ r
Œ∑t = d‚ä§tAdt t
t
Œ∏t+1 = Œ∏t + Œ∑t dt
rt+1 = rt + Œ∑t Adt
r ‚ä§ rt+1
Œ≤t+1 = t+1
rt‚ä§ rt
dt+1 = ‚àírt+1 + Œ≤t+1 dt
t=t+1
end while

f (Œ∏) ‚âà f (Œ∏t+1 ) + ‚àáf (Œ∏t+1 )‚ä§ (Œ∏ ‚àí Œ∏t+1 )
1
+ (Œ∏ ‚àí Œ∏t+1 )‚ä§ ‚àá2 f (Œ∏t+1 )(Œ∏ ‚àí Œ∏t+1 ).
2

Then we can compute the gradient on both sides of the above
equation, and obtain

2) Quasi-Newton Methods: Gradient descent employs firstorder information, but its convergence rate is slow. Thus,
the natural idea is to use second-order information, e.g.,
Newton‚Äôs method [129]. The basic idea of Newton‚Äôs method
is to use both the first-order derivative (gradient) and secondorder derivative (Hessian matrix) to approximate the objective
function with a quadratic function, and then solve the
minimum optimization of the quadratic function. This process
is repeated until the updated variable converges.
The one-dimensional Newton‚Äôs iteration formula is shown
as
Œ∏t+1 = Œ∏t ‚àí

f ‚Ä≤ (Œ∏t )
,
f ‚Ä≤‚Ä≤ (Œ∏t )

(43)

where f is the object function. More general, the highdimensional Newton‚Äôs iteration formula is
Œ∏t+1 = Œ∏t ‚àí ‚àá2 f (Œ∏t )‚àí1 ‚àáf (Œ∏t ) ,

t ‚â• 0,

(44)

2

where ‚àá f is a Hessian matrix of f . More precisely, if the
learning rate (step size factor) is introduced, the iteration
formula is shown as
dt = ‚àí‚àá2 f (Œ∏t )‚àí1 ‚àáf (Œ∏t ),

Œ∏t+1 = Œ∏t + Œ∑t dt ,

(46)

(45)

where dt is the Newton‚Äôs direction, Œ∑t is the step size.
This method can be called damping Newton‚Äôs method [130].
Geometrically speaking, Newton‚Äôs method is to fit the local
surface of the current position with a quadratic surface, while
the gradient descent method is to fit the current local surface
with a plane [131].
Quasi-Newton Method Newton‚Äôs method is an iterative
algorithm that requires the computation of the inverse Hessian
matrix of the objective function at each step, which makes
the storage and computation very expensive. To overcome the
expensive storage and computation, an approximate algorithm
was considered which is called the quasi-Newton method. The
essential idea of the quasi-Newton method is to use a positive
definite matrix to approximate the inverse of the Hessian
matrix, thus simplifying the complexity of the operation. The
quasi-Newton method is one of the most effective methods
for solving non-linear optimization problems. Moreover, the

‚àáf (Œ∏) ‚âà ‚àáf (Œ∏t+1 ) + ‚àá2 f (Œ∏t+1 )(Œ∏ ‚àí Œ∏t+1 ).

(47)

Set Œ∏ = Œ∏t in (47), we have
‚àáf (Œ∏t ) ‚âà ‚àáf (Œ∏t+1 ) + ‚àá2 f (Œ∏t+1 )(Œ∏t ‚àí Œ∏t+1 ).

(48)

Use B to represent the approximate matrix of the Hessian
matrix. Set st = Œ∏t+1 ‚àí Œ∏t , and ut = ‚àáf (Œ∏t+1 ) ‚àí ‚àáf (Œ∏t ).
The matrix Bt+1 is satisfied that
ut = Bt+1 st .

(49)

This equation is called the quasi-Newton condition, or secant
equation.
The search direction of quasi-Newton method is
dt = ‚àíBt‚àí1 gt ,

(50)

where gt is the gradient of f , and the update of quasi-Newton
is
Œ∏t+1 = Œ∏t + Œ∑t dt .
(51)
The step size Œ∑t is chosen to satisfy the Wolfe conditions,
which is a set of inequalities for inexact line searches
minŒ∑t f (Œ∏t + Œ∑t dt ) [132]. Unlike Newton‚Äôs method, quasiNewton method uses Bt to approximate the true Hessian
matrix. In the following paragraphs, we will introduce some
particular quasi-Newton methods, in which Ht is used to
express the inverse of Bt , i.e., Ht = Bt‚àí1 .
DFP In the 1950s, a physical scientist, William C. Davidon
[133], proposed a new approach to solve nonlinear problems.
Then Fletcher and Powel [134] explained and improved this
method, which sparked a lot of research in the late 1960s and
early 1970s [6]. DFP is the first quasi-Newton method named
after the initials of their three names. The DFP correction
formula is one of the most creative inventions in the field
of non-linear optimization, shown as below:
(DF P )

Bt+1

= (I ‚àí

st u ‚ä§
ut u‚ä§
u t s‚ä§
t
)Bt (I ‚àí ‚ä§ t ) + ‚ä§ t .
‚ä§
u t st
u t st
u t st

(52)

The update formula of Ht+1 is
DF P
Ht+1
= Ht ‚àí

Ht u t u ‚ä§
st s‚ä§
t Ht
t
+
.
u‚ä§
u‚ä§
t Ht u t
t st

(53)

12

BFGS Broyden, Fletcher, Goldfarb and Shanno proposed
the BFGS method [135], [136], [137], [3], in which Bt+1 is
updated according to
(BF GS)

Bt+1

= Bt ‚àí

ut u‚ä§
Bt s t s ‚ä§
t Bt
t
+
.
s‚ä§
u‚ä§
t Bt s t
t st

(54)

The corresponding update of Ht+1 is
(BF GS)

Ht+1

= (I ‚àí

st u ‚ä§
u t s‚ä§
u t s‚ä§
t
t
t
)H
(I
‚àí
)
+
.
t
s‚ä§
s‚ä§
s‚ä§
t ut
t ut
t ut

(55)

The quasi-Newton algorithm still cannot solve large-scale
data optimization problem because the method generates a
sequence of matrices to approximate the Hessian matrix.
Storing these matrices needs to consume computer resources,
especially for high-dimensional problems. It is also impossible
to retain these matrices in the high-speed storage of computers,
restricting its use to even small and midsize problems [138].
L-BFGS Limited memory quasi-Newton methods, named
L-BFGS [138], [139] is an improvement based on the quasiNewton method, which is feasible in dealing with the highdimensional situation. The method stores just a few ndimensional vectors, instead of retaining and computing fully
dense n √ó n approximations of the Hessian [140]. The
basic idea of L-BFGS is to store the vector sequence in
the calculation of approximation Ht+1 , instead of storing
complete matrix Ht . L-BFGS makes further consolidation for
the update formula of Ht+1 ,
st u ‚ä§
u t s‚ä§
st s‚ä§
t
t
t
)H
(I
‚àí
)
+
t
u‚ä§
u‚ä§
u‚ä§
t st
t st
t st
= Vt‚ä§ Ht Vt + œÅst s‚ä§
t ,

Ht+1 = (I ‚àí
where

Vt = I ‚àí œÅut s‚ä§
t ,

œÅt =

1
.
s‚ä§
t ut

(56)
(57)

The above equation means that the inverse Hessian approximation Ht+1 can be obtained using the sequence pair
{sl , ul }tl=t‚àíp+1 . Ht+1 can be computed if we know pairs
{sl , yl }tl=t‚àíp+1 . In other words, instead of storing and
calculating the complete matrix Ht+1 , L-BFGS only computes
the latest p pairs of {sl , yl }. According to the equation, a
recursive procedure can be reached. When the latest p steps
are retained, the calculation of Ht+1 can be expressed as [139]

Algorithm 3 Two-Loop Recursion for Ht gt [93]
Input: ‚àáft , ut , st
Output: Ht+1 gt+1
gt = ‚àáft
s‚ä§ u
Ht0 = kut t kt2 I
for l = t ‚àí 1 to t ‚àí p do
Œ∑l = œÅl s‚ä§
l gl+1
gl = gl+1 ‚àí Œ∑l ul
end for
rt‚àíp‚àí1 = Ht0 gt‚àíp
for l = t ‚àí p to t ‚àí 1 do
Œ≤l = œÅl u ‚ä§
l œÅl‚àí1
œÅl = œÅl‚àí1 + sl (Œ∑l ‚àí Œ≤l )
end for
Ht+1 gt+1 = œÅ
Algorithm 4 Limited-BFGS [139]
Input:
Œ∏0 ‚àà R n , «´ > 0
Output:
the solution Œ∏‚àó
t=0
g0 = ‚àáf0
u0 = 1
s0 = 1
while k gt k< «´ do
s‚ä§ u
Choose Ht0 , for example Ht0 = kut t kt2 I
gt = ‚àáft
dt = ‚àíHt gt from Algorithm L-BFGS two-loop
recursion for Ht gt
Search a step size Œ∑t through Wolfe rule
Œ∏t+1 = Œ∏t + Œ∑t dt
if k > p then
Discard the vector pair {st‚àíp , yt‚àíp } from storage
end if
Compute and save
st = Œ∏t+1 ‚àí Œ∏t , ut = gt+1 ‚àí gt
t= t+1
end while

overlapping mini-batches for consecutive samples for quasiNewton update. It means that the calculation of ut becomes
ut = ‚àáSt+1 f (Œ∏t+1 )‚àí ‚àáSt f (Œ∏t ), where St is a small subset of
samples, meanwhile St+1 and St are not independent, perhaps
‚ä§
‚ä§
Ht+1 = (Vt‚ä§ Vt‚àí1
¬∑ ¬∑ ¬∑ Vt‚àíp+1
)Ht0 (Vt‚àíp+1 Vt‚àíp+2 ¬∑ ¬∑ ¬∑ Vt ) containing a relatively large overlap. Some numerical results in
[141] have shown that the modification in L-BFGS is effective
‚ä§
+ œÅt‚àíp+1 (Vt‚ä§ Vt‚àí1
¬∑ ¬∑ ¬∑ Vt‚àíp+2 )st‚àíp+1 s‚ä§
t‚àíp+1 (Vt‚àíp+2 ¬∑ ¬∑ ¬∑ Vt )
in practice.
‚ä§
‚ä§
¬∑ Vt‚àíp+3
)st‚àíp+2 s‚ä§
+ œÅt‚àíp+2 (Vt‚ä§ Vt‚àí1
t‚àíp+2 (Vt‚àíp+3 ¬∑ ¬∑ ¬∑ Vt )
3) Stochastic Quasi-Newton Method: In many large-scale
+ ¬∑¬∑¬∑
machine learning models, it is necessary to use a stochastic
approximation algorithm with each step of update based on a
+ œÅt s t s ‚ä§
t .
(58) relatively small training subset [125]. Stochastic algorithms
often obtain the best generalization performances in largeThe update direction dt = Ht gt can be calculated, where gt is scale learning systems [142]. The quasi-Newton method only
the gradient of the objective function f . The detailed algorithm uses the first-order gradient information to approximate the
is shown in Algorithms 3 and 4.
Hessian matrix. It is a natural idea to combine the quasiFor more information about BFGS and L-BFGS algorithms, Newton method with the stochastic method, so that it can
one can refer to [93], [138]. Recently, the batch L-BFGS perform on large-scale problems. Online-BFGS and onlineon machine learning was proposed [141], which uses the LBFGS are two variants of BFGS [124].

13

Consider the minimization of a convex stochastic function,
minŒ∏‚ààR F (Œ∏) = E[f (Œ∏, Œæ)],

(59)

where Œæ is a random seed. We assume that Œæ represents a
sample (or a set of samples) consisting of an input-output pair
(x, y). In machine learning x typically represents an input and
y is the target output. f usually has the following form:
f (Œ∏; Œæ) = f (Œ∏; xi , yi ) = l(h(w; xi ); yi ),

(60)

where h is a prediction model parameterized by Œ∏, and l is
a loss function. We define fi (Œ∏) = f (Œ∏; xi , yi ), and use the
empirical loss to define the objective,
F (Œ∏) =

N
1 X
fi (Œ∏).
N i=1

(61)

Typically, if a large amount of training data is used to train
the machine learning models, a better choice is using minibatch stochastic gradient,
1X
‚àáfi (Œ∏t ),
(62)
‚àáFSt (Œ∏t ) =
c
i‚ààSt

where subset St ‚äÇ {1, 2, 3 ¬∑ ¬∑ ¬∑ N } is randomly selected. c is
the cardinality of St and c ‚â™ N . Let StH ‚äÇ {1, 2, 3, ¬∑ ¬∑ ¬∑ , N }
be a randomly chosen subset of the training samples and the
stochastic Hessian estimate can be
1 X 2
‚àá fi (Œ∏t ),
(63)
‚àá2 FSt (Œ∏t ) =
ch
H
i‚ààSt

where ch is the cardinality of StH . With given stochastic
gradient, a direct approach to develop stochastic quasi-Newton
method is to transform deterministic gradients into stochastic
gradients throughout the iterations, such as online-BFGS and
online-LBFGS [124], which are two stochastic adaptations
of the BFGS algorithms. Specifically, following the BFGS
described in the previous section, st , ut are modified as
st := Œ∏t+1 ‚àí Œ∏t

and ut := ‚àáFSt (Œ∏t+1 ) ‚àí ‚àáFSt (Œ∏t ). (64)

One disadvantage of this method is that each iteration
requires two gradient estimates. Besides this, a more worrying
fact is that updating the inverse Hessian approximations in
each step may not be reasonable [143]. Then the stochastic
quasi-Newton (SQN) method was proposed, which is to use
sub-sampled Hessian-vector products to update Ht by the
LBFGS according to [125]. Meanwhile, the authors proposed
an effective approach that decouples the stochastic gradient
and curvature estimate calculations to obtain a stable Hessian
approximation. In particular, since
‚àáF (Œ∏t+1 ) ‚àí ‚àáF (Œ∏t ) ‚âà ‚àá2 F (Œ∏t )(Œ∏t+1 ‚àí Œ∏t ),
ut := ‚àá FStH (Œ∏t )st .

Input:
Œ∏0 , V , m, Œ∑t
Output:
The solution Œ∏‚àó
for t=1, 2, 3, 4,....., do
s‚Ä≤t = Ht gt using the two-loop recursion.
st = ‚àíŒ∑t s‚Ä≤t
Œ∏t+1 = Œ∏t + s‚Ä≤t
if update pairs then
Compute st and ut
Add a new displacement pair {st , ut } to V
if |V | > m then
Remove the eldest pair from V
end if
end if
end for

In the above algorithm, V = {st , ut } is a collection
of m displacement pairs, and gt is the current stochastic
gradient ‚àáFSt (Œ∏t ). Meanwhile, the matrix-vector product
Ht gt can be computed by a two-loop recursion as described
in the previous section. Recently, more and more work
has achieved very good results in stochastic quasi-Newton.
Specifically, a regularized stochastic BFGS method was
proposed, which makes a corresponding analysis of the
convergence of this optimization method [144]. Further, an
online L-BFGS was presented in [145]. A linearly convergent
method was proposed [126], which combines the L-BFGS
method in [125] with the variance reduction technique.
Besides these, a variance reduced block L-BFGS method was
proposed, which works by employing the actions of a subsampled Hessian on a set of random vectors [146].
To sum up, we have discussed the techniques of using
stochastic methods in second-order optimization. The stochastic quasi-Newton method is a combination of the stochastic
method and the quasi-Newton method, which makes the quasiNewton method extend to large datasets. We have introduced
the related work of the stochastic quasi-Newton method in
recent years, which reflects the potential of the stochastic
quasi-Newton method in machine learning applications.
4) Hessian-Free Optimization Method: The main idea of
Hessian-free (HF) method is similar to Newton‚Äôs method,
which employs second-order gradient information. The difference is that the HF method is not necessary to directly
calculate the Hessian matrix H. It estimates the product Hv
by some techniques, and thus is called ‚ÄúHessian free‚Äù.
Consider a local quadratic approximation QŒ∏ (dt ) of the
object F around parameter Œ∏,

(65)

1
Bt dt , (67)
F (Œ∏t +dt ) ‚âà QŒ∏ (dt ) = F (Œ∏t )+‚àáF (Œ∏t )‚ä§ dt + d‚ä§
2 t

(66)

where dt is the search direction. The HF method applies the
conjugate gradient method to compute an approximate solution
dt of the linear system,

ut can be rewritten as
2

Algorithm 5 SQN Framework [143]

Based on these techniques, an SQN Framework was proposed,
and the detailed procedure is shown in Algorithm 5.

Bt dt = ‚àí‚àáF (Œ∏t ),

(68)

14

where Bt = H(Œ∏t ) is the Hessian matrix, but in practice Bt
is often defined as Bt = H(Œ∏t ) + ŒªI, Œª ‚â• 0 [7]. The new
update is then given by
Œ∏t+1 = Œ∏t + Œ∑t dt ,

(69)

where Œ∑t is the step size that ensures sufficient decrease in
the objective function, usually obtained by a linear search.
According to [7], the basic framework of HF optimization is
shown in Algorithm 6.
Algorithm 6 Hessian-Free Optimization Method [7]
Input: Œ∏0 , ‚àáf (Œ∏0 ), Œª
Output: The solution Œ∏‚àó
t=0
repeat
gt = ‚àáf (Œ∏t )
Compute Œª by some methods
Bt (v) ‚â° H(Œ∏t )v + Œªv
Compute the step size Œ∑t
dt = CG(Bt , ‚àígt )
Œ∏t+1 = Œ∏t + Œ∑t dt
t=t+1
until satisfy convergence condition
The advantage of using the conjugate gradient method
is that it can calculate the Hessian-vector product without
directly calculating the Hessian matrix. Because in the CGalgorithm, the Hessian matrix is paired with a vector, then
we can compute the Hessian-vector product to avoid the
calculation of the Hessian inverse matrix. There are many
ways to calculate Hessian-vector products, one of which is
calculated by a finite difference as [7]
‚àáf (Œ∏ + Œµv) ‚àí ‚àáf (Œ∏)
.
Œµ‚Üí+0
Œµ

Hv = lim

(70)

Sub-sampled Hessian-Free Method HF is a well-known
method, and has been studied for decades in the optimization
literatures, but has shortcomings when applied to deep neural
networks with large-scale data [7]. Therefore, a sub-sampled
technique is employed in HF, resulting in an efficient HF
method [7], [147]. The cost in each iteration can be reduced by
using only a small sample set S to calculate Hv. The objective
function has the following form:
min F (Œ∏) =

N
1 X
fi (Œ∏).
N i=1

(71)

In the tth iteration, the stochastic gradient estimation can be
written as
1 X
‚àáfi (Œ∏t ),
(72)
‚àáFSt (Œ∏t ) =
|St |
i‚ààSt

and the stochastic Hessian estimate is expressed as
‚àá2 FStH (Œ∏t ) =

1 X 2
‚àá fi (Œ∏t ).
|StH |
H
i‚ààSt

(73)

As described above, we can obtain the approximate solution of
direction dt by employing the CG method to solve the linear
system,
(74)
‚àá2 FStH (Œ∏t )dt = ‚àí‚àáFSt (Œ∏t ),
in which the stochastic gradient and stochastic Hessian matrix
are used. The basic framework of sub-sampled HF algorithm
is given in [147].
A natural question is how to determine the size of StH . On
one hand, StH can be chosen small enough so that the total cost
of CG iteration is not much greater than a gradient evaluation.
On the other hand, StH should be large enough to get useful
curvature information from Hessian-vector product. How to
balance the size of StH is a challenge being studied [147].
5) Natural Gradient: The natural gradient method can be
potentially applied to any objective function which measures
the performance of some statistical models [148]. It enjoys
richer theoretical properties when applied to objective functions based on the KL divergence between the model‚Äôs distribution and the target distribution, or certain approximation
surrogates of these [149].
The traditional gradient descent algorithm is based on the
Euclidean space. However, in many cases, the parameter
space is not Euclidean, and it may have a Riemannian metric
structure. In this case, the steepest direction of the objective
function cannot be given by the ordinary gradient and should
be given by the natural gradient [148].
We consider such a model distribution p(y|x, Œ∏), and œÄ(x, y)
is an empirical distribution. We need to fit the parameters
Œ∏ ‚àà RN . Assume that x is an observation vector, and y is
its associated label. It has the objective function,
F (Œ∏) = E(x,y)‚àºœÄ [‚àí log p(y|x, Œ∏)],

(75)

and we need to solve the optimization problem,
Œ∏‚àó = argminŒ∏ F (Œ∏).

(76)

According to [148], the natural gradient can be transformed
from a traditional gradient multiplied by a Fisher information
matrix, i.e.,
‚àáN F = G‚àí1 ‚àáF,
(77)
where F is the object function, ‚ñΩF is the traditional gradient,
‚ñΩN F is the natural gradient, and G is the Fisher information
matrix, with the following form:



‚àÇp(y|x; Œ∏) ‚àÇp(y|x; Œ∏) ‚ä§
G = Ex‚àºœÄ Ey‚àºp(y|x,Œ∏) (
.
)(
)
‚àÇŒ∏
‚àÇŒ∏
(78)
The update formula with the natural gradient is
Œ∏t = Œ∏t ‚àí Œ∑t ‚àáN F.

(79)

We cannot ignore that the application of the natural gradient is
very limited because of too much computation. It is expensive
to estimate the Fisher information matrix and calculate its
inverse matrix. To overcome this limitation, the truncated
Newton‚Äôs method was developed [7], in which the inverse
is calculated by an iterative procedure, thus avoiding the
direct calculation of the inverse of the Fisher information
matrix. In addition, the factorized natural gradient (FNG) [150]

15

and Kronecker-factored approximate curvature (K-FAC) [151]
methods were proposed to use the derivatives of probabilistic
models to calculate the approximate natural gradient update.
6) Trust Region Method: The update process of most
methods introduced above can be described as Œ∏t + Œ∑t dt . The
displacement of the point in the direction of dt can be written
as st . The typical trust region method (TRM) can be used for
unconstrained nonlinear optimization problems [140], [152],
[153], in which the displacement st is directly determined
without the search direction dt .
For the problem min fŒ∏ (x), the TRM [140] uses the secondorder Taylor expansion to approximate the objective function
fŒ∏ (x), denoted as qt (s). Each search is done within the range
of trust region with radius ‚ñ≥t . This problem can be described
as
Ô£±
Ô£≤ min q (s) = f (x ) + g ‚ä§ s + 1 s‚ä§ B s,
t
t
Œ∏ t
t
(80)
2
Ô£≥ s.t.
||s || ‚â§ ‚ñ≥ ,
t

t

where gt is the approximate gradient of the objective function
f (x) at the current iteration point xt , gt ‚âà ‚àáf (xt ), Bt is
a symmetric matrix, which is the approximation of Hessian
matrix ‚àá2 fŒ∏ (xt ), and ‚ñ≥t > 0 is the radius of the trust region.
If the L2 norm is used in the constraint function, it becomes
the Levenberg-Marquardt algorithm [154].
If st is the solution of the trust region subproblem (80), the
displacement st of each update is limited by the trust region
radius ‚ñ≥t . The core part of the TRM is the update of ‚ñ≥t .
In each update process, the similarity of the quadratic model
q(st ) and the objective function fŒ∏ (x) is measured, and ‚ñ≥t is
updated dynamically. The actual amount of descent in the tth
iteration is [140]
‚ñ≥ft = ft ‚àí f (xt + st ).

(81)

The predicted drop in the tth iteration is
‚ñ≥qt = ft ‚àí q(st ).

(82)

The ratio rt is defined to measure the approximate degree of
both,
‚ñ≥ft
.
(83)
rt =
‚ñ≥qt

It indicates that the model is more realistic than expected when
rt is close to 1, and then we should consider expanding ‚ñ≥t .
At the same time, it indicates that the model predicts a large
drop and the actual drop is small when rt is close to 0, and
then we should reduce ‚ñ≥t . Moreover, if rt is between 0 and
1, we can leave ‚ñ≥t unchanged. The thresholds 0 and 1 are
generally set as the left and right boundaries of rt [140].
7) Summary: We summarize the mentioned high-order
optimization methods in terms of properties, advantages and
disadvantages in Table II.
C. Derivative-Free Optimization
For some optimization problems in practical applications,
the derivative of the objective function may not exist or is not
easy to calculate. The solution of finding the optimal point,
in this case, is called derivative-free optimization, which is a

discipline of mathematical optimization [155], [156], [157]. It
can find the optimal solution without the gradient information.
There are mainly two types of ideas for derivativefree optimization. One is to use heuristic algorithms. It
is characterized by empirical rules and chooses methods
that have already worked well, rather than derives solutions
systematically. There are many types of heuristic optimization
methods, including classical simulated annealing arithmetic,
genetic algorithms, ant colony algorithms, and particle swarm
optimization [158], [159], [160]. These heuristic methods usually yield approximate global optimal values, and theoretical
support is weak. We do not focus on such techniques in this
section. The other is to fit an appropriate function according
to the samples of the objective function. This type of method
usually attaches some constraints to the search space to derive
the samples. Coordinate descent method is a typical derivativefree algorithm [161], and it can be extended and applied to
optimization algorithms for machine learning problems easily.
In this section, we mainly introduce the coordinate descent
method.
The coordinate descent method is a derivative-free optimization algorithm for multi-variable functions. Its idea is
that a one-dimensional search can be performed sequentially
along each axis direction to obtain updated values for each
dimension. This method is suitable for some problems in
which the loss function is non-differentiable.
The vanilla approach is to select a set of bases e1 , e2 , ..., eD
in the linear space as the search directions and minimizes the
value of the objective function in each direction. For the target
function L(Œò), when Œòt is already obtained, the jth dimension
of Œòt+1 is solved by [155]
t+1
t
t
Œ∏jt+1 = arg minŒ∏j ‚ààR L(Œ∏1t+1 , ..., Œ∏j‚àí1
, Œ∏j , Œ∏j+1
, ..., Œ∏D
). (84)

Thus, L(Œòt+1 ) ‚â§ L(Œòt ) ‚â§ ... ‚â§ L(Œò0 ) is guaranteed. The
convergence of this method is similar to the gradient descent
method. The order of update can be an arbitrary arrangement
from e1 to eD in each iteration. The descent direction can be
generalized from the coordinate axis to the coordinate block
[162].
The main difference between the coordinate descent and
the gradient descent is that each update direction in the
gradient descent method is determined by the gradient of the
current position, which may not be parallel to any coordinate
axis. In the coordinate descent method, the optimization
direction is fixed from beginning to end. It does not need
to calculate the gradient of the objective function. In each
iteration, the update is only executed along the direction of
one axis, and thus the calculation of the coordinate descent
method is simple even for some complicated problems. For
indivisible functions, the algorithm may not be able to find
the optimal solution in a small number of iteration steps. An
appropriate coordinate system can be used to accelerate the
convergence. For example, the adaptive coordinate descent
method takes principal component analysis to obtain a new
coordinate system with as little correlation as possible between
the coordinates [163]. The coordinate descent method still
has limitations when performing on the non-smooth objective
function, which may fall into a non-stationary point.

16

TABLE II: Summary of High-Order Optimization Methods
Method

Properties

Advantages

Disadvantages

Conjugate Gradient [127]

It is an optimization method between
the first-order and second-order gradient methods. It constructs a set of
conjugated directions using the gradient
of known points, and searches along the
conjugated direction to find the minimum points of the objective function.

CG method only calculates the first order gradient but has faster convergence
than the steepest descent method.

Compared with the first-order gradient
method, the calculation of the conjugate
gradient is more complex.

Newton‚Äôs
Method [129]

Newton‚Äôs method calculates the inverse
matrix of the Hessian matrix to obtain
faster convergence than the first-order
gradient descent method.

Newton‚Äôs method uses second-order
gradient information which has faster
convergence than the first-order gradient method. Newton‚Äôs method has
quadratic convergence under certain
conditions.

It needs long computing time and large
storage space to calculate and store the
inverse matrix of the Hessian matrix at
each iteration.

Quasi-Newton
Method [93]

Quasi-Newton method uses an approximate matrix to approximate the the
Hessian matrix or its inverse matrix.
Popular quasi-Newton methods include
DFP, BFGS and LBFGS.

Quasi-Newton method does not need
to calculate the inverse matrix of the
Hessian matrix, which reduces the computing time. In general cases, quasiNewton method can achieve superlinear
convergence.

Quasi-Newton method needs a large
storage space, which is not suitable for
handling the optimization of large-scale
problems.

Sochastic QuasiNewton Method
[143].

Stochastic quasi-Newton method employs techniques of stochastic optimization. Representative methods are
online-LBFGS [124] and SQN [125].

Stochastic quasi-Newton method can
deal with large-scale machine learning
problems.

Compared with the stochastic gradient
method, the calculation of stochastic
quasi-Newton method is more complex.

Hessian
Free
Method [7]

HF method
performs a suboptimization using the conjugate
gradient, which avoids the expensive
computation of inverse Hessian matrix.

HF method can employ the secondorder gradient information but does
not need to directly calculate Hessian
matrices. Thus, it is suitable for high
dimensional optimization.

The cost of computation for the matrixvector product in HF method increases
linearly with the increase of training
data. It does not work well for largescale problems.

Sub-sampled
Hessian
Free
Method [147]

Sup-sampled Hessian free method uses
stochastic gradient and sub-sampled
Hessian-vector during the process of
updating.

The sub-sampled HF method can deal
with large-scale machine learning optimization problems.

Compared with the stochastic gradient
method, the calculation is more complex and needs more computing time
in each iteration.

Natural Gradient
[148]

The basic idea of the natural gradient
is to construct the gradient descent
algorithm in the predictive function
space rather than the parametric space.

The natural gradient uses the Riemann
structure of the parametric space to
adjust the update direction, which is
more suitable for finding the extremum
of the objective function.

In the natural gradient method, the
calculation of the Fisher information
matrix is complex.

D. Preconditioning in Optimization
Preconditioning is a very important technique in optimization methods. Reasonable preconditioning can reduce
the iteration number of optimization algorithms. For many
important iterative methods, the convergence depends largely
on the spectral properties of the coefficient matrix [164]. It
can be simply considered that the pretreatment is to transform
a difficult linear system AŒ∏ = b into an equivalent system
with the same solution but better spectral characteristics.
For example, if M is a nonsingular approximation of the
coefficient matrix A, the transformed system,
M ‚àí1 AŒ∏ = M ‚àí1 b,

(85)

will have the same solution as the system AŒ∏ = b. But (85)
may be easier to solve and the spectral properties of the
coefficient matrix M ‚àí1 A may be more favorable.
In most linear systems, e.g., AŒ∏ = b, the matrix A
is often complex and makes it hard to solve the system.
Therefore, some transformation is needed to simplify this
system. M is called the preconditioner. If the matrix after

using preconditioner is obviously structured, or sparse, it will
be beneficial to the calculation [165].
The conjugate gradient algorithm mentioned previously is
the most commonly used optimization method with preconditioning technology, which speeds up the convergence. The
algorithm is shown in Algorithm 7.
E. Public Toolkits for Optimization
Fundamental optimization methods are applied in machine
learning problems extensively. There are many integrated
powerful toolkits. We summarize the existing common optimization toolkits and present them in Table III.
IV. D EVELOPMENTS AND A PPLICATIONS FOR S ELECTED
M ACHINE L EARNING F IELDS
Optimization is one of the cores of machine learning. Many
optimization methods are further developed in the face of
different machine learning problems and specific application
environments. The machine learning fields selected in this

17

TABLE III: Available Toolkits for Optimization
Toolkit

Language

Description

CVX [166]

Matlab

CVX is a matlab-based modeling system for convex
optimization but cannot handle large-scale problems.
http://cvxr.com/cvx/download/

CVXPY [167]

Python

CVXPY is a python package developed by Stanford
University Convex Optimization Group for solving convex
optimization problems.
http://www.cvxpy.org/

CVXOPT [168]

Python

CVXOPT can be used for handling convex optimization. It
is developed by Martin Andersen, Joachim Dahl, and Lieven
Vandenberghe.
http://cvxopt.org/

APM [169]

Python

APM python is suitable for large-scale optimization and
can solve the problems of linear programming, quadratic
programming, integer programming, nonlinear optimization
and so on.
http://apmonitor.com/wiki/index.php/Main/PythonApp

SPAMS [123]

C++

SPAMS is an optimization toolbox for solving various sparse
estimation problems, which is developed and maintained by
Julien Mairal. Available interfaces include matlab, R, python
and C++.
http://spams-devel.gforge.inria.fr/

minConf

Matlab

minConf can be used for optimizing differentiable multivariate functions which subject to simple constraints on
parameters. It is a set of matlab functions, in which there
are many methods to choose from.
https://www.cs.ubc.ca/‚àº schmidtm/Software/minConf.html

tf.train.optimizer [170]

Python; C++; CUDA

The basic optimization class, which is usually not called
directly and its subclasses are often used. It includes
classic optimization algorithms such as gradient descent and
AdaGrad.
https://www.tensorflow.org/api guides/python/train

section mainly include deep neural networks, reinforcement
learning, variational inference and Markov chain Monte Carlo.
Algorithm 7 Preconditioned Conjugate Gradient Method [93]
Input: A, Œ∏0 , M , b
Output: The solution Œ∏‚àó
f0 = f (Œ∏0 )
g0 = ‚àáf (Œ∏0 ) = AŒ∏0 ‚àí b
y0 is the solution of M y = g0
d0 = ‚àíg0
t=t
while gt 6= 0 do
g‚ä§ y
Œ∑t = d‚ä§t Adtt
t
Œ∏t+1 = Œ∏t + Œ∑t dt
gt+1 = gt + Œ∑t Adt
yt+1 =solution of M y = gt
g‚ä§ yt+1
Œ≤t+1 = t+1
gt‚ä§ dt
dt+1 = ‚àíyt+1 + Œ≤t+1 dt
t=t+1
end while

A. Optimization in Deep Neural Networks
The deep neural network (DNN) is a hot topic in the
machine learning community in recent years. There are many
optimization methods for DNNs. In this section, we introduce
them from two aspects, i.e., first-order optimization methods
and high-order optimization methods.
1) First-Order Gradient Method in Deep Neural Networks:
The stochastic gradient optimization method and its adaptive
variants have been widely used in DNNs and have achieved
good performance. SGD introduces the learning rate decay
factor and AdaGrad accumulates all previous gradients so
that their learning rates are continuously decreased and
converge to zero. However, the learning rates of these
two methods make the update slow in the later stage of
optimization. AdaDelta, RMSProp, Adam and other methods
use the exponential averaging to provide effective updates
and simplify the calculation. These methods use exponential
moving average to alleviate the problems caused by the
rapid decay of the learning rate but limit the current

18

learning rate to only relying on a few gradients [34].
Reddi et al. used a simple convex optimization example to
demonstrate that the RMSProp and Adam algorithms could
not converge [34]. Almost all the algorithms that rely on
a fixed-size window of the past gradients will suffer from
this problem, including AdaDelta and Nesterov-accelerated
adaptive moment estimation (Nadam) [171].
It is better to rely on the long-term memory of past
gradients rather than the exponential moving average of
gradients to ensure convergence. A new version of Adam [34],
called AmsGrad, uses a simple correction method to ensure
the convergence of the model while preserving the original
computational performance and advantages. Compared with
the Adam method, the AmsGrad makes the following changes
to the first-order moment estimation and the second-order
moment estimation:
Ô£±
mt = Œ≤1t mt‚àí1 + (1 ‚àí Œ≤1t )gt ,
Ô£¥
Ô£¥
Ô£≤
q
(86)
Vt = Œ≤2 Vt‚àí1 + (1 ‚àí Œ≤2 )gt2 ,
Ô£¥
Ô£¥
Ô£≥
VÃÇt = max(VÃÇt‚àí1 , Vt ),

where Œ≤1t is a non-constant which decreases with time, and
Œ≤2 is a constant learning rate. The correction is operated in
the second-order moment Vt , making VÃÇt monotonous. VÃÇt is
substantially used in the iteration of the target function. The
AmsGrad method takes the long-term memory of past gradients based on the Adam method, guarantees the convergence
in the later stage, and works well in applications.
Further, adjusting parameters Œ≤1 , Œ≤2 at the same time helps
to converge to a certain extent. For example, Œ≤1 can decay
modestly as Œ≤1t = Œ≤t1 , Œ≤1t ‚â§ Œ≤1 , for all t ‚àà [T ]. Œ≤2 can be
set as Œ≤2t = 1 ‚àí 1t , for all t ‚àà [T ], as in AdamNC algorithm
[34].
Another idea of combining SGD and Adam was proposed
for solving the non-convergence problem of adaptive gradient
algorithm [38]. Adaptive algorithms, such as Adam, converge
fast and are suitable for processing sparse data. SGD with
momentum can converge to more accurate results. The
combination of SGD and Adam develops the advantages of
both methods. Specifically, it first trains with Adam to quickly
drop and then switches to SGD for precise optimization based
on the previous parameters at an appropriate switch point. The
strategy is named as switching from Adam to SGD (SWATS)
[38]. There are two core problems in SWATS. One is when
to switch from Adam to SGD, the other is how to adjust the
learning rate after switching the optimization algorithm. The
SWATS approach is described in detail below.
The movement dAdam of the parameter at iteration t of the
Adam is
Œ∑ Adam
dAdam
=
mt ,
(87)
t
Vt
where Œ∑ Adam is the learning rate of Adam [38]. The movement
dSGD of the parameter at iteration t of the SGD is
dSGD
= Œ∑ SGD gt ,
t

(88)

where Œ∑ SGD is the learning rate of SGD and gt is the gradient
of the current position [38].

The movement of SGD can be decomposed into the learning
rates along Adam‚Äôs direction and its orthogonal direction.
If SGD is going to finish the trajectory but Adam has not
finished due to the momentum after selecting the optimization
direction, walking along Adam‚Äôs direction is a good choice for
SWATS. At the same time, SWATS also adjusts its optimized
trajectory by moving in the orthogonal direction. Let
P rojAdam dSGD
= dAdam
,
t
t

(89)

and derive solution
Œ∑tSGD =

(dAdam
)T dAdam
t
t
,
Adam
(dt
)T gt

(90)

where P rojAdam means the projection in the direction of
Adam. To reduce noise, a moving average can be used to
correct the estimate of the learning rate,
SGD
ŒªSGD
= Œ≤2 ŒªSGD
,
t
t‚àí1 + (1 ‚àí Œ≤2 )Œ∑t

(91)

SGD
ŒªSGD
,
= t
ŒªÀút
1 ‚àí Œ≤2

(92)

where ŒªSGD
is the first moment of learning rate Œ∑ SGD , and
t
SGD
Àú
is the learning rate of SGD after converting [38]. For
Œªt
SGD
| < «´ is often
‚àí ŒªSGD
switch point, a simple guideline |ŒªÀút
t
used [38]. Although there is no rigorous mathematical proof
for selecting this conversion criterion, it performs well across
a variety of applications. For the mathematical proof of switch
point, further research can be conducted. Although the SWATS
is based on Adam, this switching method is also applicable to
other adaptive methods, such as AdaGrad and RMSProp. The
procedure is insensitive to hyper-parameters and can obtain an
optimal solution comparable to SGD, but with a faster training
speed in the case of deep networks.
Recently some researchers are trying to explain and improve
the adaptive methods [172], [173]. Their strategies can also be
combined with the above switching techniques to enhance the
performance of the algorithm.
General fully connected neural networks cannot process
sequential data such as text and audio. Recurrent neural
network (RNN) is a kind of neural networks that is more
suitable for processing sequential data. It was generally
considered that the use of first-order methods to optimize RNN
was not effective, because the SGD and its variant methods
were difficult to learn long-term dependencies in sequence
problems [99], [104], [174].
In recent years, a well-designed method of random parameter initialization scheme using only SGD with momentum
without curvature information has achieved good results in
training RNNs [99]. In [104], [175], some techniques for
improving the optimization in training RNNs are summarized
such as the momentum methods and NAG. The first-order
optimization methods have got development for training
RNNs, but they still face the problem of slow convergence in
deep RNNs. The high-order optimization methods employing
curvature information can accelerate the convergence near
the optimal value and is considered to be more effective in
optimizing DNNs.

19

2) High-Order Gradient Method in Deep Neural Networks:
We have described the first-order optimization method applied
in DNNs. As most DNNs use large-scale data, different
versions of stochastic gradient methods were developed and
have got excellent performance and properties. For making
full use of gradient information, the second-order method
is gradually applied to DNNs. In this section, we mainly
introduce the Hessian-free method in DNN.
Hessian-free (HF) method has been studied for a long time
in the field of optimization, but it is not directly suitable for
dealing with neural networks [7]. As the objective function
in DNN is not convex, the exact Hessian matrix may not be
positive definite. Therefore, some modifications need to be
made so that the HF method can be applied to neural networks
[176].
The Generalized Gauss-Newton Matrix One solution is to
use the generalized Gauss-Newton (GGN) matrix, which can
be seen as an approximation of a Hessian matrix [177]. The
GGN matrix is a provably positive semidefinite matrix, which
avoids the trouble of negative curvature. There are at least two
ways to derive the GGN matrix [176]. Both of them require
that f (Œ∏) can be expressed as a composition of two functions
written as f (Œ∏) = Q(F (Œ∏)) where f (Œ∏) is the object function
and Q is convex. The GGN matrix G takes the following form,
G = J ‚ä§ Q‚Ä≤‚Ä≤ J,

(93)

where J is the Jacobian of F .
Damping Methods Another modification to the HF method
is to use different damping methods. For example, Tikhonov
damping, one of the most famous damping methods, is
implemented by introducing a quadratic penalty term into the
quadratic model. A quadratic penalty term Œª2 d‚ä§ d is added to
the quadratic model,

Œª
1
Q(Œ∏) := Q(Œ∏) + d‚ä§ d = f (Œ∏t ) + ‚àáf (Œ∏t )‚ä§ d + d‚ä§ Bd, (94)
2
2
where B = H + ŒªI, and Œª > 0 determines the ‚Äústrength‚Äù
of the damping which is a scalar parameter. Thus, Bv is
formulated as Bv = (H + ŒªI)v = Hv + Œªv. However,
the basic Tikhonov damping method is not good in training
RNNs [178]. Due to the complex structure of RNNs, the local
quadratic approximation in certain directions in the parameter
space, even at very small distances, maybe highly imprecise.
The Tikhonov damping method can only compensate for
this by increasing punishment in all directions because
the method lacks a selective mechanism [176]. Therefore,
the structural damping was proposed, which makes the
performance substantially better and more robust.
The HF method with structural damping can effectively train
RNNs [176]. Now we briefly introduce the HF method with
structural damping. Let e(x, Œ∏) mean the vector-value function
of Œ∏ which can be interpreted as intermediate quantities during
the calculation of f (x, Œ∏), where f (x, Œ∏) is the object function.
For instance, e(x, Œ∏) might contain the activation function of

some layers of hidden units in neural networks (like RNNs).
A structural damping can be defined as
1 X
D(e(x, Œ∏), e(x, Œ∏t )),
(95)
R(Œ∏) =
|S|
(x,y)‚ààS

where D is a distance function or a loss function. It can prevent
a large change in e(x, Œ∏) by penalizing the distance between
e(x, Œ∏) and e(x, Œ∏t ). Then, the damped local objective can be
written as
Œª
QŒ∏ (d)‚Ä≤ = QŒ∏ (d) + ¬µR(d + Œ∏t ) + d‚ä§ d,
(96)
2
where ¬µ and Œª are two parameters to be dynamically adjusted.
d is the direction at the tth iteration. More details of the
structural damping can refer to [176].
Besides, there are many second-order optimization methods
employed in RNNs. For example, quasi-Newton based optimization and L-BFGS were proposed to train RNNs [179],
[180].
In order to make the damping method based on punishment
work better, the damping parameters can be adjusted continuously. A Levenberg-Marquardt style heuristic method was used
to adjust Œª directly [7]. The Levenberg-Marquardt heuristic is
described as follows:
1) If Œ≥ < 41 Œª then Œª ‚Üê 32 Œª,
2) If Œ≥ > 43 Œª then Œª ‚Üê 23 Œª,
where Œ≥ is a ‚Äúreduction rate‚Äù with the following form,
Œ≥=

f (Œ∏t‚àí1 + dt ) ‚àí f (Œ∏t‚àí1 )
.
Mt‚àí1 (dt )

(97)

Sub-sampling As sub-sampling Hessian can be used to
handle large-scale data, several variations of the sub-sampling
methods were proposed [8], [9], [10], which used either
stochastic gradients or exact gradients. These approaches use
Bt = ‚àá2St f (Œ∏t ) as a Hessian approximation, where St is a
subset of samples. We need to compute the Hessian-vector
product in some optimization methods. If we adopt the subsampling method, it also means that we can save a lot of
computation in each iteration, such as the method proposed in
[7].
Preconditioning Preconditioning can be used to simplify
the optimization problems. For example, preconditioning can
accelerate the CG method. It is found that diagonal matrices
are particularly effective and one can use the following
preconditioner [7]:
N
X
Œ±

‚àáfi (Œ∏) ‚äô ‚àáfi (Œ∏)) + ŒªI ,
M = diag(

(98)

i=1

where ‚äô denotes the element-wise product and the exponent
Œ± is chosen to be less than 1.
B. Optimization in Reinforcement Learning
Reinforcement learning (RL) is an important research
field of machine learning and is also one of the most
popular topics. Agents using deep reinforcement learning have
achieved great success in learning complex behavior skills and
solved challenging control tasks in high-dimensional primitive

20

perceptual state space [181], [182], [183]. It interacts with the
environment through the trial-and-error mechanism and learns
optimal strategies by maximizing cumulative rewards [39].
We describe several concepts of reinforcement learning as
follows:

The value function of the current state s can be calculated by
the value function of the next state s‚Ä≤ . The Bellman equations
of VœÄ (s) and QœÄ (s, a) describe the relation by
X
X
VœÄ (s) =
œÄ(a|s)
p(s‚Ä≤ , r|s, a)[r(s, a, s‚Ä≤ )
s‚Ä≤ ,r

a

1) Agent: making different actions according to the state
of the external environment, and adjusting the strategy
according to the reward of the external environment.
2) Environment: all things outside the agent that will be
affected by the action of the agent. It can change the
state and provide the reward to the agent.
3) State s: a description of the environment.
4) Action a: a description of the behavior of the agent.
5) Reward rt (st‚àí1 , at‚àí1 , st ): the timely return value at
time t.
6) Policy œÄ(a|s): a function that the agent decides the
action a according to the current state s.
7) State transition probability p(s‚Ä≤ |s, a): the probability
distribution that the environment will transfer to state s‚Ä≤
at the next moment, after the agent selecting an action
a based on the current state s.
8) p(s‚Ä≤ , r|s, a): the probability that the agent transforms to
state s‚Ä≤ and obtains the reward r, where the agent is in
state s and selecting the action a.
Many reinforcement learning problems can be described
by Markov decision process (MDP) < S, A, P, Œ≥, r > [39],
in which S is state space, A is action space, P is state
transition probability function, r is reward function and Œ≥
is the discount factor 0 < Œ≥ < 1. At each time, the agent
accepts a state and selects the action from an action set
according to the policy. The agent receives feedback from the
environment and then moves to the next state. The goal of
reinforcement learning is to find a strategy that allows us to get
the maximum Œ≥-discounted cumulative reward. The discounted
return is calculated by
Gt =

‚àû
X

Œ≥ k rt+k .

(99)

k=0

People do not necessarily know the MDP behind the problem. From this point, reinforcement learning is divided into
two categories. One is model-based reinforcement learning
which knows the MDP of the whole model (including the
transition probability P and reward function r), and the other
is the model-free method in which the MDP is unknown.
Systematic exploration is required in the latter methods.
The most commonly used value function is the state value
function,
VœÄ (s) = EœÄ [Gt |St = s],

(100)

which is the expected return of executing policy œÄ from state
s. The state-action value function is also essential which is the
expected return for selecting action a under state s and policy
œÄ,
QœÄ (s, a) = EœÄ [Gt |St = s, At = a].

(101)

‚Ä≤

(102)

œÄ(a‚Ä≤ |s‚Ä≤ )QœÄ (s‚Ä≤ , a‚Ä≤ )].

(103)

+ Œ≥VœÄ (s )],
X
QœÄ (s, a) =
p(s‚Ä≤ , r|s, a)[r(s, a, s‚Ä≤ )
s‚Ä≤ ,r

+Œ≥

X
a‚Ä≤

There are many reinforcement learning methods based
on value function. They are called value-based methods,
which play a significant role in RL. For example, Q-learning
[184] and SARSA [185] are two popular methods which use
temporal difference algorithms. The policy-based approach
is to optimize the policy œÄŒ∏ (a|s) directly and update the
parameters Œ∏ by gradient descent [186].
The actor-critic algorithm is a reinforcement learning
method combining policy gradient and temporal differential
learning, which learns both a policy and a state value function.
It estimates the parameters of two structures simultaneously.
1) The actor is a policy function, which is to learn a policy
œÄŒ∏ (a|s) to obtain the highest possible return.
2) The critic refers to the learned value function VœÜ (s),
which estimates the value function of the current policy,
that is to evaluate the quality of the actor.
In the actor-critic method, the critic solves a problem of
prediction, while the actor pays attention to the control [187].
There is more information of actor-critic method in [88], [187]
The summary of the value-based method, the policy-based
method, and the actor-critic method are as follows:
1) The value-based method: It needs to calculate value
function, and usually gets a definite policy.
2) The policy-based method: It optimizes the policy œÄ
without selecting an action according to value function.
3) The actor-critic method: It combines the above two
methods, and learns both the policy œÄ and the state value
function.
Deep reinforcement learning (DRL) combines reinforcement learning and deep learning, which defines problems and
optimizes goals in the framework of RL, and solves problems
such as state representation and strategy representation using
deep learning techniques.
DRL has achieved great success in many challenging control
tasks and uses DNNs to represent the control policy. For
neural network training, a simple stochastic gradient algorithm
or other first-order algorithms are usually chosen, but these
algorithms are not efficient in exploring the weight space,
which makes DRL methods often take several days to train
[60]. So, a distributed method was proposed to solve this
problem, in which parallel actor-learners have a stabilizing
effect during training [182]. It executes multiple agents to
interact with the environment simultaneously, which reduces
the training time. But this method ignores the sampling
efficiency. A scalable and sample-efficient natural gradient

21

algorithm was proposed, which uses a Kronecker-factored
approximation method to compute the natural policy gradient
update, and employ the update to the actor and the critic
(ACKTR) [60].
C. Optimization in Meta Learning
Meta learning [45], [46] is a popular research direction
in the field of machine learning. It solves the problem of
learning to learn. In the past cognition, the research of machine
learning is to obtain a large amount of data in a specific task
firstly and then use the data to train the model. In machine
learning, adequate training data is the guarantee of achieving
good performance. However, human beings can well process
new tasks with only a few training samples, which are much
more efficient than traditional machine learning methods. The
key point could be that the human brain has learned ‚Äúhow to
learn‚Äù and can make full use of past knowledge and experience
to guide the learning of new tasks. Therefore, how to make
machines have the ability to learn efficiently like human beings
has become a frontier issue in machine learning.
The goal of meta learning is to design a model that can
training well in the new tasks using as few samples as possible
without overfitting. The process of adapting to the new tasks
is essentially a learning process in the meta-testing, but only
with limited samples from new tasks. The application of meta
learning methods in supervised learning can solve the few-shot
learning problems [47].
As few-shot learning problems receive more and more
attention, meta learning is also developing rapidly. In general,
meta learning methods can be summarized into the following
three types [48]: metric-based methods [49], [50], [51],
[52], model-based methods [53], [54] and optimization-based
methods [55], [56], [47]. In this subsection, we focus on the
optimization-based meta learning methods. In meta learning,
there are usually some tasks with sufficient training samples
and a new task with only a few training samples. The main
idea can be described as follows: in the meta-train step,
sample a task œÑ from the total task set T , which contains
(DœÑtrain , DœÑtest ). For task œÑ , train and update the optimizer
parameter Œ∏ with the training samples DœÑtrain , update the
meta-optimizer parameter œÜ with the test samples DœÑtest .
The process of sampling tasks and updating parameters are
repeated multiple times. In the meta-test step, the trained metaoptimizer is used for learning a new task.
Since the purpose of meta learning is to achieve fast
learning, a key point is to make the gradient descent
more accurately in the optimization. In some meta learning
methods, the optimization process itself can be regarded as a
learning problem to learn the prediction gradient rather than a
determined gradient descent algorithm [188]. Neural networks
with original gradient as input and prediction gradient as
output is often used as a meta-optimizer [55]. The neural work
is trained using the training and test samples from other tasks
and used in the new task. The parameter update in the process
of training is as follows:
Œ∏t+1 = Œ∏t + N (g(Œ∏t ), œÜ),

(104)

where Œ∏t is the model parameter at the iteration t, and N is
the meta-optimizer with parameter œÜ that learns how to predict
the gradient. After training, the meta-optimizer N and its
parameter œÜ are updated according to the loss value in the test
samples. The experiments have confirmed that learning neural
optimizers is advantageous compared to the most advanced
adaptive stochastic gradient optimization methods used in deep
learning [55]. Due to the similarity between the gradient
update in backpropagation and the cell state update in the
long short-term memory (LSTM), LSTM is often used as the
meta-optimizer [55], [56].
A model-agnostic meta learning algorithm (MAML) is
another method for meta learning which was proposed to learn
the parameters of any model subjected to gradient descent
methods. It is applicable to different learning problems,
including classification, regression and reinforcement learning
[47]. The basic idea of the model-agnostic algorithm is to
begin multiple tasks at the same time, and then get the
synthetic gradient direction of different tasks, so as to learn a
common base model. The main process can be described as
follows: in the meta-train step, multiple tasks batch œÑi , which
contains (Ditrain , Ditest ), are extracted from the total task set
‚Ä≤
T . For all œÑi , train and update the parameter Œ∏i with the train
train
:
samples Di
‚Ä≤

Œ∏i = Œ∏ ‚àí Œ±

‚àÇJœÑi (Œ∏)
,
‚àÇ(Œ∏)

(105)

where Œ± is the learning rate of training process and JœÑi (Œ∏) is
the loss function in task i with training samples Ditrain . After
the training step, use the synthetic gradient direction of these
‚Ä≤
parameters Œ∏i on the test samples Ditest of the respective task
to update parameter Œ∏:
P
‚Ä≤
‚àÇ œÑi ‚àºp(T ) JœÑi (Œ∏i )
,
(106)
Œ∏ =Œ∏‚àíŒ≤
‚àÇ(Œ∏)
where Œ≤ is the meta learning rate of the test process and JœÑi (Œ∏)
is the loss function in task i with test samples Ditest . The metatrain step is repeated multiple times to optimize a good initial
parameter Œ∏. In the meta-test step, the trained parameter Œ∏ is
used as the initial parameter such that the model has a maximal
performance on the new task. MAML does not introduce
additional parameters for meta learning, nor does it require a
specific learner architecture. The development of the method is
of great significance to the optimization-based meta learning
methods. Recently, an expanded task-agnostic meta learning
algorithm is proposed to enhance the generalization of metalearner towards a variety of tasks, which achieves outstanding
performance on few-shot classification and reinforcement
learning tasks [189].
D. Optimization in Variational Inference
In the machine learning community, there are many attractive probabilistic models but with complex structures and
intractable posteriors, and thus some approximate methods
are used, such as variational inference and Markov chain
Monte Carlo (MCMC) sampling. Variational inference, a
common technique in machine learning, is widely used to

22

approximate the posterior density of the Bayesian model,
which transforms intricate inference problems into highdimensional optimization problems [190], [191]. Compared
with MCMC, the variational inference is faster and more
suitable for dealing with large-scale data. Variational inference
has been applied to large-scale machine learning tasks,
such as large-scale document analysis, computer vision and
computational neuroscience [192].
Variational inference often defines a flexible family of
distributions indexed by free parameters on latent variables
[190], and then finds the variational parameters by solving an
optimization problem.
Now let us review the principle of variational inference
[58]. Variational inference approximates the true posterior by
attempting to minimize the Kullback-Leibler (KL) divergence
between a potential factorized distribution and the true
posterior.
Let Z = {zi } represent the set of all latent variables and
parameters in the model and X = {xi } be a set of all
observed data. The joint likelihood of X and Z is p(Z, X) =
p(Z)p(X|Z). In Bayesian models, the posterior distribution
p(Z|X) should be computed to make further inference.
What we need to do is to approximate p(Z|X) with the
distribution q(Z) that belongs to a constrained family of distributions. The goal is to make the two distributions as similar
as possible. Variational inference chooses KL divergence to
measure the difference between the two distributions, that is
to minimize the KL divergence of q(Z) and p(Z|X). Here is
the formula for the KL divergence between q and p:


q(Z)
KL[q(Z)||p(Z|X)] = Eq log
p(Z|X)
= Eq [log q(Z)] ‚àí Eq [log p(Z|X)]
= Eq [log q(Z)] ‚àí Eq [log p(Z, X)] + log p(X)
= ‚àíELBO(q) + const,
(107)

where log p(X) is replaced by a constant because we are
only interested in q. With the above formula, we can know
KL divergence is difficult to optimize because it requires
knowing the distribution that we are trying to approximate. An
alternative method is to maximize the evidence lower bound
(ELBO), a lower bound on the logarithm of the marginal
probability of the observations. We can obtain ELBO‚Äôs
formula as
ELBO(q) = E [log p(Z, X)] ‚àí E [log q(Z)] .

(108)

Variational inference can be treated as an optimization
problem with the goal of minimizing the evidence lower
bound. A direct method is to solve this optimization problem
using the coordinate ascent, which is called coordinate ascent
variational inference (CAVI). CAVI iteratively optimizes each
factor of the mean-field variational density, while holding the
others fixed [192].
Specifically, variational
q has the structure of the
Qdistribution
M
mean-field, i.e., q(Z) = i=1 qi (zi ). With this assumption, we
can bring the distribution q into the ELBO, by some derivation
according to [57], and obtain the following formula:
qi‚àó ‚àù exp{E‚àíi [log p(zi , Z‚àíi , X)]}.

(109)

Then the CAVI algorithm can be given below in Algorithm 8.
Algorithm 8 Coordinate Ascent Variational Inference [192]
Input: p(X, Z), XQ
Output:
q(Z) = M
i=1 qi (zi )
Initialize Variational factors qi (zi )
repeat
for i=1,2,3....,M do
qi‚àó ‚àù exp{E‚àíi [log p(zi , Z‚àíi , X)]}
end for
Compute ELBO(q):
ELBO(q) = E[log p(Z, X)] ‚àí E log q(Z)
until ELBO converges
In traditional coordinate ascension algorithms, the efficiency
of processing large data is very low, because each iteration
needs to compute all the data, which is very time-consuming.
Modern machine learning models often need to analyze and
process large-scale data, which is difficult and costly. Stochastic optimization enables machine learning to be extended
on massive data [193]. This reminds us of an attractive
technique to handle large data sets: stochastic optimization
[97], [192], [194]. By introducing stochastic optimization into
variational inference, the stochastic variational inference (SVI)
was proposed [58], in which the exponential family is taken
as a typical example.
Gaussian process (GP) is an important machine learning
method based on statistical learning and Bayesian theory. It
is suitable for complex regression problems such as high
dimensions, small samples, and nonlinearities. GP has the
advantages of strong generalization ability, flexible nonparametric inference, and strong interpretability. However,
the complexity and storage requirements of accurate solution
for GP are high, which hinders the development of GP
under large-scale data. The stochastic variational inference
method introduced in this section can popularize variational
inference on large-scale datasets, but it can only be applied to
probabilistic models with factorized structures. For GPs whose
observations are correlated with each other, the stochastic
variational inference can be adapted by introducing the
global inducing variables as variational variables [195], [196].
Specifically, the observations are assumed to be conditionally
independent given the inducing variables and the variational
distribution for the inducing variables is assumed to have an
explicit form. Thus, the resulting GP model can be factorized
in a necessary manner, enabling the stochastic variational
inference. This method can also be easily extended to models
with non-Gaussian likelihood or latent variable models based
on GPs.
E. Optimization in Markov Chain Monte Carlo
Markov chain Monte Carlo (MCMC) is a class of sampling
algorithms to simulate complex distributions that are difficult
to sample directly. It is a practical tool for Bayesian posterior
inference. The traditional and common MCMC algorithms

23

include Gibbs sampling, slice sampling, Hamiltonian Monte
Carlo (HMC) [197], [198], Reimann manifold variants [199],
and so on. These sampling methods are limited by the
computational cost and are difficult to extend to large-scale
data.This section takes HMC as an example to introduce the
optimization in MCMC. The bottleneck of the HMC is that
the gradient calculation is costly on large data sets.
We first introduce the derivation of HMC. Consider the
random variable Œ∏, which can be sampled from the posterior
distribution,
p(Œ∏|D) ‚àù exp(‚àíU (Œ∏)),
(110)
where D is the set of observations, and U is the potential
energy function with the following formula:
X
U (Œ∏) = ‚àí log p(Œ∏|D) = ‚àí
log p(x|Œ∏) ‚àí log p(Œ∏). (111)
x‚ààD

In HMC [197], an independent auxiliary momentum variable
r is introduced from Hamiltonian dynamic. The Hamiltonian
function and the joint distribution of Œ∏ and r are described by
1
H(Œ∏, r) = U (Œ∏) + rT M ‚àí1 r = U (Œ∏) + K(r),
2

(112)

1
(113)
p(Œ∏, r) ‚àù exp(‚àíU (Œ∏) ‚àí rT M ‚àí1 r),
2
where M denotes the mass matrix, and K(r) is the kinetic
energy function. The process of HMC sampling is derived by
simulating the Hamiltonian dynamic system,

dŒ∏ = M ‚àí1 rdt,
(114)
dr = ‚àí‚àáU (Œ∏)dt.
Hamiltonian dynamic describes the continuous motion of a
particle. Hamiltonian equations are numerically approximated
by the discretized leapfrog integrator for practical simulating
[197]. The update equations are as follows [197]:
Ô£±
Ô£≤ ri (t + 2«´ ) = ri (t) ‚àí 2«´ dr(t),
Œ∏i (t + «´) = Œ∏i (t) + «´dŒ∏(t + 2«´ ),
(115)
Ô£≥
ri (t + «´) = ri (t + 2«´ ) ‚àí 2«´ dr(t + «´).
In the case of large datasets, the gradient of U (Œ∏) needs to
be calculated on the entire data set in each leapfrog iteration. In
order to improve the efficiency, the stochastic gradient method
was used to calculate ‚àáU (Œ∏) with a mini-batch DÃÉ sampled
uniformly from D, which reduces the cost of calculation [61].
However, the gradient calculated in a mini-batch instead of
the full dataset will cause noise. According to the central limit
theorem, this noisy gradient can be approximated as
‚àáUÃÉ (Œ∏) ‚âà ‚àáU (Œ∏) + N (0, V (Œ∏)),

(116)

where gradient noise obeys normal distribution whose covariance is V (Œ∏). If we replace ‚àáU (Œ∏) by ‚àáUÃÉ (Œ∏) directly, the
Hamiltonian dynamics will be changed as

dŒ∏ = M ‚àí1 rdt,
(117)
dr = ‚àí‚àáU (Œ∏)dt + N (0, 2B(Œ∏)dt),
where B(Œ∏) = 12 «´V (Œ∏) is the diffusion matrix [61].
Since the discretization of the dynamical system introduces
noise, the Metropolis-Hastings (MH) correction step should

be done after the leapfrog step. These MH steps require
expensive calculations overall data in each iteration. Beyond
that, there is an incorrect stationary distribution [200] in
the stochastic gradient variant of HMC. Thus, Hamiltonian
dynamic was further modified, which minimizes the effect of
the additional noise, achieves the invariant distribution and
eliminates MH steps [61]. Specifically, a friction term is added
to the dynamical process of momentum update:

dŒ∏ = M ‚àí1 rdt,
dr = ‚àí‚àáU (Œ∏)dt ‚àí BM ‚àí1 rdt + N (0, 2B(Œ∏)dt).
(118)
The introduced friction term is helpful for decreasing total
energy H(Œ∏, r) and weakening the effects of noise in the
momentum update phase. The dynamical system is also the
type of second-order Langevin dynamics with friction in
physics, which can explore efficiently and counteract the
effect of the noisy gradients [61] and thus no MH correction
is required. This second-order Langevin dynamic MCMC
method, called SGHMC, is used to deal with sampling
problems on large data sets [61], [201].
Moreover, HMC is highly sensitive to hyper-parameters,
such as the path length (step number) L and the step size
«´. If the hyper-parameters are not set properly, the efficiency
of the HMC will drop dramatically. There are some methods
to optimize these two hyper-parameters instead of manually
setting them.
1) Path Length L: The value of path length L has a great
influence on the performance of HMC. If L is too small,
the distance between the resulting sample points will be very
close; if L is too large, the resulting sample points will loop
back, resulting in wasted computation. In general, manually
setting L cannot maximize the sampling efficiency of the
HMC.
Matthew et al. [202] proposed an extension of the HMC
method called the No-U-Turn sampler (NUTS), which uses a
recursive algorithm to generate a set of possible independent
samples efficiently, and stops the simulation by discriminating
the backtracking automatically. There is no need to set the
step parameter L manually. In models with multiple discrete
variables, the ability of NUTS to select the track length
automatically allows it to generate more valid samples and
perform more efficiently than the original HMC.
2) Adaptive Step Size «´: The performance of HMC is highly
sensitive to the step size «´ in leapfrog integrator. If «´ is too
small, the update will slow, and the calculation cost will be
high; if «´ is too large, the rejection rate will be high, resulting
in useless updates.
To set «´ reasonably and adaptively, a vanishing adaptation
of the dual averaging algorithm can be used in HMC [203],
[204]. Specifically, a statistic Ht = Œ¥ ‚àí Œ±t is adopted
in dual averaging method, where Œ¥ is the desired average
acceptance probability, and Œ±t is the current MetropolisHasting acceptance probability for iteration t. The statistic
Ht ‚Äôs expectation h(«´) is defined as
h(«´) ‚â° Et [Ht |«´t ] ‚â° lim

T ‚Üí‚àû

1
E[Ht |«´t ],
T

(119)

24

where «´t is the step size for iteration t in the leapfrog
integrator. To satisfy h(«´) ‚â° Et [Ht |«´t ] = 0, we can derive
the update formula of «´, i.e., «´t+1 = «´t ‚àí Œ∑t Ht . Tuning «´
by vanishing adaptation algorithm guarantees that the average
acceptance probability of Metropolis verges to a fixed value.
The hyper-parameters in the HMC include not only the step
size «´ and the length of iteration steps L, but also the mass
M , etc. Optimizing these hyper-parameters can help improve
sampling performance [199], [205], [206]. It is convenient and
efficient to tune the hyper-parameters automatically without
cumbersome adjustments based on data and variables in
MCMC. These adaptive tuning methods can be applied to
other MCMC algorithms to improve the performance of the
samplers.
In addition to second-order SGHMC, stochastic gradient
Langevin dynamics (SGLD) [207] is a first-order Langevin
dynamic technique combined with stochastic optimization.
Efficient variants of both SGLD and SGHMC are still active
[201], [208].
V. C HALLENGES AND O PEN P ROBLEMS
With the rise of practical demand and the increase of
the complexity of machine learning models, the optimization
methods in machine learning still face challenges. In this
part, we discuss open problems and challenges for some
optimization methods in machine learning, which may offer
suggestions or ideas for future research and promote the wider
application of optimization methods in machine learning.
A. Challenges in Deep Neural Networks
There are still many challenges while optimizing DNNs.
Here we mainly discuss two challenges with respect to data
and model, respectively. One is insufficient data in training,
and the other is a non-convex objective in DNNs.
1) Insufficient Data in Training Deep Neural Networks: In
general, deep learning is based on big data sets and complex
models. It requires a large number of training samples to
achieve good training effects. But in some particular fields,
finding a sufficient amount of training data is difficult. If we
do not have enough data to estimate the parameters in the
neural networks, it may lead to high variance and overfitting.
There are some techniques in neural networks that can
be used to reduce the variance. Adding L2 regularization
to the objective is a natural method to reduce the model
complexity. Recently, a common method is dropout [62]. In
the training process, each neuron is allowed to stop working
with a probability of p, which can prevent the synergy between
certain neurons. M subnets can be sampled like bagging by
multiple puts and returns [209]. Each expected result at the
output layer is calculated as
o = EM [f (x; Œ∏, M )] =

M
X

p(Mi )f (x; Œ∏, Mi ),

(120)

i=1

where p(Mi ) is the probability of the ith subnet. Dropout can
prevent overfitting and improve the generalization ability of the
network, but its disadvantage is increasing the training time as

each training changes from the full network to a sub-network
[210].
Not only overfitting but also some training details will affect
the performance of the model due to the complexity of the
DNNs. The improper selection of the learning rate and the
number of iterations in the SGD will make the model unable
to converge, which makes the accuracy of model fluctuate
greatly. Besides, taking an inappropriate black box of neural
network construction may result in training not being able to
continue, so designing an appropriate neural network model is
particularly important. These impacts are even greater when
data are insufficient.
The technology of transfer learning [211] can be applied
to build networks in the scenario of insufficient data. Its
idea is that the models trained from other data sources can
be reused in similar target fields after certain modifications
and improvements, which dramatically alleviates the problems
caused by insufficient datasets. Moreover, the advantages
brought by transfer learning are not limited to reducing
the need for sufficient training data, but also can avoid
overfitting effectively and achieve better performance in
general. However, if target data is not as relevant to the
original training data, the transferred model does not bring
good performance.
Meta learning methods can be used for systematically
learning parameter initialization, which ensures that training
begins with a suitable initial model. However, it is necessary to
ensure the correlation between multiple tasks for meta-training
and tasks for meta-testing. Under the premise of models with
similar data sources for training, transfer learning and meta
learning can overcome the difficulties caused by insufficient
training data in new data sources, but these methods usually
introduce a large number of parameters or complex parameter
adjustment mechanisms, which need to be further improved
for specific problems. Therefore, using insufficient data for
training DNNs is still a challenge.
2) Non-convex Optimization in Deep Neural Network:
Convex optimization has good properties and a comprehensive
set of tools are open to solve the optimization problem.
However, many machine learning problems are formulated
as non-convex optimization problems. For example, almost
all the optimization problems in DNNs are non-convex.
Non-convex optimization is one of the difficulties in the
optimization problem. Unlike convex optimization, there may
be innumerable optimum solutions in its feasible domain in
non-convex problems. The complexity of the algorithm for
searching the global optimal value is NP-hard [109].
In recent years, non-convex optimization has gradually
attracted the attention of researches. The methods for solving
non-convex optimization problems can be roughly divided into
two types. One is to transform the non-convex optimization
into a convex optimization problem, and then use the convex
optimization method. The other is to use some special
optimization method for solving non-convex functions directly.
There is some work on summarizing the optimization methods
for solving non-convex functions from the perspective of
machine learning [212].
1) Relaxation method: Relax the problem to make it

25

become a convex optimization problem. There are many
relaxation techniques, for example, the branch-andbound method called Œ±BB convex relaxation [213],
[214], which uses a convex relaxation at each step to
compute the lower bound in the region. The convex
relaxation method has been used in many fields. In the
field of computer vision, a convex relaxation method
was proposed to calculate minimal partitions [215]. For
unsupervised and semi-supervised learning, the convex
relaxation method was used for solving semidefinite
programming [216].
2) Non-convex optimization methods: These methods include projection gradient descent [217], [218], alternating minimization [219], [220], [221], expectation
maximization algorithm [222], [223] and stochastic
optimization and its variants [37].
B. Difficulties in Sequential Models with Large-Scale Data
When dealing with large-scale time series, the usual
solutions are using stochastic optimization, processing data in
mini-batches, or utilizing distributed computing to improve
computational efficiency [224]. For a sequential model,
segmenting the sequences can affect the dependencies between
the data on the adjacent time indices. If sequence length is
not an integral multiple of the mini-batch size, the general
operation is to add some items sampled from the previous
data into the last subsequence. This operation will introduce
the wrong dependency in the training model. Therefore, the
analysis of the difference between the approximated solution
obtained and the exact solution is a direction worth exploring.
Particularly, in RNNs, the problem of gradient vanishing and
gradient explosion is also prone to occur. So far, it is generally
solved by specific interaction modes of LSTM and GRU [225]
or gradient clipping. Better appropriate solutions for dealing
with problems in RNNs are still worth investigating.
C. High-Order Methods for Stochastic Variational Inference
The high-order optimization method utilizes curvature
information and thus converges fast. Although computing
and storing the Hessian matrices are difficult, with the
development of research, the calculation of the Hessian matrix
has made great progress [8], [9], [226], and the second-order
optimization method has become more and more attractive.
Recently, stochastic methods have also been introduced into
the second-order method, which extends the second order
method to large-scale data [8], [10].
We have introduced some work on stochastic variational
inference. It introduces the stochastic method into variational
inference, which is an interesting and meaningful combination.
This makes variational inference be able to handle large-scale
data. A natural idea is whether we can incorporate secondorder optimization methods (or higher-order) into stochastic
variational inference, which is interesting and challenging.
D. Stochastic Optimization in Conjugate Gradient
Stochastic methods exhibit powerful capabilities when dealing with large-scale data, especially for first-order optimization

[227]. Then the relevant experts and scholars also introduced
this stochastic idea to the second-order optimization methods
[124], [125], [228] and achieved good results.
Conjugate gradient method is an elegant and attractive
algorithm, which has the advantages of both the firstorder and second-order optimization methods. The standard form of a conjugate gradient is not suitable for a
stochastic approximation. Through using the fast Hessiangradient product, the stochastic method is also introduced to
conjugate gradient, in which some numerical results show the
validity of the algorithm [227]. Another version of stochastic
conjugate gradient method employs the variance reduction
technique, and converges quickly with just a few iterations and
requires less storage space during the running process [229].
The stochastic version of conjugate gradient is a potential
optimization method and is still worth studying.
VI. C ONCLUSION
This paper introduces and summarizes the frequently
used optimization methods from the perspective of machine
learning, and studies their applications in various fields of
machine learning. Firstly, we describe the theoretical basis
of optimization methods from the first-order, high-order,
and derivative-free aspects, as well as the research progress
in recent years. Then we describe the applications of the
optimization methods in different machine learning scenarios
and the approaches to improve their performance. Finally,
we discuss some challenges and open problems in machine
learning optimization methods.
R EFERENCES
[1] H. Robbins and S. Monro, ‚ÄúA stochastic approximation method,‚Äù The
Annals of Mathematical Statistics, pp. 400‚Äì407, 1951.
[2] P. Jain, S. Kakade, R. Kidambi, P. Netrapalli, and A. Sidford,
‚ÄúParallelizing stochastic gradient descent for least squares regression:
mini-batching, averaging, and model misspecification,‚Äù Journal of
Machine Learning Research, vol. 18, 2018.
[3] D. F. Shanno, ‚ÄúConditioning of quasi-Newton methods for function
minimization,‚Äù Mathematics of Computation, vol. 24, pp. 647‚Äì656,
1970.
[4] J. Hu, B. Jiang, L. Lin, Z. Wen, and Y.-x. Yuan, ‚ÄúStructured quasinewton methods for optimization with orthogonality constraints,‚Äù SIAM
Journal on Scientific Computing, vol. 41, pp. 2239‚Äì2269, 2019.
[5] J. Pajarinen, H. L. Thai, R. Akrour, J. Peters, and G. Neumann,
‚ÄúCompatible natural gradient policy search,‚Äù Machine Learning, pp.
1‚Äì24, 2019.
[6] J. E. Dennis, Jr, and J. J. MoreÃÅ, ‚ÄúQuasi-Newton methods, motivation
and theory,‚Äù SIAM Review, vol. 19, pp. 46‚Äì89, 1977.
[7] J. Martens, ‚ÄúDeep learning via Hessian-free optimization,‚Äù in
International Conference on Machine Learning, 2010, pp. 735‚Äì742.
[8] F. Roosta-Khorasani and M. W. Mahoney, ‚ÄúSub-sampled Newton
methods II: local convergence rates,‚Äù arXiv preprint arXiv:1601.04738,
2016.
[9] P. Xu, J. Yang, F. Roosta-Khorasani, C. ReÃÅ, and M. W. Mahoney, ‚ÄúSubsampled Newton methods with non-uniform sampling,‚Äù in Advances in
Neural Information Processing Systems, 2016, pp. 3000‚Äì3008.
[10] R. Bollapragada, R. H. Byrd, and J. Nocedal, ‚ÄúExact and inexact
subsampled newton methods for optimization,‚Äù IMA Journal of
Numerical Analysis, vol. 1, pp. 1‚Äì34, 2018.
[11] L. M. Rios and N. V. Sahinidis, ‚ÄúDerivative-free optimization: a review
of algorithms and comparison of software implementations,‚Äù Journal
of Global Optimization, vol. 56, pp. 1247‚Äì1293, 2013.
[12] A. S. Berahas, R. H. Byrd, and J. Nocedal, ‚ÄúDerivative-free
optimization of noisy functions via quasi-newton methods,‚Äù SIAM
Journal on Optimization, vol. 29, pp. 965‚Äì993, 2019.

26

[13] Y. LeCun and L. Bottou, ‚ÄúGradient-based learning applied to document
recognition,‚Äù Proceedings of the IEEE, vol. 86, pp. 2278‚Äì2324, 1998.
[14] A. Krizhevsky, I. Sutskever, and G. E. Hinton, ‚ÄúImagenet classification
with deep convolutional neural networks,‚Äù in Advances in neural
information processing systems, 2012, pp. 1097‚Äì1105.
[15] P. Sermanet and D. Eigen, ‚ÄúOverfeat: Integrated recognition, localization and detection using convolutional networks,‚Äù in International
Conference on Learning Representations, 2014.
[16] A. Karpathy and G. Toderici, ‚ÄúLarge-scale video classification with
convolutional neural networks,‚Äù in IEEE Conference on Computer
Vision and Pattern Recognition, 2014, pp. 1725‚Äì1732.
[17] Y. Kim, ‚ÄúConvolutional neural networks for sentence classification,‚Äù
in Conference on Empirical Methods in Natural Language Processing,
2014, pp. 1746‚Äì1751.
[18] S. Ji, W. Xu, M. Yang, and K. Yu, ‚Äú3D convolutional neural networks
for human action recognition,‚Äù IEEE Transactions on Pattern Analysis
and Machine Intelligence, vol. 35, pp. 221‚Äì231, 2012.
[19] S. Lai, L. Xu, and K. Liu, ‚ÄúRecurrent convolutional neural networks
for text classification,‚Äù in Association for the Advancement of Artificial
Intelligence, 2015, pp. 2267‚Äì2273.
[20] K. Cho and B. Van MerrieÃànboer, ‚ÄúLearning phrase representations
using RNN encoder-decoder for statistical machine translation,‚Äù in
Conference on Empirical Methods in Natural Language Processing,
2014, pp. 1724‚Äì1734.
[21] P. Liu and X. Qiu, ‚ÄúRecurrent neural network for text classification with
multi-task learning,‚Äù in International Joint Conferences on Artificial
Intelligence, 2016, pp. 2873‚Äì2879.
[22] A. Graves and A.-r. Mohamed, ‚ÄúSpeech recognition with deep recurrent
neural networks,‚Äù in International Conference on Acoustics, Speech and
Signal processing, 2013, pp. 6645‚Äì6649.
[23] K. Gregor and I. Danihelka, ‚ÄúDraw: A recurrent neural network for
image generation,‚Äù arXiv preprint arXiv:1502.04623, 2015.
[24] A. v. d. Oord, N. Kalchbrenner, and K. Kavukcuoglu, ‚ÄúPixel recurrent
neural networks,‚Äù arXiv preprint arXiv:1601.06759, 2016.
[25] A. Ullah and J. Ahmad, ‚ÄúAction recognition in video sequences using
deep bi-directional LSTM with CNN features,‚Äù IEEE Access, vol. 6,
pp. 1155‚Äì1166, 2017.
[26] Y. Xia and J. Wang, ‚ÄúA bi-projection neural network for solving
constrained quadratic optimization problems,‚Äù IEEE Transactions on
Neural Networks and Learning Systems, vol. 27, no. 2, pp. 214‚Äì224,
2015.
[27] S. Zhang, Y. Xia, and J. Wang, ‚ÄúA complex-valued projection neural
network for constrained optimization of real functions in complex
variables,‚Äù IEEE Transactions on Neural Networks and Learning
Systems, vol. 26, no. 12, pp. 3227‚Äì3238, 2015.
[28] Y. Xia and J. Wang, ‚ÄúRobust regression estimation based on lowdimensional recurrent neural networks,‚Äù IEEE Transactions on Neural
Networks and Learning Systems, vol. 29, no. 12, pp. 5935‚Äì5946, 2018.
[29] Y. Xia, J. Wang, and W. Guo, ‚ÄúTwo projection neural networks
with reduced model complexity for nonlinear programming,‚Äù IEEE
Transactions on Neural Networks and Learning Systems, pp. 1‚Äì10,
2019.
[30] J. Duchi, E. Hazan, and Y. Singer, ‚ÄúAdaptive subgradient methods
for online learning and stochastic optimization,‚Äù Journal of Machine
Learning Research, vol. 12, pp. 2121‚Äì2159, 2011.
[31] M. D. Zeiler, ‚ÄúAdaDelta: An adaptive learning rate method,‚Äù arXiv
preprint arXiv:1212.5701, 2012.
[32] T. Tieleman and G. Hinton, ‚ÄúDivide the gradient by a running average
of its recent magnitude,‚Äù COURSERA: Neural Networks for Machine
Learning, pp. 26‚Äì31, 2012.
[33] D. P. Kingma and J. Ba, ‚ÄúAdam: A method for stochastic optimization,‚Äù
in International Conference on Learning Representations, 2014, pp. 1‚Äì
15.
[34] S. J. Reddi, S. Kale, and S. Kumar, ‚ÄúOn the convergence of Adam
and beyond,‚Äù in International Conference on Learning Representations,
2018, pp. 1‚Äì23.
[35] A. Radford, L. Metz, and S. Chintala, ‚ÄúUnsupervised representation
learning with deep convolutional generative adversarial networks,‚Äù
arXiv preprint arXiv:1511.06434, 2015.
[36] N. L. Roux, M. Schmidt, and F. R. Bach, ‚ÄúA stochastic gradient
method with an exponential convergence rate for finite training sets,‚Äù in
Advances in Neural Information Processing Systems, 2012, pp. 2663‚Äì
2671.
[37] R. Johnson and T. Zhang, ‚ÄúAccelerating stochastic gradient descent
using predictive variance reduction,‚Äù in Advances in Neural Information
Processing Systems, 2013, pp. 315‚Äì323.

[38] N. S. Keskar and R. Socher, ‚ÄúImproving generalization performance
by switching from Adam to SGD,‚Äù arXiv preprint arXiv:1712.07628,
2017.
[39] R. S. Sutton and A. G. Barto, Reinforcement Learning: An Introduction.
MIT press, 1998.
[40] J. Mattner, S. Lange, and M. Riedmiller, ‚ÄúLearn to swing up and
balance a real pole based on raw visual input data,‚Äù in International
Conference on Neural Information Processing, 2012, pp. 126‚Äì133.
[41] V. Mnih, K. Kavukcuoglu, D. Silver, A. Graves, I. Antonoglou,
D. Wierstra, and M. Riedmiller, ‚ÄúPlaying Atari with deep reinforcement
learning,‚Äù arXiv preprint arXiv:1312.5602, 2013.
[42] V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness,
M. G. Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland,
and G. Ostrovski, ‚ÄúHuman-level control through deep reinforcement
learning,‚Äù Nature, vol. 518, pp. 529‚Äì533, 2015.
[43] Y. Bengio, ‚ÄúLearning deep architectures for AI,‚Äù Foundations and
Trends in Machine Learning, vol. 2, pp. 1‚Äì127, 2009.
[44] S. S. Mousavi, M. Schukat, and E. Howley, ‚ÄúDeep reinforcement
learning: an overview,‚Äù in SAI Intelligent Systems Conference, 2016,
pp. 426‚Äì440.
[45] J. Schmidhuber, ‚ÄúEvolutionary principles in self-referential learning, or
on learning how to learn: the meta-meta-... hook,‚Äù Ph.D. dissertation,
Technische UniversitaÃàt MuÃànchen, MuÃànchen, Germany, 1987.
[46] T. Schaul and J. Schmidhuber, ‚ÄúMetalearning,‚Äù Scholarpedia, vol. 5,
pp. 46‚Äì50, 2010.
[47] C. Finn, P. Abbeel, and S. Levine, ‚ÄúModel-agnostic meta-learning
for fast adaptation of deep networks,‚Äù in International Conference on
Machine Learning, 2017, pp. 1126‚Äì1135.
[48] O.
Vinyals,
‚ÄúModel
vs
optimization
meta
learning,‚Äù
http://metalearning-symposium.ml/files/vinyals.pdf, 2017.
[49] J. Bromley, I. Guyon, Y. LeCun, E. SaÃàckinger, and R. Shah, ‚ÄúSignature
verification using a ‚Äùsiamese‚Äù time delay neural network,‚Äù in Advances
in Neural Information Processing Systems, 1994, pp. 737‚Äì744.
[50] G. Koch, R. Zemel, and R. Salakhutdinov, ‚ÄúSiamese neural networks
for one-shot image recognition,‚Äù in International Conference on
Machine Learning WorkShop, 2015, pp. 1‚Äì30.
[51] O. Vinyals, C. Blundell, T. Lillicrap, D. Wierstra et al., ‚ÄúMatching
networks for one shot learning,‚Äù in Advances in Neural Information
Processing Systems, 2016, pp. 3630‚Äì3638.
[52] J. Snell, K. Swersky, and R. Zemel, ‚ÄúPrototypical networks for fewshot learning,‚Äù in Advances in Neural Information Processing Systems,
2017, pp. 4077‚Äì4087.
[53] A. Santoro, S. Bartunov, M. Botvinick, D. Wierstra, and T. Lillicrap,
‚ÄúMeta-learning with memory-augmented neural networks,‚Äù in International Conference on Machine Learning, 2016, pp. 1842‚Äì1850.
[54] J. Weston, S. Chopra, and A. Bordes, ‚ÄúMemory networks,‚Äù in
International Conference on Learning Representations, 2015, pp. 1‚Äì
15.
[55] M. Andrychowicz, M. Denil, S. Gomez, M. W. Hoffman, D. Pfau,
T. Schaul, B. Shillingford, and N. De Freitas, ‚ÄúLearning to learn
by gradient descent by gradient descent,‚Äù in Advances in Neural
Information Processing Systems, 2016, pp. 3981‚Äì3989.
[56] S. Ravi and H. Larochelle, ‚ÄúOptimization as a model for few-shot
learning,‚Äù in International Conference on Learning Representations,
2016, pp. 1‚Äì11.
[57] C. M. Bishop, Pattern Recognition and Machine Learning. Springer,
2006.
[58] M. D. Hoffman, D. M. Blei, C. Wang, and J. Paisley, ‚ÄúStochastic
variational inference,‚Äù Journal of Machine Learning Research, vol. 14,
pp. 1303‚Äì1347, 2013.
[59] C. Ledig, L. Theis, F. HuszaÃÅr, J. Caballero, A. Cunningham, A. Acosta,
A. Aitken, A. Tejani, J. Totz, Z. Wang et al., ‚ÄúPhoto-realistic single
image super-resolution using a generative adversarial network,‚Äù in
Computer Vision and Pattern Recognition, 2017, pp. 4681‚Äì4690.
[60] Y. Wu, E. Mansimov, R. B. Grosse, S. Liao, and J. Ba, ‚ÄúScalable
trust-region method for deep reinforcement learning using Kroneckerfactored approximation,‚Äù in Advances in Neural Information Processing
Systems, 2017, pp. 5279‚Äì5288.
[61] T. Chen, E. Fox, and C. Guestrin, ‚ÄúStochastic gradient Hamiltonian
Monte Carlo,‚Äù in International Conference on Machine Learning, 2014,
pp. 1683‚Äì1691.
[62] N. Srivastava, G. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov, ‚ÄúDropout: a simple way to prevent neural networks from
overfitting,‚Äù Journal of Machine Learning Research, vol. 15, pp. 1929‚Äì
1958, 2014.

27

[63] W. Yin and H. SchuÃàtze, ‚ÄúMultichannel variable-size convolution for
sentence classification,‚Äù in Conference on Computational Language
Learning, 2015, pp. 204‚Äì214.
[64] J. Yang, K. Yu, Y. Gong, and T. S. Huang, ‚ÄúLinear spatial pyramid
matching using sparse coding for image classification,‚Äù in IEEE
Conference on Computer Vision and Pattern Recognition, 2009, pp.
1794‚Äì1801.
[65] Y. Bazi and F. Melgani, ‚ÄúGaussian process approach to remote sensing
image classification,‚Äù IEEE Transactions on Geoscience and Remote
Sensing, vol. 48, pp. 186‚Äì197, 2010.
[66] D. C. Ciresan, U. Meier, and J. Schmidhuber, ‚ÄúMulti-column deep
neural networks for image classification,‚Äù in IEEE Conference on
Computer Vision and Pattern Recognition, 2012, pp. 3642‚Äì3649.
[67] J. A. Hartigan and M. A. Wong, ‚ÄúAlgorithm AS 136: A k-means
clustering algorithm,‚Äù Journal of the Royal Statistical Society. Series
C (Applied Statistics), vol. 28, pp. 100‚Äì108, 1979.
[68] S. Guha, R. Rastogi, and K. Shim, ‚ÄúROCK: A robust clustering
algorithm for categorical attributes,‚Äù Information Systems, vol. 25, pp.
345‚Äì366, 2000.
[69] C. Ding, X. He, H. Zha, and H. D. Simon, ‚ÄúAdaptive dimension
reduction for clustering high dimensional data,‚Äù in IEEE International
Conference on Data Mining, 2002, pp. 147‚Äì154.
[70] M. Guillaumin and J. Verbeek, ‚ÄúMultimodal semi-supervised learning
for image classification,‚Äù in Computer Vision and Pattern Recognition,
2010, pp. 902‚Äì909.
[71] O. Chapelle and A. Zien, ‚ÄúSemi-supervised classification by low density separation.‚Äù in International Conference on Artificial Intelligence
and Statistics, 2005, pp. 57‚Äì64.
[72] Z.-H. Zhou and M. Li, ‚ÄúSemi-supervised regression with co-training.‚Äù
in International Joint Conferences on Artificial Intelligence, 2005, pp.
908‚Äì913.
[73] A. Demiriz and K. P. Bennett, ‚ÄúSemi-supervised clustering using
genetic algorithms,‚Äù Artificial Neural Networks in Engineering, vol. 1,
pp. 809‚Äì814, 1999.
[74] B. Kulis and S. Basu, ‚ÄúSemi-supervised graph clustering: a kernel
approach,‚Äù Machine Learning, vol. 74, pp. 1‚Äì22, 2009.
[75] D. Zhang and Z.-H. Zhou, ‚ÄúSemi-supervised dimensionality reduction,‚Äù
in SIAM International Conference on Data Mining, 2007, pp. 629‚Äì634.
[76] P. Chen and L. Jiao, ‚ÄúSemi-supervised double sparse graphs
based discriminant analysis for dimensionality reduction,‚Äù Pattern
Recognition, vol. 61, pp. 361‚Äì378, 2017.
[77] K. P. Bennett and A. Demiriz, ‚ÄúSemi-supervised support vector
machines,‚Äù in Advances in Neural Information processing systems,
1999, pp. 368‚Äì374.
[78] E. Cheung, Optimization Methods for Semi-Supervised Learning.
University of Waterloo, 2018.
[79] O. Chapelle, V. Sindhwani, and S. S. Keerthi, ‚ÄúOptimization techniques
for semi-supervised support vector machines,‚Äù Journal of Machine
Learning Research, vol. 9, pp. 203‚Äì233, 2008.
[80] ‚Äî‚Äî, ‚ÄúBranch and bound for semi-supervised support vector
machines,‚Äù in Advances in Neural Information Processing Systems,
2007, pp. 217‚Äì224.
[81] Y.-F. Li and I. W. Tsang, ‚ÄúConvex and scalable weakly labeled svms,‚Äù
Journal of Machine Learning Research, vol. 14, pp. 2151‚Äì2188, 2013.
[82] F. Murtagh, ‚ÄúA survey of recent advances in hierarchical clustering
algorithms,‚Äù The Computer Journal, vol. 26, pp. 354‚Äì359, 1983.
[83] V. Castro and J. Yang, ‚ÄúA fast and robust general purpose clustering
algorithm,‚Äù in Knowledge Discovery in Databases and Data Mining,
2000, pp. 208‚Äì218.
[84] G. H. Ball and D. J. Hall, ‚ÄúA clustering technique for summarizing
multivariate data,‚Äù Behavioral Science, vol. 12, pp. 153‚Äì155, 1967.
[85] S. Wold, K. Esbensen, and P. Geladi, ‚ÄúPrincipal component analysis,‚Äù
Chemometrics and Intelligent Laboratory Systems, vol. 2, pp. 37‚Äì52,
1987.
[86] I. Jolliffe, ‚ÄúPrincipal component analysis,‚Äù in International Encyclopedia of Statistical Science, 2011, pp. 1094‚Äì1096.
[87] M. E. Tipping and C. M. Bishop, ‚ÄúProbabilistic principal component
analysis,‚Äù Journal of the Royal Statistical Society: Series B (Statistical
Methodology), vol. 61, pp. 611‚Äì622, 1999.
[88] R. S. Sutton and A. G. Barto, Reinforcement Learning: An Introduction.
MIT Press, 2018.
[89] L. P. Kaelbling, M. L. Littman, and A. W. Moore, ‚ÄúReinforcement
learning: A survey,‚Äù Journal of Artificial Intelligence Research, vol. 4,
pp. 237‚Äì285, 1996.
[90] S. Ruder, ‚ÄúAn overview of gradient descent optimization algorithms,‚Äù
arXiv preprint arXiv:1609.04747, 2016.

[91] S. Boyd and L. Vandenberghe, Convex Optimization.
Cambridge
University Press, 2004.
[92] J. Alspector, R. Meir, B. Yuhas, A. Jayakumar, and D. Lippe, ‚ÄúA
parallel gradient descent method for learning in analog VLSI neural
networks,‚Äù in Advances in Neural Information Processing Systems,
1993, pp. 836‚Äì844.
[93] J. Nocedal and S. J. Wright, Numerical Optimization. Springer, 2006.
[94] A. S. Nemirovsky and D. B. Yudin, Problem Complexity and Method
Efficiency in Optimization. John Wiley & Sons, 1983.
[95] A. Nemirovski, A. Juditsky, G. Lan, and A. Shapiro, ‚ÄúRobust stochastic
approximation approach to stochastic programming,‚Äù SIAM Journal on
Optimization, vol. 19, pp. 1574‚Äì1609, 2009.
[96] A. Agarwal, M. J. Wainwright, P. L. Bartlett, and P. K. Ravikumar,
‚ÄúInformation-theoretic lower bounds on the oracle complexity of
convex optimization,‚Äù in Advances in Neural Information Processing
Systems, 2009, pp. 1‚Äì9.
[97] H. Robbins and S. Monro, ‚ÄúA stochastic approximation method,‚Äù The
Annals of Mathematical Statistics, pp. 400‚Äì407, 1951.
[98] C. Darken, J. Chang, and J. Moody, ‚ÄúLearning rate schedules for faster
stochastic gradient search,‚Äù in Neural Networks for Signal Processing,
1992, pp. 3‚Äì12.
[99] I. Sutskever, ‚ÄúTraining recurrent neural networks,‚Äù Ph.D. dissertation,
University of Toronto, Ontario, Canada, 2013.
[100] Z. Allen-Zhu, ‚ÄúNatasha 2: Faster non-convex optimization than SGD,‚Äù
in Advances in Neural Information Processing Systems, 2018, pp.
2675‚Äì2686.
[101] R. Ge, F. Huang, C. Jin, and Y. Yuan, ‚ÄúEscaping from saddle pointsonline stochastic gradient for tensor decomposition,‚Äù in Conference on
Learning Theory, 2015, pp. 797‚Äì842.
[102] B. T. Polyak, ‚ÄúSome methods of speeding up the convergence of iteration methods,‚Äù USSR Computational Mathematics and Mathematical
Physics, vol. 4, pp. 1‚Äì17, 1964.
[103] I. Goodfellow, Y. Bengio, and A. Courville, Deep Learning. MIT
Press, 2016.
[104] I. Sutskever, J. Martens, G. Dahl, and G. Hinton, ‚ÄúOn the importance
of initialization and momentum in deep learning,‚Äù in International
Conference on Machine Learning, 2013, pp. 1139‚Äì1147.
[105] Y. Nesterov, ‚ÄúA method for unconstrained convex minimization
problem with the rate of convergence O( k12 ),‚Äù Doklady Akademii Nauk
SSSR, vol. 269, pp. 543‚Äì547, 1983.
[106] L. C. Baird III and A. W. Moore, ‚ÄúGradient descent for general
reinforcement learning,‚Äù in Advances in Neural Information Processing
Systems, 1999, pp. 968‚Äì974.
[107] C. Darken and J. E. Moody, ‚ÄúNote on learning rate schedules for
stochastic optimization,‚Äù in Advances in Neural Information Processing
Systems, 1991, pp. 832‚Äì838.
[108] M. Schmidt, N. Le Roux, and F. Bach, ‚ÄúMinimizing finite sums with
the stochastic average gradient,‚Äù Mathematical Programming, vol. 162,
pp. 83‚Äì112, 2017.
[109] Z. Allen-Zhu and E. Hazan, ‚ÄúVariance reduction for faster non-convex
optimization,‚Äù in International Conference on Machine Learning, 2016,
pp. 699‚Äì707.
[110] S. J. Reddi, A. Hefny, S. Sra, B. Poczos, and A. Smola, ‚ÄúStochastic
variance reduction for nonconvex optimization,‚Äù in International
Conference on Machine Learning, 2016, pp. 314‚Äì323.
[111] A. Defazio, F. Bach, and S. Lacoste-Julien, ‚ÄúSAGA: A fast incremental
gradient method with support for non-strongly convex composite
objectives,‚Äù in Advances in Neural Information Processing Systems,
2014, pp. 1646‚Äì1654.
[112] M. J. Powell, ‚ÄúA method for nonlinear constraints in minimization
problems,‚Äù Optimization, pp. 283‚Äì298, 1969.
[113] S. Boyd, N. Parikh, E. Chu, B. Peleato, J. Eckstein et al., ‚ÄúDistributed
optimization and statistical learning via the alternating direction method
of multipliers,‚Äù Foundations and Trends in Machine Learning, vol. 3,
pp. 1‚Äì122, 2011.
[114] A. Nagurney and P. Ramanujam, ‚ÄúTransportation network policy
modeling with goal targets and generalized penalty functions,‚Äù
Transportation Science, vol. 30, pp. 3‚Äì13, 1996.
[115] B. He, H. Yang, and S. Wang, ‚ÄúAlternating direction method with
self-adaptive penalty parameters for monotone variational inequalities,‚Äù
Journal of Optimization Theory and Applications, vol. 106, pp. 337‚Äì
356, 2000.
[116] D. Hallac, C. Wong, S. Diamond, A. Sharang, S. Boyd, and
J. Leskovec, ‚ÄúSnapvx: A network-based convex optimization solver,‚Äù
Journal of Machine Learning Research, vol. 18, pp. 1‚Äì5, 2017.

28

[117] B. Wahlberg, S. Boyd, M. Annergren, and Y. Wang, ‚ÄúAn ADMM
algorithm for a class of total variation regularized estimation problems,‚Äù
arXiv preprint arXiv:1203.1828, 2012.
[118] M. Frank and P. Wolfe, ‚ÄúAn algorithm for quadratic programming,‚Äù
Naval Research Logistics Quarterly, vol. 3, pp. 95‚Äì110, 1956.
[119] M. Jaggi, ‚ÄúRevisiting Frank-Wolfe: Projection-free sparse convex
optimization,‚Äù in International Conference on Machine Learning, 2013,
pp. 427‚Äì435.
[120] M. Fukushima, ‚ÄúA modified Frank-Wolfe algorithm for solving
the traffic assignment problem,‚Äù Transportation Research Part B:
Methodological, vol. 18, pp. 169‚Äì177, 1984.
[121] M. Patriksson, The Traffic Assignment Problem: Models and Methods.
Dover Publications, 2015.
[122] K. L. Clarkson, ‚ÄúCoresets, sparse greedy approximation, and the FrankWolfe algorithm,‚Äù ACM Transactions on Algorithms, vol. 6, pp. 63‚Äì96,
2010.
[123] J. Mairal, F. Bach, J. Ponce, G. Sapiro, R. Jenatton, and
G. Obozinski, ‚ÄúSPAMS: A sparse modeling software, version 2.3,‚Äù
http://spams-devel.gforge.inria.fr/downloads.html, 2014.
[124] N. N. Schraudolph, J. Yu, and S. GuÃànter, ‚ÄúA stochastic quasi-Newton
method for online convex optimization,‚Äù in Artificial Intelligence and
Statistics, 2007, pp. 436‚Äì443.
[125] R. H. Byrd, S. L. Hansen, J. Nocedal, and Y. Singer, ‚ÄúA stochastic
quasi- method for large-scale optimization,‚Äù SIAM Journal on
Optimization, vol. 26, pp. 1008‚Äì1031, 2016.
[126] P. Moritz, R. Nishihara, and M. Jordan, ‚ÄúA linearly-convergent
stochastic L-BFGS algorithm,‚Äù in Artificial Intelligence and Statistics,
2016, pp. 249‚Äì258.
[127] M. R. Hestenes and E. Stiefel, Methods of conjugate gradients for
solving linear systems. NBS Washington, DC, 1952.
[128] J. R. Shewchuk, ‚ÄúAn introduction to the conjugate gradient method
without the agonizing pain,‚Äù Carnegie Mellon University, Tech. Rep.,
1994.
[129] M. Avriel, Nonlinear Programming: Analysis and Methods. Dover
Publications, 2003.
[130] P. T. Harker and J. Pang, ‚ÄúA damped-Newton method for the linear
complementarity problem,‚Äù Lectures in Applied Mathematics, vol. 26,
pp. 265‚Äì284, 1990.
[131] P. Y. Ayala and H. B. Schlegel, ‚ÄúA combined method for determining
reaction paths, minima, and transition state geometries,‚Äù The Journal
of Chemical Physics, vol. 107, pp. 375‚Äì384, 1997.
[132] M. Raydan, ‚ÄúThe barzilai and borwein gradient method for the
large scale unconstrained minimization problem,‚Äù SIAM Journal on
Optimization, vol. 7, pp. 26‚Äì33, 1997.
[133] W. C. Davidon, ‚ÄúVariable metric method for minimization,‚Äù SIAM
Journal on Optimization, vol. 1, pp. 1‚Äì17, 1991.
[134] R. Fletcher and M. J. Powell, ‚ÄúA rapidly convergent descent method
for minimization,‚Äù The Computer Journal, vol. 6, pp. 163‚Äì168, 1963.
[135] C. G. Broyden, ‚ÄúThe convergence of a class of double-rank
minimization algorithms: The new algorithm,‚Äù IMA Journal of Applied
Mathematics, vol. 6, pp. 222‚Äì231, 1970.
[136] R. Fletcher, ‚ÄúA new approach to variable metric algorithms,‚Äù The
Computer Journal, vol. 13, pp. 317‚Äì322, 1970.
[137] D. Goldfarb, ‚ÄúA family of variable-metric methods derived by
variational means,‚Äù Mathematics of Computation, vol. 24, pp. 23‚Äì26,
1970.
[138] J. Nocedal, ‚ÄúUpdating quasi-Newton matrices with limited storage,‚Äù
Mathematics of Computation, vol. 35, pp. 773‚Äì782, 1980.
[139] D. C. Liu and J. Nocedal, ‚ÄúOn the limited memory BFGS method
for large scale optimization,‚Äù Mathematical programming, vol. 45, pp.
503‚Äì528, 1989.
[140] W. Sun and Y. X. Yuan, Optimization theory and methods: nonlinear
programming. Springer Science & Business Media, 2006.
[141] A. S. Berahas, J. Nocedal, and M. TakaÃÅc, ‚ÄúA multi-batch L-BFGS
method for machine learning,‚Äù in Advances in Neural Information
Processing Systems, 2016, pp. 1055‚Äì1063.
[142] L. Bottou and O. Bousquet, ‚ÄúThe tradeoffs of large scale learning,‚Äù in
Advances in Neural Information Processing Systems, 2008, pp. 161‚Äì
168.
[143] L. Bottou, F. E. Curtis, and J. Nocedal, ‚ÄúOptimization methods for
large-scale machine learning,‚Äù Society for Industrial and Applied
Mathematics Review, vol. 60, pp. 223‚Äì311, 2018.
[144] A. Mokhtari and A. Ribeiro, ‚ÄúRes: Regularized stochastic BFGS
algorithm,‚Äù IEEE Transactions on Signal Processing, vol. 62, pp. 6089‚Äì
6104, 2014.
[145] ‚Äî‚Äî, ‚ÄúGlobal convergence of online limited memory BFGS,‚Äù Journal
of Machine Learning Research, vol. 16, pp. 3151‚Äì3181, 2015.

[146] R. Gower, D. Goldfarb, and P. RichtaÃÅrik, ‚ÄúStochastic block BFGS:
Squeezing more curvature out of data,‚Äù in International Conference on
Machine Learning, 2016, pp. 1869‚Äì1878.
[147] R. H. Byrd, G. M. Chin, W. Neveitt, and J. Nocedal, ‚ÄúOn the use of
stochastic Hessian information in optimization methods for machine
learning,‚Äù SIAM Journal on Optimization, vol. 21, pp. 977‚Äì995, 2011.
[148] S. I. Amari, ‚ÄúNatural gradient works efficiently in learning,‚Äù Neural
Computation, vol. 10, pp. 251‚Äì276, 1998.
[149] J. Martens, ‚ÄúNew insights and perspectives on the natural gradient
method,‚Äù arXiv preprint arXiv:1412.1193, 2014.
[150] R. Grosse and R. Salakhudinov, ‚ÄúScaling up natural gradient by
sparsely factorizing the inverse fisher matrix,‚Äù in International
Conference on Machine Learning, 2015, pp. 2304‚Äì2313.
[151] J. Martens and R. Grosse, ‚ÄúOptimizing neural networks with
Kronecker-factored approximate curvature,‚Äù in International Conference on Machine Learning, 2015, pp. 2408‚Äì2417.
[152] R. H. Byrd, J. C. Gilbert, and J. Nocedal, ‚ÄúA trust region method based
on interior point techniques for nonlinear programming,‚Äù Mathematical
Programming, vol. 89, pp. 149‚Äì185, 2000.
[153] L. Hei, ‚ÄúPractical techniques for nonlinear optimization,‚Äù Ph.D.
dissertation, Northwestern University, America, 2007.
[154] M. I. Lourakis, ‚ÄúA brief description of the levenberg-marquardt
algorithm implemented by levmar,‚Äù Foundation of Research and
Technology, vol. 4, pp. 1‚Äì6, 2005.
[155] A. R. Conn, K. Scheinberg, and L. N. Vicente, Introduction to
Derivative-Free Optimization.
Society for Industrial and Applied
Mathematics, 2009.
[156] C. Audet and M. Kokkolaras, Blackbox and Derivative-Free Optimization: Theory, Algorithms and Applications. Springer, 2016.
[157] L. M. Rios and N. V. Sahinidis, ‚ÄúDerivative-free optimization: a review
of algorithms and comparison of software implementations,‚Äù Journal
of Global Optimization, vol. 56, pp. 1247‚Äì1293, 2013.
[158] S. Kirkpatrick, C. D. Gelatt, and M. P. Vecchi, ‚ÄúOptimization by
simulated annealing,‚Äù Science, vol. 220, pp. 671‚Äì680, 1983.
[159] M. Mitchell, An Introduction to Genetic Algorithms. MIT press, 1998.
[160] M. Dorigo, M. Birattari, C. Blum, M. Clerc, T. StuÃàtzle, and A. Winfield,
Ant Colony Optimization and Swarm Intelligence. Springer, 2008.
[161] D. P. Bertsekas, Nonlinear Programming. Athena Scientific Belmont,
1999.
[162] P. RichtaÃÅrik and M. TakaÃÅcÃå, ‚ÄúIteration complexity of randomized blockcoordinate descent methods for minimizing a composite function,‚Äù
Mathematical Programming, vol. 144, pp. 1‚Äì38, 2014.
[163] I. Loshchilov, M. Schoenauer, and M. Sebag, ‚ÄúAdaptive coordinate
descent,‚Äù in Annual Conference on Genetic and Evolutionary
Computation, 2011, pp. 885‚Äì892.
[164] T. Huckle, ‚ÄúApproximate sparsity patterns for the inverse of a matrix
and preconditioning,‚Äù Applied Numerical Mathematics, vol. 30, pp.
291‚Äì303, 1999.
[165] M. Benzi, ‚ÄúPreconditioning techniques for large linear systems: a
survey,‚Äù Journal of Computational Physics, vol. 182, pp. 418‚Äì477,
2002.
[166] M. Grant and S. Boyd, ‚ÄúCVX: Matlab software for disciplined convex
programming, version 2.1,‚Äù http://cvxr.com/cvx, 2014.
[167] S. Diamond and S. Boyd, ‚ÄúCvxpy: A python-embedded modeling
language for convex optimization,‚Äù Journal of Machine Learning
Research, vol. 17, pp. 2909‚Äì2913, 2016.
[168] M. Andersen, J. Dahl, and L. Vandenberghe, ‚ÄúCvxopt: A python
package for convex optimization, version 1.1.6,‚Äù https://cvxopt.org/,
2013.
[169] J. D. Hedengren, R. A. Shishavan, K. M. Powell, and T. F. Edgar,
‚ÄúNonlinear modeling, estimation and predictive control in apmonitor,‚Äù
Computers & Chemical Engineering, vol. 70, pp. 133‚Äì148, 2014.
[170] M. Abadi, P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean, M. Devin,
S. Ghemawat, G. Irving, and M. Isard, ‚ÄúTensorflow: a system for largescale machine learning,‚Äù in USENIX Symposium on Operating Systems
Design and Implementations, 2016, pp. 265‚Äì283.
[171] T. Dozat, ‚ÄúIncorporating nesterov momentum into adam,‚Äù in International Conference on Learning Representations, 2016, pp. 1‚Äì14.
[172] I. Loshchilov and F. Hutter, ‚ÄúFixing weight decay regularization in
Adam,‚Äù arXiv preprint arXiv:1711.05101, 2017.
[173] Z. Zhang, L. Ma, Z. Li, and C. Wu, ‚ÄúNormalized direction-preserving
Adam,‚Äù arXiv preprint arXiv:1709.04546, 2017.
[174] H. Salehinejad, S. Sankar, J. Barfett, E. Colak, and S. Valaee,
‚ÄúRecent advances in recurrent neural networks,‚Äù arXiv preprint
arXiv:1801.01078, 2017.

29

[175] Y. Bengio, N. Boulanger-Lewandowski, and R. Pascanu, ‚ÄúAdvances in
optimizing recurrent networks,‚Äù in IEEE International Conference on
Acoustics, Speech and Signal Processing, 2013, pp. 8624‚Äì8628.
[176] J. Martens and I. Sutskever, ‚ÄúTraining deep and recurrent networks with
Hessian-free optimization,‚Äù in Neural Networks: Tricks of the Trade,
2012, pp. 479‚Äì535.
[177] N. N. Schraudolph, ‚ÄúFast curvature matrix-vector products for secondorder gradient descent,‚Äù Neural Computation, vol. 14, pp. 1723‚Äì1738,
2002.
[178] J. Martens and I. Sutskever, ‚ÄúLearning recurrent neural networks with
Hessian-free optimization,‚Äù in International Conference on Machine
Learning, 2011, pp. 1033‚Äì1040.
[179] A. Likas and A. Stafylopatis, ‚ÄúTraining the random neural network
using quasi-Newton methods,‚Äù European Journal of Operational
Research, vol. 126, pp. 331‚Äì339, 2000.
[180] X. Liu and S. Liu, ‚ÄúLimited-memory bfgs optimization of recurrent
neural network language models for speech recognition,‚Äù in International Conference on Acoustics, Speech and Signal Processing, 2018,
pp. 6114‚Äì6118.
[181] T. P. Lillicrap, J. J. Hunt, A. Pritzel, N. Heess, T. Erez,
Y. Tassa, D. Silver, and D. Wierstra, ‚ÄúContinuous control with deep
reinforcement learning,‚Äù arXiv preprint arXiv:1509.02971, 2015.
[182] V. Mnih, A. P. Badia, M. Mirza, A. Graves, T. Lillicrap, T. Harley,
D. Silver, and K. Kavukcuoglu, ‚ÄúAsynchronous methods for deep
reinforcement learning,‚Äù in International Conference on Machine
Learning, 2016, pp. 1928‚Äì1937.
[183] D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. Van
Den Driessche, J. Schrittwieser, I. Antonoglou, V. Panneershelvam, and
M. Lanctot, ‚ÄúMastering the game of go with deep neural networks and
tree search,‚Äù Nature, vol. 529, pp. 484‚Äì489, 2016.
[184] C. J. Watkins and P. Dayan, ‚ÄúQ-learning,‚Äù Machine Learning, vol. 8,
pp. 279‚Äì292, 1992.
[185] G. A. Rummery and M. Niranjan, ‚ÄúOn-line Q-learning using connectionist systems,‚Äù Cambridge University Engineering Department, Tech.
Rep., 1994.
[186] Y. Li, ‚ÄúDeep reinforcement learning: An overview,‚Äù arXiv preprint
arXiv:1701.07274, 2017.
[187] S. Bhatnagar, R. S. Sutton, M. Ghavamzadeh, and M. Lee, ‚ÄúNatural
actor-critic algorithms,‚Äù Automatica, vol. 45, pp. 2471‚Äì2482, 2009.
[188] S. Thrun and L. Pratt, Learning to Learn. Springer Science & Business
Media, 2012.
[189] M. Abdullah Jamal and G.-J. Qi, ‚ÄúTask agnostic meta-learning for
few-shot learning,‚Äù in The IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), 2019, pp. 1‚Äì11.
[190] M. I. Jordan, Z. Ghahramani, T. S. Jaakkola, and L. K. Saul, ‚ÄúAn
introduction to variational methods for graphical models,‚Äù Machine
Learning, vol. 37, pp. 183‚Äì233, 1999.
[191] M. J. Wainwright and M. I. Jordan, ‚ÄúGraphical models, exponential
families, and variational inference,‚Äù Foundations and Trends in
Machine Learning, vol. 1, pp. 1‚Äì305, 2008.
[192] D. M. Blei, A. Kucukelbir, and J. D. McAuliffe, ‚ÄúVariational inference:
A review for statisticians,‚Äù Journal of the American Statistical
Association, vol. 112, pp. 859‚Äì877, 2017.
[193] L. Bottou and Y. L. Cun, ‚ÄúLarge scale online learning,‚Äù in Advances
in Neural Information Processing Systems, 2004, pp. 217‚Äì224.
[194] J. C. Spall, Introduction to Stochastic Search and Optimization:
Estimation, Simulation, and Control. Wiley-Interscience, 2005.
[195] J. Hensman, N. Fusi, and N. Lawrence, ‚ÄúGaussian processes for big
data,‚Äù in Conference on Uncertainty in Artificial Intellegence, 2013,
pp. 282‚Äì290.
[196] J. Hensman, A. G. d. G. Matthews, and Z. Ghahramani, ‚ÄúScalable
variational gaussian process classification,‚Äù in International Conference
on Artificial Intelligence and Statistics, 2015, pp. 351‚Äì360.
[197] S. Duane, A. D. Kennedy, B. J. Pendleton, and D. Roweth, ‚ÄúHybrid
monte carlo,‚Äù Physics Letters B, vol. 195, pp. 216‚Äì222, 1987.
[198] R. Neal, ‚ÄúMCMC using Hamiltonian dynamics,‚Äù Handbook of Markov
Chain Monte Carlo, vol. 2, pp. 113‚Äì162, 2011.
[199] M. Girolami and B. Calderhead, ‚ÄúRiemann manifold langevin and
hamiltonian monte carlo methods,‚Äù Journal of the Royal Statistical
Society: Series B (Statistical Methodology), vol. 73, pp. 123‚Äì214, 2011.
[200] M. Betancourt, ‚ÄúThe fundamental incompatibility of scalable Hamiltonian monte carlo and naive data subsampling,‚Äù in International
Conference on Machine Learning, 2015, pp. 533‚Äì540.
[201] S. Ahn, A. Korattikara, and M. Welling, ‚ÄúBayesian posterior sampling
via stochastic gradient fisher scoring,‚Äù in International Conference on
Machine Learning, 2012, pp. 1591‚Äì1598.

[202] M. D. Hoffman and A. Gelman, ‚ÄúThe No-U-turn sampler: adaptively
setting path lengths in Hamiltonian monte carlo,‚Äù Journal of Machine
Learning Research, vol. 15, pp. 1593‚Äì1623, 2014.
[203] Y. Nesterov, ‚ÄúPrimal-dual subgradient methods for convex problems,‚Äù
Mathematical Programming, vol. 120, pp. 221‚Äì259, 2009.
[204] C. Andrieu and J. Thoms, ‚ÄúA tutorial on adaptive MCMC,‚Äù Statistics
and Computing, vol. 18, pp. 343‚Äì373, 2008.
[205] B. Carpenter, A. Gelman, M. D. Hoffman, D. Lee, B. Goodrich,
M. Betancourt, M. Brubaker, J. Guo, P. Li, and A. Riddell, ‚ÄúStan: A
probabilistic programming language,‚Äù Journal of Statistical Software,
vol. 76, pp. 1‚Äì37, 2017.
[206] S. L. Cotter, G. O. Roberts, A. M. Stuart, and D. White, ‚ÄúMCMC
methods for functions: modifying old algorithms to make them faster,‚Äù
Statistical Science, vol. 28, pp. 424‚Äì446, 2013.
[207] M. Welling and Y. W. Teh, ‚ÄúBayesian learning via stochastic
gradient Langevin dynamics,‚Äù in International Conference on Machine
Learning, 2011, pp. 681‚Äì688.
[208] N. Ding, Y. Fang, R. Babbush, C. Chen, R. D. Skeel, and H. Neven,
‚ÄúBayesian sampling using stochastic gradient thermostats,‚Äù in Advances
in Neural Information Processing Systems, 2014, pp. 3203‚Äì3211.
[209] L. Breiman, ‚ÄúBagging predictors,‚Äù Machine Learning, vol. 24, pp. 123‚Äì
140, 1996.
[210] W. Zaremba, I. Sutskever, and O. Vinyals, ‚ÄúRecurrent neural network
regularization,‚Äù arXiv preprint arXiv:1409.2329, 2014.
[211] S. J. Pan and Q. Yang, ‚ÄúA survey on transfer learning,‚Äù IEEE
Transactions on Knowledge and Data Engineering, vol. 22, pp. 1345‚Äì
1359, 2010.
[212] P. Jain and P. Kar, ‚ÄúNon-convex optimization for machine learning,‚Äù
Foundations and Trends in Machine Learning, vol. 10, pp. 142‚Äì336,
2017.
[213] C. S. Adjiman and S. Dallwig, ‚ÄúA global optimization method, Œ±bb, for
general twice-differentiable constrained NLPs‚ÄìI. theoretical advances,‚Äù
Computers & Chemical Engineering, vol. 22, pp. 1137‚Äì1158, 1998.
[214] C. Adjiman, C. Schweiger, and C. Floudas, ‚ÄúMixed-integer nonlinear
optimization in process synthesis,‚Äù in Handbook of combinatorial
optimization, 1998, pp. 1‚Äì76.
[215] T. Pock, A. Chambolle, D. Cremers, and H. Bischof, ‚ÄúA convex
relaxation approach for computing minimal partitions,‚Äù in IEEE
Conference on Computer Vision and Pattern Recognition, 2009, pp.
810‚Äì817.
[216] L. Xu and D. Schuurmans, ‚ÄúUnsupervised and semi-supervised multiclass support vector machines,‚Äù in Association for the Advancement of
Artificial Intelligence, 904-910, p. 13.
[217] Y. Chen and M. J. Wainwright, ‚ÄúFast low-rank estimation by projected
gradient descent: General statistical and algorithmic guarantees,‚Äù arXiv
preprint arXiv:1509.03025, 2015.
[218] D. Park and A. Kyrillidis, ‚ÄúProvable non-convex projected gradient
descent for a class of constrained matrix optimization problems,‚Äù arXiv
preprint arXiv:1606.01316, 2016.
[219] P. Jain, P. Netrapalli, and S. Sanghavi, ‚ÄúLow-rank matrix completion
using alternating minimization,‚Äù in ACM Annual Symposium on Theory
of Computing, 2013, pp. 665‚Äì674.
[220] M. Hardt, ‚ÄúUnderstanding alternating minimization for matrix
completion,‚Äù in IEEE Annual Symposium on Foundations of Computer
Science, 2014, pp. 651‚Äì660.
[221] M. Hardt and M. Wootters, ‚ÄúFast matrix completion without the
condition number,‚Äù in Conference on Learning Theory, 2014, pp. 638‚Äì
678.
[222] S. Balakrishnan, M. J. Wainwright, and B. Yu, ‚ÄúStatistical guarantees
for the em algorithm: From population to sample-based analysis,‚Äù The
Annals of Statistics, vol. 45, pp. 77‚Äì120, 2017.
[223] Z. Wang, Q. Gu, Y. Ning, and H. Liu, ‚ÄúHigh dimensional expectationmaximization algorithm: Statistical optimization and asymptotic
normality,‚Äù arXiv preprint arXiv:1412.8729, 2014.
[224] N. S. Keskar, D. Mudigere, J. Nocedal, M. Smelyanskiy, and P. T. P.
Tang, ‚ÄúOn large-batch training for deep learning: Generalization gap
and sharp minima,‚Äù arXiv preprint arXiv:1609.04836, 2016.
[225] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio, ‚ÄúEmpirical evaluation of
gated recurrent neural networks on sequence modeling,‚Äù arXiv preprint
arXiv:1412.3555, 2014.
[226] J. Martens, Second-Order Optimization For Neural Networks. University of Toronto (Canada), 2016.
[227] N. N. Schraudolph and T. Graepel, ‚ÄúConjugate directions for stochastic
gradient descent,‚Äù in International Conference on Artificial Neural
Networks, 2002, pp. 1351‚Äì1356.

30

[228] A. Bordes, L. Bottou, and P. Gallinari, ‚ÄúSGD-QN: Careful quasiNewton stochastic gradient descent,‚Äù Journal of Machine Learning
Research, vol. 10, pp. 1737‚Äì1754, 2009.
[229] X. Jin, X. Zhang, K. Huang, and G. Geng, ‚ÄúStochastic conjugate
gradient algorithm with variance reduction,‚Äù IEEE transactions on
Neural Networks and Learning Systems, pp. 1‚Äì10, 2018.

