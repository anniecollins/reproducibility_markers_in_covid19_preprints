Straggler Resilient Serverless Computing Based on
Polar Codes
Burak Bartan and Mert Pilanci

arXiv:1901.06811v2 [cs.IT] 13 Jul 2019

Department of Electrical Engineering
Stanford University
Email: {bbartan, pilanci}@stanford.edu

Abstract‚ÄîWe propose a serverless computing mechanism
for distributed computation based on polar codes. Serverless
computing is an emerging cloud based computation model
that lets users run their functions on the cloud without provisioning or managing servers. Our proposed approach is a
hybrid computing framework that carries out computationally
expensive tasks such as linear algebraic operations involving
large-scale data using serverless computing and does the rest
of the processing locally. We address the limitations and reliability issues of serverless platforms such as straggling workers
using coding theory, drawing ideas from recent literature on
coded computation. The proposed mechanism uses polar codes
to ensure straggler-resilience in a computationally effective
manner. We provide extensive evidence showing polar codes
outperform other coding methods. We have designed a sequential decoder specifically for polar codes in erasure channels
with full-precision input and outputs. In addition, we have
extended the proposed method to the matrix multiplication case
where both matrices being multiplied are coded. The proposed
coded computation scheme is implemented for AWS Lambda.
Experiment results are presented where the performance of the
proposed coded computation technique is tested in optimization
via gradient descent. Finally, we introduce the idea of partial
polarization which reduces the computational burden of encoding and decoding at the expense of straggler-resilience.

I. I NTRODUCTION
Computations for large-scale problems on the cloud might
require a certain level of expertise for managing servers, and
certainly requires configuration of resources ahead of time.
It might be challenging to estimate beforehand exactly how
much RAM, storage, and time a certain problem requires.
For server-based computing on the cloud, users have to
manage these configurations which if not done right, costs
more money for users. Serverless computing, on the other
hand, emerges as a platform simpler to use with much less
overhead. Serverless functions offer an alternative to largescale computing with a lot to offer in terms of cost and speed.
In this work, we work with a mechanism based on serverless computing that enables users to run their computations
in their computers except whenever there is a large-scale
matrix multiplication, the computation is done in parallel
in a serverless computing platform. The key advantages of
this mechanism that may not be available in server-based
approaches are:
‚Ä¢

When serverless functions are not being used (during
some local computations in an algorithm), since there

are no servers running, users do not pay for the resources
they do not use.
‚Ä¢ The serverless approach has the ease of running the
overall algorithm in your own machine with only
computationally-heavy parts running on the cloud and
returning their outputs to your local machine for further
manipulation.
‚Ä¢ It is possible to request different numbers of serverless
functions in different stages of the algorithm. This might
be cost-effective when running algorithms with varying
computational loads.
Along with these advantages, serverless computing comes
with certain limitations for resources such as RAM and
lifetime. For instance, for AWS Lambda, each function can
have a maximum of 3 GB of RAM and has a lifetime up
to 15 minutes. A mechanism based on serverless computing
must take these limitations into account.
One problem that serverless computing platforms and
server-based platforms have in common is that a portion
of the functions (or workers) might finish their task later
than the others (these slower workers are often referred to
as stragglers), and this may cause the overall output to be
delayed if no precaution is taken. Furthermore, it is not
uncommon in serverless computing for a function to return
nothing because functions can crash due to the lifetime
constraint or for other reasons. The straggler issue could be
more problematic in the case of serverless computing than in
server-based computing. For instance, if we assume that each
function will straggle with a given probability independent
of other functions, the probability that there will be at least
one straggling function increases as the number of functions
increases. Since each function can have a limited amount
of memory, large-scale computations usually require many
functions to run in parallel.
To overcome the issue of straggling functions, we use the
idea of inserting redundancy to computations using codes.
This idea has been explored in the literature by many works
such as [9], [2], [14] for dealing with stragglers encountered
in distributed computation. Codes not only help speed up
computations by making it possible to compute the desired
output without waiting for the outputs of the straggling
workers, but also provide resilience against crashes and
timeouts, leading to a more reliable mechanism.

A straggler-resilient scheme designed for a serverless
computing platform needs to be scalable as we wish to allow
the number of functions to vary greatly. Two things become
particularly important if the number of workers is as high
as hundreds or thousands. The first one is that encoding and
decoding must be low complexity. The second one is that
one must be careful with the numerical round-off errors if the
inputs are not from a finite field, but instead are full-precision
real numbers. To clarify this point, when the inputs are realvalued, encoding and decoding operations introduce roundoff errors. Polar codes show superiority over many codes
in terms of both of these aspects. They have low encoding
and decoding complexity and both encoding and decoding
involve a small number of subtraction and addition operations
(no multiplications involved in encoding or decoding). In
addition, they achieve capacity, and the importance of that
fact in coded computation is that the number of worker
outputs needed for decoding is asymptotically optimal.
A. An Important Difference Between Server-Based and
Serverless Computing
We should note one important difference between using
serverless and server-based computing that helps highlight
the usefulness of polar codes. In server-based computing,
one needs to use much fewer machines than the number of
functions one would need in serverless computing to achieve
the same amount of computing. The reason for this is the
limited resources each function can have in serverless computing. Hence, the number of functions is usually expected
to be high, depending on the scale of the computation. This
is an important design criterion that needs to be addressed
as it necessitates efficient encoding and decoding algorithms
for the code we are using. For instance, for a distributed
server-based system with N = 8 machines, using maximum
distance separable (MDS) codes with decoding complexity
as high as O(N 3 ) could still be acceptable. This becomes
unacceptable when we switch to a serverless system as
the number of functions that achieve the same amount of
computations could go up as high as a few hundreds. In this
case, it becomes necessary to use codes with fast decoders
such as polar codes.
Even though polar codes do not have the MDS code
properties, as the block-length of the code increases (i.e. more
functions are used), the performance gap between polar codes
and MDS codes closes. We further discuss this point in the
Numerical Results section.
B. Related Work
Coded matrix multiplication has been introduced in [9]
for speeding up distributed matrix-vector multiplication in
server-based computing platforms. [9] has shown that it is
possible to speed up distributed matrix multiplication by using codes (MDS codes in particular) to avoid waiting for the
slowest nodes. MDS codes however have the disadvantage
of having high encoding and decoding complexity, which
could be restricting in setups with large number of workers.
[2] attacks at this problem presenting a coded computation

scheme based on d-dimensional product codes. [14] presents
a scheme referred to as polynomial codes for coded matrix
multiplication with input matrices from a large finite field.
This approach might require quantization for real-valued
inputs which could introduce additional numerical issues.
[4] and [15] are other works investigating coded matrix
multiplication and provide analysis on the optimal number
of worker outputs required. In addition to the coding theoretic approaches, [6] offers an approximate straggler-resilient
matrix multiplication scheme where the ideas of sketching
and straggler-resilient distributed matrix multiplication are
brought together.
Using Luby Transform (LT) codes, a type of rateless
fountain codes, in coded computation has been recently
proposed in [11] and [10]. The proposed scheme in [10]
divides the overall task into smaller tasks (each task is a
multiplication of a row of A with x) for better load-balancing.
The work [11] proposes the use of inactivation decoding and
the work [10] uses peeling decoder. Peeling decoder has a
computational complexity of O(N log N ) (same complexity
as the decoder we propose), however its performance is not
satisfactory if the number of inputs symbols is not very large.
Inactivation decoder performs better than the peeling decoder,
however, it is not as fast as the peeling decoder.
There has been some recent work on serverless computing
for machine learning training. In [7], serverless machine
learning training is discussed in detail, and challenges and
possible solutions for designing serverless machine training
are provided. Authors in [5] consider an architecture with
multiple master nodes and state that for small neural network
models, serverless computing helps speed up hyperparameter
tuning. Similarly, the work in [13] shows via experiments that
their prototype on AWS Lambda can reduce model training
time greatly.
C. Main Contributions
This work investigates the use of serverless computing
for large-scale computations with a solution to the issue of
stragglers based on polar codes. We identify that polar codes
are a natural choice for coded computation with serverless
computing due to their low complexity encoding and decoding. Furthermore, we propose a sequential decoder for polar
codes designed to work with full-precision data for erasure
channels. The proposed decoder is different from successive
cancellation (SC) decoder given in [1], which is for discrete
data and is based on estimation using likelihoods. We also
analytically justify the use of the polar code kernel that we
used in this work when the inputs and outputs are not from
a finite field but are full-precision real-valued data. Next, we
discuss the polarization of distributions of worker run times
and provide some numerical results to that end. This provides
some important insights towards understanding polarization
phenomenon in a setting other than communication.
Given the work of [9], it is not very surprising that any
linear code like polar codes could also be used in coded
computation. The main novelty of this work lies in the design
of a mechanism based on serverless computing that is easy

to use and can handle large-scale data. We adopt coded
computation as the tool to make the mechanism more resilient
and reliable, and polar codes are our choice of code to ensure
scalability.
Differently from other erasure codes, polar codes offer
a very interesting interpretation in terms of run times of
machines due to the polarization phenomenon. By bringing
together a number of machines in polar code construction,
we achieve virtually transformed machines with polarized run
times. To clarify, the polar coding transformation polarizes
the run times of the workers, that is, as a result of the
transformation, we will obtain faster and slower transformed
machines. This interpretation is equivalent to channels polarizing when polar codes are used for channel coding in
communications [1]. If we set the rate to 1 ‚àí , then we
choose the best N (1 ‚àí ) machines out of the N machines
as the data machines whereas the remaining machines are
frozen (i.e. we send in zero matrices for the slow machines).

is referred to as large-scale matrix-vector multiplication,
different from matrix-matrix multiplication where the second
matrix is also partitioned. We discuss that case later in the
text.
B. Code Construction
Consider the polar coding representation in Figure 2 for
N = 4 nodes. The channels W shown in Figure 2 are always
erasure channels in this work because of the assumption that
if the output of a compute node is available, then it is assumed
to be correct. If the output of a node is not available (straggler
node), then it is considered an erasure.
!""
!#"
!$"

II. C ODED C OMPUTATION WITH P OLAR C ODING
In this section we describe our proposed polar coding
method for matrix-vector multiplication. Later in coded matrix multiplication section, we talk about the extension of this
method to matrix multiplication (both matrices are encoded
instead of one of them). We would like to note that the
method described in this section is applicable for both serverbased and serverless computing platforms. Hence, we use the
terms worker, serverless function, compute node to mean the
same thing, which is a single computing block of whatever
distributed platform we are using. The term master node
refers to the machine that we aggregete the results in.
A. System Model
We are interested in speeding up the computation of A √ó x
where A ‚àà Rm√ón and x ‚àà Rn√ór using the model in Figure
1. The master node encodes the A matrix and communicates
the encoded matrix chunks to workers. Compute nodes then
perform their assigned matrix multiplication. After compute
nodes start performing their assigned tasks, the master node
starts listening for compute node outputs. Whenever a decodable set of outputs is detected, the master node downloads
the available node outputs and performs decoding, using the
sequential decoder described in subsection II.E.
"#,%&'( )

"#,#
"+,#

")*+,%&'( )

Encoding

"+,+,%&'( )

"+,%&'( )

AWS S3

Compute node !‚àí1

AWS Lambda

Master

Result

")*+,+,%&'( )

AWS S3

Decoding

Fig. 1. System model.

Note that this approach assumes x fits in the memory
of a compute node. In coded computation literature, this

!"$

!##

!#$

!$#

!$$

!%#

!%$

&

!"%

&

!#%

&

!$%

&

!%%

Fig. 2. Polar coding for N = 4.

Let Dij denote the data for the node i in the j‚Äôth level 1 .
Further, let us denote the erasure probability of each channel
by , and assume that the channels are independent. Using the
notation from [1], the coding scheme in Figure 2 does the
(0)
(3)
following channel transformation: W 4 ‚Üí (W4 , ..., W4 )
where the transformed channels are defined as:
(0)

W4

: D00 ‚Üí (D03 , ..., D33 )

(1)
W4
(2)
W4
(3)
W4

: D10 ‚Üí (D03 , ..., D33 , D00 )
: D20 ‚Üí (D03 , ..., D33 , D00 , D10 )
: D30 ‚Üí (D03 , ..., D33 , D00 , D10 , D20 )

(1)

The transformation for N = 4 in fact consists of two
levels of two N = 2 blocks, where an N = 2 block does
(0)
(1)
the transformation W 2 ‚Üí (W2 , W2 ), which is shown in
Figure 3. We can now compute the erasure probabilities for
the transformed channels. Consider the block for N = 2
in Figure 3. We have P r(D00 is erased) = 1 ‚àí (1 ‚àí )2 ,
P r(D01 is erased|D00 ) = 2 .
!""

"#,+,%&'( )

Compute node 1
Master

")*+,#

Input

Compute node 0

!%"

!"#

!#"

!"#
!##

%

!"$

%

!#$

Fig. 3. Polar coding for N = 2.

To compute the erasure probabilities for N = 4, note
that D01 , D21 , D03 , D23 form an N = 2 block. Similarly, D11 , D31 , D13 , D33 form another N = 2 block. It
follows that the erasure probabilities for the level 1 are:
1 Note that during encoding, the node values D represent the data before
ij
it is multiplied by x, and during decoding, Dij s represent the data after the
multiplication by x.

P r(D01 is erased) = P r(D11 is erased) = 1 ‚àí (1 ‚àí )2 ,
and P r(D21 is erased|D01 ) = P r(D31 is erased|D11 ) = 2 .
Now, we can compute the erasure probabilities for the input
level:
P r(D00 is erased) = 1 ‚àí (1 ‚àí )4
P r(D10 is erased|D00 ) = (1 ‚àí (1 ‚àí )2 )2

D. Channel

P r(D20 is erased|D00 , D10 ) = 1 ‚àí (1 ‚àí 2 )2
P r(D30 is erased|D00 , D10 , D20 ) = 4

placed below it. The way encoding is done is that we compute
the data for each level from left to right starting from the
leftmost level. There are log2 N + 1 levels in total and N
nodes in every level. Hence, the encoding complexity is
O(N log N ).

(2)

It is straightforward to repeat this procedure to find the
erasure probabilities for the transformed channels in the cases
of larger N .
Knowing the erasure probabilities of channels, we now
select the best channels for data, and freeze the rest (i.e.,
set to zero). The indices of data and frozen channels are
made known to both encoding and decoding. Note that by
(i)
‚Äôchannel‚Äô, we mean the transformed virtual channels WN ,
not W . We refer the readers to [1] for an in-depth analysis
and discussion on polar codes.
A possible disadvantage of the proposed scheme is that the
number of compute nodes has to be a power of 2. This could
pose a problem if the number of workers we are interested
in utilizing is not a power of 2. We identify two possible
solutions to overcome this issue. The first one is to use a
kernel of different size instead of 2. The second solution
is to have multiple code constructions. For instance, let us
assume that we wish to use 20 compute nodes and we choose
 = 14 . We can divide the overall task into 2 constructions.
We would compute the first task using 16 compute nodes
(12 data, 4 frozen channels), and the second task using 4
compute nodes (3 data, 1 frozen channels), where the first
task is to multiply the first 45 m rows of A with x, and the
second task is to multiply the last 51 m rows of A with x.
This way we obtain two straggler-resilient tasks and we use
all 20 workers.
C. Encoding Algorithm
After computing the erasure probabilities for the transformed channels, We choose the d = N (1 ‚àí ) channels
with the lowest erasure probabilities as data channels. The
remaining N  channels are frozen. The inputs for the data
channels are the row partitions of matrix A. That is, we
partition A such that each matrix chunk has m
d rows:
m
A = [AT1 , AT2 , . . . ATd ]T where Ai ‚àà R d √ón . For example, for N = 4 and  = 0.5, the erasure probabilities
of the transform channels are calculated using (2) to be
[0.938, 0.563, 0.438, 0.063]. It follows that we freeze the first
two channels, and the last two channels are the data channels.
m
This means that in Figure 2, we set D00 = D10 = 0 2 √ón
and D20 = A1 , D30 = A2 .
We encode the input using the structure given for N = 4
in Figure 2. Note that instead of the XOR operation like
in polar coding for communication, what we have in this
work is addition over real numbers. This structure can be
easily formed for higher N values. For instance, for N = 8,
we simply connect the circuit in Figure 2 with its duplicate

Channels in the communication context correspond to
compute nodes in the coded computation framework. The
i‚Äôth node computes the matrix multiplication Di,log2 N √ó x.
When a decodable set of outputs is detected, the master node
moves on to decoding the available outputs. At that time, all
the delayed nodes (stragglers) are considered to be erased.
E. Decoding Algorithm
The decoding algorithm, whose pseudo-code is given in
Alg. 1, does not require quantization of data as it is tailored
to work with full-precision data. Note that the notation
IDij ‚àà {0, 1} indicates whether the data for node i in level
j (namely, Dij ) is known. In the first part of the decoding algorithm, we continuously check for decodability as
compute node outputs become available. When the available
outputs become decodable, we move on to the second part.
In the second part, decoding takes place given the available
downloaded compute node outputs. The second part makes
calls to the function decodeRecursive, given in Alg. 2.
Algorithm 1: Decoding algorithm.
Input: Indices of the frozen channels
Result: y = A √ó x
. Part I
Initialize ID:,0 = [ID0,0 , ID1,0 , . . . , IDN ‚àí1,0 ] = [0, . . . , 0]
while ID:,0 not decodable do
update ID:,0
checkDecodability(ID:,0 )2
end
Initialize an empty list y
for i ‚Üê 0 to N ‚àí 1 do
Di,0 = decodeRecursive(i, 0)
if node i is a data node then
y = [y; Di,0 ]
end

. Part II

. forward prop
if i mod 2 = 1 then
for j ‚Üê 0 to log2 N do
for l ‚Üê 0 to i do
compute Dlj if unknown
end
end
end
end

2 checkDecodability is a function that checks whether it is possible to
decode a given sequence of indicators (identifying availability of outputs).
This works the same way as part II of Algorithm 1, but differs in that it
does not deal with data, but instead binary indicators.

Algorithm 2: decodeRecursive(i, j)
Input: Node i ‚àà [0, N ‚àí 1], level j ‚àà [0, log2 N ]
Result: IDij and modifies D
if j = log2 N then return IDi,log2 N . base case 1
if IDij = 1 then return 1
. base case 2
IDi,(j+1) = decodeRecursive(i, j + 1)
IDpair(i),(j+1) = decodeRecursive(pair(i), j + 1)
if i is upper node then
if IDi,(j+1) AND IDpair(i),(j+1) = 1 then
compute Dij
return 1
end
else
if IDi,(j+1) OR IDpair(i),(j+1) = 1 then
compute Dij
return 1
end
end
return 0

III. A NALYSIS
A. Polar Coding on Full-Precision Data
Note that both encoding and decoding algorithms operate
only
 1 1 on N = 2 blocks which correspond to the kernel F2 =
0 1 . Theorem 1 justifies the use of F2 for real-valued data
among all possible 2 √ó 2 kernels. We first give a definition
for a polarizing kernel, and then give a lemma which will
later be used in proving Theorem 1.
Definition 1 (Polarizing kernel): Let f be a function satisfying the linearity property f (au1 + bu2 ) = af (u1 ) + bf (u2 )
where a, b ‚àà R and assume that there is an algorithm to
compute f that takes a certain amount of time to run with its
run time
Let K denote a 2 √ó 2 kernel
 distributed randomly.

and vv12 = K √ó uu12 . Assume that we input v1 and v2
to two i.i.d. instances of the same algorithm for f . Further,
let T1 , T2 be random variables denoting the run times for
computing f (v1 ), f (v2 ), respectively. We are interested in
computing f (u1 ), f (u2 ) in this order. If the time required
to compute f (u1 ) is max(T1 , T2 ) and the time required to
compute f (u2 ) given the value of f (u1 ) is min(T1 , T2 ), then
we say K is a polarizing kernel.
Lemma 1: A kernel K ‚àà R2√ó2 is a polarizing kernel if and
only if the following conditions are both satisfied: 1) Both
elements in the second column of K are nonzero, 2) K is
invertible.
Proof: We first prove that if K is a polarizing kernel,
then it satisfies both of the given conditions. Let us assume an
f function satisfying the linearity property given in Definition
1. Since f holds the linearity property, we can write

 
 

f (v1 )
K11 K12
f (u1 )
=
√ó
.
(3)
f (v2 )
K21 K22
f (u2 )
Computing f (u2 ) given the value of f (u1 ) in time
min(T1 , T2 ) means that f (u2 ) can be computed using f (u1 )
and either one of f (v1 ), f (v2 ) (whichever is computed

earlier). This implies that we must be able to recover f (u2 )
using one of the following two equations
K12 √ó f (u2 ) = f (v1 ) ‚àí K11 f (u1 )

(4)

K22 √ó f (u2 ) = f (v2 ) ‚àí K21 f (u1 ).

(5)

We use (4) if f (v1 ) is known, and (5) if f (v2 ) is known.
This implies that both K12 and K22 need to be nonzero. Furthermore, to be able to compute f (u1 ) in time max(T1 , T2 )
means that it is possible to find f (u1 ) using both f (v1 ) and
f (v2 ) (note that we do not assume we know the value of
f (u2 )). There are two scenarios where this is possible: Either
at least one row of K must have its first element as nonzero
and its second element as zero, or K must be invertible. Since
we already found out that K12 and K22 are both nonzero, we
are left with one scenario, which is that K must be invertible.
We proceed to prove the other direction of the ‚Äôif and only
if‚Äô statement, which states that if a kernel K ‚àà R2√ó2 satisfies
the given two conditions, then it is a polarizing kernel. We
start by assuming an invertible K ‚àà R2√ó2 with both elements
in its second column nonzero. Since K is invertible, we can
uniquely determine f (u1 ) when both f (v1 ) and f (v2 ) are
available, which occurs at time max(T1 , T2 ). Furthermore,
assume we know the value of f (u1 ). At time min(T1 , T2 ), we
will also know one of f (v1 ), f (v2 ), whichever is computed
earlier. Knowing f (u1 ), and any one of f (v1 ), f (v2 ), we can
determine f (u2 ) using the suitable one of the equations (4),
(5) because K12 and K22 are both assumed to be nonzero.
Hence this completes the proof that a kernel K satisfying the
given two conditions is a polarizing kernel.
Theorem 1: Of all possible
2 √ó 2 polarizing kernels,

the kernel F2 = 10 11 results in the fewest number of
computations for encoding real-valued data.
Proof: By Lemma 1, we know that for K to be a
polarizing kernel, it must be invertible and must have both
K12 and K22 as nonzero. For a 2 √ó 2 matrix to be invertible
with both second column elements as nonzero, at least one
of the elements in the first column must also be nonzero.
We now know that K12 , K22 and at least one of K11 , K21
must be nonzero in a polarizing kernel K. It is easy to
see that having all four elements of K as nonzero leads
to more computations than having only three elements of
K as nonzero. Hence, we must choose either K11 or K21
to be zero (it does not matter which one). It is possible to
avoid any multiplications by selecting
 the nonzero elements
 
of K as ones. Hence, both K = 10 11 and K = 01 11
are polarizing kernels and lead to the same amount of
computations, which is a single addition. This amount of
computations is the minimum possible as otherwise K will
not satisfy the condition that a polarizing kernel must have
at least 3 nonzero elements.
IV. D ISCUSSION ON FAST D ECODERS FOR MDS C ODES
Most works in coded computation literature employ MDS
codes as their way of inserting redundancy into computations. Decoding in the case of Reed-Solomon codes and
full-precision data requires solving a linear system. In the
case where one wishes to work with full-precision data, the

decoding becomes expensive (using Gaussian elimination it
takes O(n3 ) operations) and in addition gets unstable for
systems with high number of workers since the linear system
to be solved is a Vandermonde based linear system.
There are many works that restrict their schemes to working with values from a finite field of some size q. In that
case, it is possible to use fast decoding algorithms which are
based on fast algorithms for polynomial interpolation. One
such decoding algorithm is given in [12], which provides
O(n log n) encoding and decoding algorithms for ReedSolomon erasure codes based on Fermat Number Transform
(FNT). The complexity for the encoder is the same as taking
a single FNT transform and for the decoder, it is equal
to taking 8 FNT transforms. To compare with polar codes,
polar codes require n log n operations for both encoding and
decoding. Another work where a fast erasure decoder for
Reed-Solomon codes is presented is [3] which presents a
decoder that works in time O(n log2 n).
There exist many other fast decoding algorithms for RS
codes with complexities as low as O(n log n). However,
the decoding process in these algorithms usually requires
taking a fast transform (e.g. FNT) many times and are
limited to finite fields. Often these fast decoding algorithms
have big hidden constants in their complexity and hence
quadratic time decoding algorithms are sometimes preferred
over them. Polar codes, on the other hand, provide very
straightforward and computationally inexpensive encoding
and decoding algorithms. One of our contributions is the
design of an efficient decoder for polar codes tailored for
the erasure channel that can decode full-precision data.
V. PARTIAL C ONSTRUCTION
In this section, we introduce a new idea that we refer to
as partial construction. Let us assume we are interested in
computing Ax where we only encode A and not x. If the
data matrix A is very large, it might be challenging to encode
it. A way around having to encode a large A is to consider
partial code constructions, that is, for A = [AT1 , ..., ATp ]T , we
encode each submatrix Ai separately. It follows that decoding
the outputs of the construction for the submatrix Ai will
give us Ai x. This results in a weaker straggler resilience,
however, we get a trade-off between the computational load
of encoding and straggler resilience. Partial construction
also decreases the computations required for decoding since
instead of decoding a code with N outputs (of complexity
O(N log N )), now we need to decode p codes with Np
outputs, which is of total complexity O(N log( Np )).
In addition, partial construction makes it possible to
parallel compute both encoding and decoding. Each code
construction can be encoded and decoded independently from
the rest of the constructions.
Partial construction idea can also be applied to coded
computation schemes based on other codes. For instance, one
scenario where this idea is useful is when one is interested in
using RS codes with full-precision data. Given that for large
N values, using RS codes with full-precision data becomes
impossible, one can construct many smaller size codes. When

the code size is small enough, solving a Vandermonde-based
linear system can be painlessly done.
A. In-Memory Encoding
Another benefit of the partial construction idea is that
for constructions of sizes small enough, encoding can be
performed in the memory of the workers after reading the
necessary data. This results in a straggler-resilient scheme
without doing any pre-computing to encode the entire dataset.
In-memory encoding could be useful for problems where the
data matrix A also is also changing over time because it
might be too expensive to encode the entire dataset A every
time it changes.
VI. C ODED M ATRIX M ULTIPLICATION
In this section, we provide an extension to our proposed
method to accommodate coding of both A and B for computing the matrix multiplication AB (instead of coding only
A). This can be thought of as a two-dimensional extension
of our method. Let us partition A and B as follows:
Ô£Æ
Ô£π
A1


Ô£Ø
Ô£∫
A = Ô£∞ ... Ô£ª , B = B1 . . . Bd2 .
(6)
Ad1
Let us denote zero matrix padded version of A by AÃÉ =
[AÃÉT1 , ..., AÃÉTN1 ]T such that AÃÉi = 0 if i is a frozen channel
index and AÃÉi = Aj if i is a data channel index with j the
appropriate index. Similarly, we define BÃÉ = [BÃÉ1 , ..., BÃÉN2 ]
such that BÃÉi = 0 if i is a frozen channel index and BÃÉi = Bj
if i is a data channel index with j the appropriate index.
Encoding on AÃÉ can be represented as GN1 AÃÉ where GN1 is
the N1 dimensional generator matrix and acts on submatrices
AÃÉi . Similarly, encoding on BÃÉ would be BÃÉGN2 .
Encoding A and B gives us N1 submatrices (GN1 AÃÉ)i due
to A and N2 submatrices (BÃÉGN2 )j due to B. Then, we
matrix-multiply the encoded matrices using a total of N1 N2
workers with the (i, j)‚Äôth worker computing the matrix multiplication (GN1 AÃÉ)i (BÃÉGN2 )j . More explicitly, the worker
outputs will be of the form:
Ô£Æ
Ô£π
(GN1 AÃÉ)1 (BÃÉGN2 )1 . . . (GN1 AÃÉ)1 (BÃÉGN2 )N2
Ô£Ø
Ô£∫
..
..
P =Ô£∞
Ô£ª
.
.
(GN1 AÃÉ)N1 (BÃÉGN2 )1

...

(GN1 AÃÉ)N1 (BÃÉGN2 )N2
(7)

Note that for fixed j, the worker outputs are:
Ô£Æ
Ô£π
(GN1 AÃÉ)1 (BÃÉGN2 )j
Ô£Ø
Ô£∫
..
Ô£∞
Ô£ª
.
(GN1 AÃÉ)N1 (BÃÉGN2 )j

(8)

For fixed j, the outputs are linear in (BÃÉGN2 )j , hence, it is
possible to decode these outputs using the decoder we have
for the 1D case. Similarly, for fixed i, the outputs are:


(9)
(GN1 AÃÉ)i (BÃÉGN2 )1 . . . (GN1 AÃÉ)i (BÃÉGN2 )N2
For fixed i, the outputs are linear in (GN1 AÃÉ)i . It follows
that the 1D decoding algorithm can be used for decoding the

Algorithm 3: 2D decoding algorithm for matrix multiplication.
Input: the worker output matrix P
Result: y = A √ó B
while P has missing entries do
. loop over rows
for i ‚Üê 0 to N1 ‚àí 1 do
if P [i, :] has missing entries and is decodable
then
decode P [i, :] using Alg. 1
forward prop to fill in P [i, :]
end
end
. loop over columns
for j ‚Üê 0 to N2 ‚àí 1 do
if P [:, j] has missing entries and is decodable
then
decode P [:, j] using Alg. 1
forward prop to fill in P [:, j]
end
end
end
decode all rows and then all columns of P
return entries of P (ignoring the frozen entries)

VII. N UMERICAL R ESULTS
A. Encoding and Decoding Speed Comparison
Figure 4 shows the time encoding and decoding algorithms
take as a function of the number of workers N for ReedSolomon and polar codes. For Reed-Solomon codes, we
implemented two encoders and decoders. The first approach
is the naive approach where encoding is done using matrix
multiplication (O(N 2 )) and decoding is done by solving a
linear system (O(N 3 )), hence the naive encoder and decoder
can support full-precision data. The second approach is the
fast implementation for both encoding and decoding (of complexities O(N log N ) and O(N log2 N ), respectively). The
fast implementation is based on Fermat Number Transform
(FNT), hence only supports finite field data. In obtaining
the plots in Figure 4, we always used 0.5 as the rate and
performed the computation Ax where A is (100N √ó 5000)dimensional and x is (5000 √ó 1000)-dimensional. The line in
Figure 4(b) with markers ‚Äôx‚Äô and dashed lines indicates that
the error due to the decoder is unacceptably high (this can
happen because we used full-precision data for the naive RS
decoder).

RS (naive)
RS with FNT
Polar Coding

300

Decoding time (sec)

Encoding time (sec)

outputs. Based on these observations, we designed a polar
decoder for the 2D case whose pseudo-code is given in Alg.
3. The 2D decoding algorithm makes calls to the 1D encoding
and decoding algorithms many times to fill in the missing
entries of the encoded matrix P defined in (7). When all
missing entries of P are computed, first all rows and then all
columns of P are decoded and finally, the frozen entries are
removed to obtain the multiplication AB.

200
100

RS (naive)
RS (naive) -- high error
RS with FNT
Polar Coding

100

50

0

0
8

16

32

64
N

128

256

512

(a) Encoding

8

16

32

64
N

128

256

512

(b) Decoding

Fig. 4. Comparison of encoding and decoding speeds for RS and polar
codes. Note that the horizontal axis is in log-scale.

Figure 4 illustrates that polar codes take much less time
for encoding and especially decoding compared to ReedSolomon codes. This is because of the constants hidden in
the complexities of fast decoders for Reed-Solomon decoders
which is not the case for polar codes. We note that it might
be more advantageous to use RS codes for small N values
because they have the MDS properties and can encode and
decode fast enough for small N . However, in serverless
computing where each function has limited resources and
hence using large N values is usually the case, we need
faster encoding and decoding algorithms. Considering the
comparison in Figure 4, polar codes are more suitable to
use with serverless computing.
B. Polarized Computation Times
Figure 5 illustrates how the empirical CDFs of computation times polarize as we increase the number of functions
N . Figure 5(a) shows the empirical CDF of the computation
times of AWS Lambda functions, obtained by timing 500
AWS Lambda functions running the same Python program.
The other plots in Figure 5 are generated assuming that there
are N functions with i.i.d. run time distributions (the CDF
of which is plotted in Figure 5 (a)), and show the resulting
transformed CDFs of the polarized computation times. Note
that the empirical CDFs move away from each other (i.e.
polarize) as N is increased and we obtain better and worse
run time distributions. Note that the freezing operation in
the code construction corresponds to not using workers with
worse run times.
C. Empirical Distribution of Decodability Time
We refer to the time instance where the available outputs
become decodable for the first time as decodability time.
Figure 6 shows the histograms of the decodability time for
different values of N for polar, LT, and MDS codes, respectively. These histograms were obtained by sampling i.i.d.
worker run times with replacement from the input distribution
whose CDF is plotted in Figure 5(a) and by repeating this
1000 times. Further,  = 0.375 was used as the erasure
probability. We observe that as N increases, the distributions
converge to the dirac delta function, showing that for large
N values, the decodability time becomes deterministic.
Plots in Figure 6(d,e,f) are the decodability time histograms for LT codes with peeling decoder. The degree

N=1

N=2

1
i

CDF: Pr(t >= T )

CDF: Pr(t >= Ti)

1

0.5

0
0

50

100

0.5

0
0

150

50

100

t

(a) N = 1

N = 64

1
i

CDF: Pr(t >= T )

CDF: Pr(t >= Ti)

(b) N = 2

N = 16

1

150

t

0.5

0
0

50

100

150

0.5

0
0

50

100

t

150

t

(c) N = 16

(d) N = 64

Figure 7 shows decodability time histograms for computing the matrix multiplication AB for polar (using the 2D
decoder outlined in Alg. 3) and MDS codes. The rate for
encoding A is 34 and it is the same for B, which gives an
9
. The decodability time for polar codes is
overall rate of 16
the first time instance in which the decoder in Alg. 3 is able
to decode the available set of outputs. The decodability time
for MDS codes is whenever 9N
16 of the outputs is available.
Figure 7 illustrates that the decodability time for the polar
codes is only slightly worse than for MDS codes. Note that
the decodability time for MDS codes is optimal since the
recovery threshold is optimal for MDS codes when A is
partitioned row-wise and B is partitioned column-wise when
computing AB [14]. For N = 256, we see in Figure 7 that
the gap between the decodability time performances of polar
and MDS codes is negligibly small. Hence, as the number
of functions is increased, the decodability time becomes no
longer an important disadvantage of using polar codes instead
of MDS codes.
800

1000

400

500

200
0

0

50
100
time (sec)

0

150

(a) Polar, N = 64

50
100
time (sec)

150

frequency

1000

500

0

0

(b) Polar, N = 256

1000

frequency

distribution is the robust soliton distribution as suggested
in [10]. We see that polar codes achieve better decodability
times than LT codes. Plots in Figure 6(g,h,i) on the other
hand show that MDS codes perform better than polar codes
in terms of decodability time, which is expected. When
considering this result, one should keep in mind that for
large N , MDS codes take much longer times to encode and
decode compared to polar codes as we discussed previously.
In addition, we see that for large N values, the gap between
the decodability time performances closes.

600

frequency

frequency

Fig. 5. Polarization of empirical CDFs.

0

50
100
time (sec)

150

(c) MDS, N = 64

500

0

0

50
100
time (sec)

150

(d) MDS, N = 256

400
200
0

600
400
200

0

50
100
time (sec)

0

150

Fig. 7. Histograms of decodability time for polar codes and MDS codes
for matrix multiplication.

800

frequency

800

600

frequency

frequency

800

600
400
200

0

50
100
time (sec)

0

150

0

50
100
time (sec)

150

D. Coded Computation on AWS Lambda

We have implemented the proposed coded computation
(b) Polar, N = 64 (c) Polar, N = 512 scheme for the AWS Lambda platform and now present the
500
400
600
results illustrating its performance. The implementation is
400
300
written in Python. The compute nodes are AWS Lambda
400
300
200
functions each with a memory of 1536 MB and a timeout
200
200
100
100
limit of 300 seconds. We have utilized the Pywren module
0
0
0
0
50
100
150
0
50
100
150
0
50
100
150 [8] for running code in AWS Lambda. The master node in
time (sec)
time (sec)
time (sec)
our implementation is a Macbook Pro laptop with 8 GB of
(d) LT, N = 8
(e) LT, N = 64
(f) LT, N = 512
RAM.
800
1000
1000
Given in Figure 8 is a plot showing the timings of
800
800
600
serverless
functions, and of the decoding process, where
600
600
400
we
compute
A √ó x where A ‚àà R38400√ó3000000 and x ‚àà
400
400
3000000√ó20
200
R
using N = 512 serverless functions, and taking
200
200
0
0
0

=
0.25.
The
vertical axis represents the numbers we assign
0
50
100
150
0
50
100
150
0
50
100
150
time (sec)
time (sec)
time (sec)
to the serverless functions (i.e. job id). Encoding process
(g) MDS, N = 8 (h) MDS, N = 64 (i) MDS, N = 512 is not included in the plot, as it is usually the case for
many applications that we multiply the same A matrix with
Fig. 6. Histograms of decodability time for polar, LT, and MDS codes.
different x‚Äôs. Hence for an application that requires iterative
frequency

frequency

frequency

frequency

frequency

frequency

(a) Polar, N = 8

600
500
i'th job starts
i'th job ends
i'th result available
t

job id

400
300

0

Decodable
Decoding starts
Decoding ends

200
100
0

0

50

100
time (sec)

150

200

Fig. 8. Job output times and decoding times for N = 512 using AWS
Lambda.

For the experiment shown in Figure 8, each serverless
function instance performs a matrix multiplication with dimensions (100√ó3000000) and (3000000√ó20). A matrix with
dimensions (100 √ó 3000000) requires a memory of 2.3 GB.
It is not feasible to load a matrix of this size into the memory
at once; hence, each serverless function loads 1/10‚Äôth of its
corresponding matrix at a time. After computing 1/10‚Äôth of
its overall computation, it moves on to perform the next 1/10
of its computation. In Figure 8, the red stars show the times
each functions starts running. Green stars (mostly invisible
because they are covered by the blue stars) show the times
functions finish running. Blue stars indicate the times that
the outputs of functions become available. Green (vertical)
line is the first time the available outputs become decodable.
After the available outputs become decodable, we cannot start
decoding right away; we have to wait for their download (to
the master node) to be finished, and this is shown by the
magenta line. Magenta line also indicates the beginning of
the decoding process, and lastly the black line indicates that
decoding is finished.
We observe that there are straggling AWS Lambda functions that finish after decoding is over, showing the advantage
of our coded computation scheme over an uncoded scheme
where we would have to wait for all AWS Lambda functions
to finish their assigned tasks. The slowest serverless function
seems to have finished around t = 200, whereas the result
is available at around t = 150 for the proposed coded
computation.
E. Application: Gradient Descent on a Least Squares Problem
We used the proposed method in solving a least squares
problem via gradient descent uaing AWS Lambda. The

problem that we focus on in this subsection is the standard
least squares problem:
minimize ||Ax ‚àí y||22

(10)

where x ‚àà Rn√ór is not necessarily a vector; it could be a
matrix. Let x‚àó ‚àà Rn√ór be the optimal solution to (10), and let
x‚àói represent the i‚Äôth column of x‚àó . Note that if x is a matrix,
then the problem (10) is equivalent to solving r different
least-squares problems with the same A matrix: minimize
||Axi ‚àí yi ||22 . The solution to this problem is the same as the
i‚Äôth column of x‚àó , that is, x‚àói . When r is large (and if we
assume that A fits in the memory of each worker), one way to
solve (10) in a distributed setting is by assigning the problem
of minimizing ||Axi ‚àíyi ||22 to worker i. This solution however
would suffer from possible straggling serverless function, and
assumes that A is small enough to fit in the memory of a
serverless function. Another solution, the one we experiment
with in this subsection, is to use gradient descent as in this
case we are no longer restricted by A having to fit in the
memory and our proposed method can be used to provide
resilience towards stragglers for this solution.
10 4
10 3

10 2

cost

matrix multiplications with the same A but different x‚Äôs, it is
sufficient to encode A once, but decoding has to be repeated
for every different x. Therefore, the overall time would be
dominated by the matrix multiplications and decoding, which
are repeated many times unlike encoding which takes place
once.

10 1
Uncoded, 8 nodes
Polar coding, N = 16,
Polar coding, N = 32,
Polar coding, N = 64,

10 0

10 -1

0

20

40

= 0.5
= 0.75
= 0.875

60
time (sec)

80

100

120

Fig. 9. Cost vs time for the gradient descent example.

The gradient descent update rule for this problem is:
xt+1 = xt ‚àí ¬µ(AT Axt ‚àí AT y),

(11)

where ¬µ is the step size (or learning rate), and the subscript
t specifies the iteration number.
We applied our proposed coded matrix multiplication
scheme to solve a least squares problem (10) using gradient
descent where A ‚àà R20000√ó4800 , and x ‚àà R4800√ó1000 .
Figure 9 shows the downward-shifted cost (i.e., l2 -norm
of the residuals ||Axt ‚àí y||2 ) as a function of time under
different schemes. Before starting to update the gradients,
we first compute and encode AT A offline. Then, in each
iteration of the gradient descent, the master node decodes
the downloaded outputs, updates xt , sends the updated xt to
AWS S3 and initializes the computation AT Axt . In the case
of uncoded computation, we simply divide the multiplication
task among N (1‚àí) serverless functions, and whenever all of
the N (1 ‚àí ) functions finish their computations, the outputs
are downloaded to the master node, and there is no decoding.

Then, master node computes and sends the updated xt , and
initializes the next iteration.
Note that in a given iteration, while computation with polar
coding with rate (1 ‚àí ) waits for the first decodable set of
outputs out of N outputs, uncoded computation waits for all
N (1 ‚àí ) nodes to finish computation. With this in mind, it
follows that coded computation results in a trade-off between
price and time, that is, by paying more, we can achieve a
faster convergence time, as illustrated in Figure 9. Note that
in coded computation we pay for N serverless functions,
and in uncoded computation we pay for N (1 ‚àí ) serverless
functions. Using  as a tuning parameter for redundancy, we
achieve different convergence times.
VIII. C ONCLUSION
We have proposed to use polar codes for distributed matrix
multiplication in serverless computing, and discussed that the
properties of polar codes are a good fit for straggler-resilient
serverless computing. We have discussed the differences between serverless and server-based computing and addressed
the differences and limitations of serverless computing in
our proposed mechanism. We considered a centralized model
with a master node and a large number of serverless functions. We implemented our proposed method using AWS
Lambda and presented results showing its performance. We
presented a sequential decoder algorithm that can encode and
decode full-precision data so that our proposed framework
can be used for computations on full-precision data. We
discussed how to extend the proposed method to the twodimensional case which corresponds to matrix multiplication
where we code both matrices being multiplied. We have
identified and illustrated with a numerical example a tradeoff between the computation price and convergence time
for the gradient descent algorithm applied to a least-squares
problem.
R EFERENCES
[1] E. Arikan. Channel polarization: A method for constructing capacityachieving codes for symmetric binary-input memoryless channels.
IEEE Transactions on Information Theory, 55:3051‚Äì3073, 2009.
[2] T. Baharav, K. Lee, O. Ocal, and K. Ramchandran. Straggler-proofing
massive-scale distributed matrix multiplication with d-dimensional
product codes. IEEE International Symposium on Information Theory
(ISIT), pages 1993‚Äì1997, 2018.
[3] FreÃÅdeÃÅric Didier. Efficient erasure decoding of reed-solomon codes.
CoRR, abs/0901.1886, 2009.
[4] S. Dutta, M. Fahim, F. Haddadpour, H. Jeong, V. R. Cadambe,
and P. Grover. On the optimal recovery threshold of coded matrix
multiplication. CoRR, abs/1801.10292, 2018.
[5] L. Feng, P. Kudva, D. Da Silva, and J. Hu. Exploring serverless computing for neural network training. In 2018 IEEE 11th International
Conference on Cloud Computing (CLOUD), pages 334‚Äì341, July 2018.
[6] V. Gupta, S. Wang, T. A. Courtade, and K. Ramchandran. Oversketch: Approximate matrix multiplication for the cloud. CoRR,
abs/1811.02653, 2018.
[7] Alexey Tumanov Andrew Zhang Joao Carreira, Pedro Fonseca and
Randy Katz. A case for serverless machine learning. Workshop on
Systems for ML and Open Source Software at NeurIPS 2018, 2018.
[8] E. Jonas, S. Venkataraman, I. Stoica, and B. Recht. Occupy the cloud:
Distributed computing for the 99%. CoRR, abs/1702.04024, 2017.
[9] K. Lee, M. Lam, R. Pedarsani, D. Papailiopoulos, and K. Ramchandran. Speeding up distributed machine learning using codes. IEEE
Transactions on Information Theory, 64(3):1514‚Äì1529, March 2018.

[10] A. Mallick, M. Chaudhari, and G. Joshi. Rateless codes for near-perfect
load balancing in distributed matrix-vector multiplication. CoRR,
abs/1804.10331, 2018.
[11] A. Severinson, A. G. i Amat, and E. Rosnes. Block-diagonal and
lt codes for distributed computing with straggling servers. IEEE
Transactions on Communications, 2018.
[12] A. Soro and J. Lacan. Fnt-based reed-solomon erasure codes. In 2010
7th IEEE Consumer Communications and Networking Conference,
pages 1‚Äì5, Jan 2010.
[13] H. Wang, D. Niu, and B. Li. Distributed machine learning with a
serverless architecture. In IEEE INFOCOM 2019 - IEEE Conference
on Computer Communications, pages 1288‚Äì1296, April 2019.
[14] Q. Yu, M. A. Maddah-Ali, and A. S. Avestimehr. Polynomial codes:
An optimal design for high-dimensional coded matrix multiplication.
Adv. in Neural Info. Proc. Systems (NIPS) 30, pages 4406‚Äì4416, 2017.
[15] Q. Yu, M. A. Maddah-Ali, and A. S. Avestimehr. Straggler mitigation
in distributed matrix multiplication: Fundamental limits and optimal
coding. CoRR, abs/1801.07487, 2018.

