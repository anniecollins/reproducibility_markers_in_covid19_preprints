Noname manuscript No.
(will be inserted by the editor)

The PRIMPing Routine â€” Tiling through Proximal
Alternating Linearized Minimization
Sibylle Hess Â· Katharina Morik Â·
Nico Piatkowski

arXiv:1906.09722v1 [cs.AI] 17 Jun 2019

Received: date / Accepted: date

Abstract Mining and exploring databases should provide users with knowledge
and new insights. Tiles of data strive to unveil true underlying structure and
distinguish valuable information from various kinds of noise. We propose a novel
Boolean matrix factorization algorithm to solve the tiling problem, based on recent
results from optimization theory. In contrast to existing work, the new algorithm
minimizes the description length of the resulting factorization. This approach is
well known for model selection and data compression, but not for finding suitable
factorizations via numerical optimization. We demonstrate the superior robustness
of the new approach in the presence of several kinds of noise and types of underlying structure. Moreover, our general framework can work with any cost measure
having a suitable real-valued relaxation. Thereby, no convexity assumptions have
to be met. The experimental results on synthetic data and image data show that
the new method identifies interpretable patterns which explain the data almost
always better than the competing algorithms.
Keywords Tiling Â· Boolean Matrix Factorization Â· Minimum Description Length
principle Â· Proximal Alternating Linearized Minimization Â· Nonconvex-Nonsmooth
Minimization Â· Alternating Minimization

1 Introduction
In a large range of data mining tasks such as Market Basket Analysis, Text Mining, Collaborative Filtering or DNA Expression Analysis, we are interested in the
exploration of data which is represented by a binary matrix. Data exploration is
unsupervised by nature; the objective is to gain insight by a summarization of its
relevant parts. Here, we seek for sets of columns and rows whose intersecting positions frequently feature a one. This identifies, e.g., groups of users together with
their shared preferences, genes that are often co-expressed among several tissue
samples, or words that occur together in documents describing the same topic. The
identification of such sets of columns and rows is studied from the perspective of
TU Dortmund, Computer Science, LS 8, 44221 Dortmund, Germany

2

Sibylle Hess et al.

Fig. 1: Example binary dataset (left) with ones in yellow and zeros in blue. A
rearrangement of columns and rows unveils structure (right).

various data mining subfields as biclustering, tiling or matrix factorization (Tatti
and Vreeken 2012; Zimek and Vreeken 2013).
Consider the example binary database presented on the left in Fig. 1. The
distribution of ones appears disarrayed, but a suitable permutation of columns and
rows reveals a formation of blocks, depicted by the matrix on the right. Interpreting
all binary entries which do not fit to this formation as noise, we aim to separate
the haphazard component from the formative one.
This objective is difficult to delineate: where to draw the line between structure
and noise? Are there natural limitations on the amount of blocks to derive? To
what extend may they overlap? Miettinen and Vreeken (2014) successfully apply
the Minimum Description Length (MDL) principle to reduce these considerations
into one objective: exploit just as many regularities as serves the compression of the
data. Identifying regularities with column-row interrelations, the description length
counterbalances the complexity of the model (derived interrelations) and the fit
to the data, measured by the size of the encoded data using the model. Decisive
for the feasibility of extracted components is the definition of the encoding.
Miettinen and Vreeken (2014) evaluate several encodings with respect to their
ability to filter a planted structure from noise. The method they use applies a
greedy Boolean matrix factorization to extract candidate interrelations which are
selected according to a specified description length. Another framework proposed
by Lucchese et al (2014) greedily selects the interrelations directly in accordance
with the description length. Most recently, Karaev et al (2015) propose another
greedy algorithm with focus on a setting where ones more probably indicate interrelations than noise. All these methods are capable to identify the underlying
structure in respectively examined settings. All in all, the experiments indicate
however that the quality considerably varies depending on the distribution of noise
and characteristics of the dataset (Miettinen and Vreeken 2014; Karaev et al 2015).
For real-world datasets, it is difficult (if not impossible) to estimate these aspects, in order to choose the appropriate algorithm or to assess its quality on
the given dataset. Believing that the unsteady performance is due to a lack of
theoretical foundation, we introduce a framework called PAL-Tiling to numerically optimize a cost measure which has a suitable real-valued approximation. In
this respect, we derive approximations of two MDL cost measures, consequently
proposing two algorithms: one applying L1-regularization on the matrix factorization (Panpal) and one employing an encoding by code tables as proposed by
Siebes et al (2006) (Primp). We assess the algorithmsâ€™ ability to filter the true
underlying structure from the noise. Therefore, we compare various performance

The PRIMPing Routine

3

measures in a controlled setting of synthetically generated data as well as for realworld data. We show that Primp is capable of recovering the latent structure in
spite of varying database characteristics and noise distributions. In addition, we
visualize the derived categorization into tiles by means of images, showing that our
conducted minimization procedure of PAL-Tiling yields interpretable groupings.

1.1 Roadmap
In Section 2 we introduce our notation and review the work related to the three
research branches of Tiling, MDL, and Nonnegative Matrix Factorization, which
compound our method. After surveying these building blocks, we introduce our
optimization framework PAL-Tiling in Sec. 3. We derive the proximal mapping
with respect to the proposed penalization of non-binary values, enabling the minimization of the approximate Boolean matrix factorization error under convergence
guarantees. Therewith we derive the L1-regularized minimization of the reconstruction error by the algorithm Panpal in Sec. 3.3. We formulate the encoding
via code tables in the form of a Boolean matrix factorization, which defines together with a suitable relaxation of this measure, derived in Sec. 3.4, the algorithm
Primp. In Sec. 4, we compare our approach to related methods in various synthetically generated settings and real-world data. Furthermore, we provide insight
into the algorithmsâ€™ understanding of noise based on images. Finally, we conclude
in Sec. 5.

2 Problem Definition and Building Blocks
We identify items I = {1, . . . , n} and transactions T = {1, . . . , m} by a set of
indices of a binary matrix D âˆˆ {0, 1}mÃ—n . This matrix represents the data, having
Dji = 1 iff transaction j contains item i. A set of items is called a pattern. If the
pattern is a subset of a transaction, we say the transaction supports the pattern.
Throughout the paper, we often employ the function Î¸t which rounds real to
binary values, i.e., Î¸t (x) = 1 for x â‰¥ t and Î¸t (x) = 0 otherwise. We abbreviate
Î¸0.5 to Î¸ and denote with Î¸(X) = (Î¸(Xji ))ji the entry-wise application of Î¸ to a
matrix X.
We denote matrix norms as k Â· k for the Frobenius norm and | Â· | for the entrywise 1-norm. These norms are equivalent for binary matrices X in the sense that
|X| = kXk2 . We use the short notation |X|âˆ’ = |Î¸(âˆ’X)| and |X|+ = |Î¸(X)| to
separate the norm of negative and nonnegative entries of X. We often abbreviate
the notation of a matrix (xij )1â‰¤iâ‰¤n,1â‰¤jâ‰¤m to (xij )ij if the range of indices is clear
from the context. Correspondingly, we notate column vectors (xi )i . The operator â—¦
denotes the Hadamard product which multiplies two matrices of same dimensions
element-wise. Lastly, we remark that log denotes the natural logarithm.

2.1 Problem Definition
We seek sets of column-row selections which can be visualized as a formation of
blocks as exemplified in our introduction. The expectation that such a formation

4

Sibylle Hess et al.

ï£«

1 1
ï£¬
ï£¬ 1 0
ï£¬
ï£¬ 0 1
ï£­
1 0

1
1
1
1

1
0
1
0

1
1
1
1

ï£¶
ï£«ï£«
ï£¶
ï£«
ï£¶
ï£·
ï£¬ï£¬ 1 1 ï£·
ï£·
ï£·
ï£¬ï£¬
ï£·
ï£·
ï£· = Î¸ ï£¬ï£¬ 1 0 ï£· Â· ï£­ 1 0 1 0 1 ï£¸ï£·
ï£·
ï£¬ï£¬ 0 1 ï£·
ï£·
0 1 1 1 1
ï£¸
ï£­ï£­
ï£¸
ï£¸
1 0
ï£¶

Fig. 2: An exact Boolean factorization using two tiles. The tiles are highlighted.

exists is based on the assumption that the data D originates from a Boolean
matrix product Î¸(Y X T ). Here, it is important to understand that the thresholding
function Î¸ (defined above) suffices to map binary operations onto the Boolean
algebra where the addition corresponds to the logical conjunction, i.e., Î¸(0 + 1) =
Î¸(1 + 0) = 1 and Î¸(1 + 1) = 1. This way, the product is also well-defined for
nonnegative real-valued matrices. For an exploration of non-canonical Boolean
matrix products, and what derives from them, see, e.g., (Miettinen 2015).
Let X be an n Ã— r binary matrix and Y an m Ã— r binary matrix. The product Î¸(Y X T ) specifies r column-row selections called tiles, one by each pair of
column vectors (XÂ·s , YÂ·s ). Thereby, we implicitly assume that each tile provides
information about co-occurrences of items and transactions. In practice, however,
one column vector may be equal to the zero vector or indicate only one item,
respectively a single usage of a pattern. We do not take these trivial column-row
selections into account and introduce the function r(Â·, Â·) to count the number of
valuable tiles r(X, Y ) = |{s : |XÂ·s | > 1âˆ§|YÂ·s | > 1}| â‰¤ r. In theory, we often assume
that r = r(X, Y ) and in this case, we call r the rank of the tiling or factorization.
An example of a rank-2 factorization is depicted in Fig. 2. The vector XÂ·s indicates the pattern which contains all items i âˆˆ I with Xis = 1. Likewise, the vector
YÂ·s marks the transactions which use pattern XÂ·s to form the tile. Accordingly,
we refer to the matrix X as the pattern matrix and to Y as the usage matrix.
T
The name tile reflects its visualization as a single block matrix YÂ·s XÂ·s
for suitably
rearranged columns and rows.
We state the informal problem to recover the latent factorization, which we
intend to approach in this paper, as follows.
Informal Problem Definition
Given a data matrix D âˆˆ {0, 1}mÃ—n originating from the following process
1.
2.
3.
4.

Let X âˆˆ {0, 1}nÃ—r be a rank r matrix, denoting r patterns.
For each transaction DjÂ· choose a set of patterns Sj âŠ† {1, . . . r}.
Construct Y âˆˆ {0, 1}mÃ—r such that Yjs = 1 â‡” s âˆˆ Sj .
Let N âˆˆ {âˆ’1, 0, 1}mÃ—n be the noise matrix satisfying
Nji + Î¸(Y X T )ji â‰¥ 0.

5. Set
D = Î¸(Y X T ) + N.
Find

the factor matrices X and Y .

(1)

The PRIMPing Routine

5

Algorithm

LTM
r-LTM
Hyper+
MaxEnt
Asso
Krimp, Slim, SHrimp
Groei
Panda
Mdl4bmf, Nassau
Mdl4bmf, Panda+

f (X, Y, D)

Constraints C
(N = D âˆ’ Î¸(Y X T ))

R

r
âˆ’|Î¸(Y X T )|
|X| + |Y |
ICp (X, Y )
âˆ’
Lp (X, Y )
fRSS (X, Y, D)
fCT (X, Y, D)
fCT (X, Y, D)
fL1 (X, Y, D)
fTXD (X, Y, D)
fTX (X, Y, D)

|N | = 0
|N |âˆ’ = 0
|N |+ = 0, |N |âˆ’ â‰¤ Î²

N
{r}
N

âˆ…

N

âˆ…
|N |âˆ’ = 0
|N |âˆ’ = 0
âˆ…
âˆ…
âˆ…

{r}
N
{r}
{r}
Nâ‰¤min{n,m}
Nâ‰¤min{n,m}

Table 1: Overview of tiling cost measures and implementing algorithms. Nâ‰¤a denotes the set of natural numbers less than or equal to a.

Solving this problem is infeasible in practice as the data generation process is
not invertible. Therefore, an approachable surrogate problem is formulated: the
minimization of a function, which shall, together with suitable constraints on the
result space, indicate the quality of the derived model. In the following, we inspect
how three related research branches formulate and tackle such minimization problems, namely Tiling, the Minimum Description Length principle and Nonnegative
Matrix Factorization.

2.2 Tiling
Tiling addresses the task to find binary matrices which minimize a given cost
measure in a restricted search space. Many cost measures have been formulated
with respect to tiling. Each one defines different criteria of what makes a set of
tiles suitable. We list the most important considerations in Table 1 according to
the following task formalization:
Tiling
Given a binary database D âˆˆ {0, 1}mÃ—n , a set of real-valued functions
c âˆˆ C, a set of natural numbers R and a cost measure f .
Find a tiling
min f (X, Y, D)
(X,Y )

subject to c(X, Y, D) â‰¤ 0, c âˆˆ C
X âˆˆ {0, 1}nÃ—r , Y âˆˆ {0, 1}mÃ—r , r âˆˆ R

We see in Table 1 that many algorithms prohibit negative noise (|N |âˆ’ = 0). We
call such tilings restrained, as the usage of patterns is restrained to the supporting
transactions.
Geerts et al (2004) consider the cost measure as a measure of interestingness
of patterns. In this setting, a tile is determined by its pattern because its usage is

6

Sibylle Hess et al.

identified with all supporting transactions. This implicitly excludes negative noise
but enables the application of pattern-mining techniques in the algorithms LTM
and r-LTM.
Kontonasios and De Bie (2010) and Xiang et al (2011) argue that the integration of negative noise enables more succinct descriptions and makes the tiling
robust to noise. If negative noise is not allowed, every flip of a single bit in the
interior of a tile breaks it into two. Xiang et al (2011) propose with the greedy
algorithm Hyper+ to mine restrained tiles first and to combine them to larger
(noisy) tiles in a second step, as long as a specified amount of negative noise is
not exceeded. Kontonasios and De Bie (2010) propose the information theoretical regulation of noise. The algorithm MaxEnt greedily selects the tile with the
highest information ratio among a set of input candidate tiles. The information
ratio puts the information content ICp (X, Y ) in relation to the description length
Lp (X, Y ) of a tiling, given a maximum entropy distribution p over data matrices.
Both algorithms include negative noise only in a post-processing step and provide
no mechanisms to directly derive suitable unrestrained tiles.
Miettinen et al (2008) strive for direct minimization of the approximation error
under the umbrella term Boolean Matrix Factorization (BMF). They show that
the tiling of rank r which yields the minimum error fRSS (X, Y, D) = |D âˆ’ Î¸(Y X T )|
cannot be approximated within any factor in polynomial time (unless NP = P).
Accordingly, they propose a heuristic to solve this problem. Asso incrementally
creates r tiles by selecting a pattern first and minimizing the error subject to
the usage afterwards. Decisive for the quality of the returned factorization is the
choice of the rank r. To determine this parameter automatically, several algorithms
implement one key paradigm called Minimum Description Length (MDL).

2.3 The MDL Principle
MDL is introduced by Rissanen (1978) as an applicable version of Kolmogorov
complexity (Li 1997; GruÌˆnwald 2007). The learning task to find the best model
according to the MDL principle is given as follows:
Description Length Minimization
Given data D and a set of models M.
Find a model M âˆˆ M for D which minimizes the description length
L(D, M ) = LD (D, M ) + LM (M ),
where LD (D, M ) denotes the compression size of the database in bits
(using model M for the encoding) and LM (M ) is the description size
in bits of the model M itself.
Specifications of this task differ in the definition of the encoding which defines
the set of models M. Typical models for tilings are given by the factorizations
which satisfy the constraints
M = {(X, Y ) âˆˆ {0, 1}nÃ—r Ã— {0, 1}mÃ—r | c(X, Y, N ) â‰¤ 0 âˆ€c âˆˆ C, r âˆˆ R}.
An encoding which is successfully applied in the area of pattern mining and which
we discuss later in the context of tiling, uses code tables as proposed by Siebes et al

The PRIMPing Routine

7

(2006). The code table assigns optimal prefix-free codes to a set of patterns, such
that the code lengths can be calculated without realizations of actual codes. We
imagine the code table two-columned: itemsets are listed on the left and assigned
codes on the right. Such a dictionary from itemsets to code words can be applied
to databases similarly as code words to natural language texts. However, the code
usage is not as naturally defined as for words in a text. Patterns are not nicely
separated by blanks and the possibilities to disassemble a transaction into patterns
are numerous. Therefore, we require for every transaction the indication of its cover
by patterns of the code table. This is modeled by a function cover, which partitions
DjÂ· into patterns of the code table.
Let CT = {(XÏƒ , CÏƒ )|1 â‰¤ Ïƒ â‰¤ Ï„ } be a code table of Ï„ patterns XÏƒ together
with their assigned codes CÏƒ . For any distribution P over a finite set â„¦, an optimal
set of prefix-free codes exists (Cover and Thomas 2006, Theorem 5.4.1) such that
the number of required bits for the code of x âˆˆ â„¦ is approximately
L(code(x)) â‰ˆ âˆ’ log(P (x)).
Desiring that frequently used codes are shorter in size, Siebes et al (2006) introduce
the function usage that maps a pattern to the number of transactions which use
it for their cover, i.e.,
usage(XÏƒ ) = |{XÏƒ âˆˆ cover(CT, DjÂ· ) | j âˆˆ T }|.
The probability mass function over all itemsets XÏƒ in the code table is defined as
P (XÏƒ ) = P

usage(XÏƒ )
.
usage(XÏ )

(2)

1â‰¤Ïâ‰¤Ï„

This implies that L(CÏƒ ) = âˆ’ log P (XÏƒ ). The data matrix is encoded by a transactionwise concatenation of codes, denoted by the cover, i.e., transaction DjÂ· is encoded
by a concatenation of codes CÏƒ with XÏƒ âˆˆ cover(CT, DjÂ· ). Therefore, code CÏƒ
occurs usage(XÏƒ ) times in the encoded dataset. The size of the data description
is thus computed by
X
usage(XÏƒ ) Â· log(P (XÏƒ )).
LD
CT (D, CT ) = âˆ’
1â‰¤Ïƒâ‰¤Ï„

The description of the model, the code table, requires the declaration of codes CÏƒ
and corresponding patterns XÏƒ . Code CÏƒ has a size of âˆ’ log (P (XÏƒ )). A pattern
is described by concatenated standard codes of contained items. Standard codes
arise from the code table consisting of singleton patterns only, where the usage of
singleton {i} for i âˆˆ I is equal to the frequency |DÂ·i |. In conclusion, the description
size of the model is computed as

!
X
X
|DÂ·i |
M
LCT (CT ) = âˆ’
log (P (XÏƒ )) +
log
.
|D|
1â‰¤Ïƒâ‰¤Ï„
usage(XÏƒ )>0

iâˆˆXÏƒ

Note that the function LCT originally uses the logarithm with base two. We implicitly reformulate this description length by substituting with the natural logarithm. This is equivalent to multiplying the function by a constant which is

8

Sibylle Hess et al.

negligible during minimization. In return, using the natural logarithm will shorten
the derivations in Sec. 3.4.
Siebes et al (2006) use a heuristic cover function for the algorithm Krimp
which employs a specified, static order on patterns. The cover function greedily
selects the next pattern in the order which covers items that are not covered yet.
This way, covering patterns must neither overlap nor cover more items than stated
by the transaction. Krimp examines an input set of frequent patterns in another
static order, adding a candidate pattern to the code table whenever that improves
the compression size. Additionally, pruning methods are proposed to correct the
selection of patterns in the code table.
Slim (Smets and Vreeken 2012) differs in its candidate generation, which is
dynamically implemented according to an estimated compression gain and dependent on the current code table. This strategy typically improves the compression
size, but mainly reduces the amount of returned patterns. Still, the number of
considered candidates is extremely large in comparison to those who are accepted.
Time consumption is dominated by computing the usage for each evaluated candidate. SHrimp (Hess et al 2014) exploits the indexing nature of trees in order to
efficiently identify those parts of the database which are affected by an extension
of the code table. Siebes and Kersten (2011) restrict with the algorithm Groei
the code table to a constant number of patterns. They resort to a heuristic beam
search algorithm, but only for tiny datasets, the beam width parameter can be set
to a level allowing a reasonably wide enough exploration of the search space, or
else the run time explodes.
All these algorithms follow the heuristic cover definition of Krimp which prohibits negative noise and tile overlap (we state the function fCT and discuss the
specific relationship between the proposed encoding by code tables and tiling in
Sec. 3.4). Although the employment of code tables is originally motivated as a
methodology to obtain concise and compressing descriptions of the data, the encoding is quite wordy in comparison to the output of unrestrained tiling algorithms, which we discuss in the following section. Nonetheless, attempts to revoke
the restraints of the tiling are not known to us.

2.4 Merging MDL and Tiling
MDLâ€™s incorporated trade-off between model complexity and data fit is apt for
the determination of the factorization rank. Algorithms which determine the rank
according to the MDL principle implement a similar scheme, so far. The costs are
identified with the description length and in every iteration, the rank is increased
as long as this results in decreasing costs. For every considered rank, a factorization (tiling) method is invoked, which usually extends the result from the former
iteration. The performance of this method depends on the choice of factorization
and encoding which determines the description length.
Lucchese et al (2010) propose an encoding as it is known for sparse data representations, describing a matrix only by the positions of ones. Consequently,
the model is described with LM ((X, Y )) = |X| + |Y | bits and the data with
LD (D, (X, Y )) = |D âˆ’ Î¸(Y X T )| bits, up to a multiplicative constant. The resulting cost function is denoted as fL1 (X, Y, D) = |D âˆ’ Î¸(Y X T )| + |X| + |Y |. The

The PRIMPing Routine

9

algorithm Panda uses a factorization method which adds a tile to the current
tiling in a two stage heuristic, comparable to Hyper+.
Miettinen and Vreeken (2014) argue that the encoding used in Panda is too
coarse. They investigate multiple encodings, applying Asso to incrementally increase the factorization rank. Their best-performing encoding is called Typed XOR
DtM encoding. This is based upon the description of n-dimensional binary vectors
by number and distribution of ones. We refer to the Typed XOR DtM description
length as fTXD and to the corresponding algorithm as Mdl4bmf. The experimental evaluation suggests that Mdl4bmfâ€™s rank estimation is accurate in a setting
with moderate noise, i.e., less than 15%, and moderate number of planted tiles,
i.e., less than 15. It seems to have a tendency to underfit, as opposed to Panda,
which returns sometimes ten times more tiles than planted.
On the other hand, the framework of Panda can be applied with an arbitrary
cost measure. Lucchese et al (2014) enhance the algorithm Panda to a faster version Panda+ and evaluate the ability to detect a planted tiling in relation to
different cost measures and algorithms. In their evaluation of synthetically generated datasets with less than 10% equally distributed noise, Panda+ using Typed
XOR costs fTX is outperforming any other choice. The performance is explained
with the objective of Panda+â€™s factorization method, which aims at minimizing
the costs, in contrast to Asso, minimizing only the noise.
Another algorithm which tries to incorporate the direct optimization of the
MDL-cost measure is Nassau (Karaev et al 2015). Remarking that the formerly
proposed algorithms do not reconsider tiles mined at previous iterations, Nassau
refines the whole tiling every few steps in relation to the cost measure. Still, the
incorporated factorization method minimizes solely the factorization error. The
experiments focus on a setting where negative noise is prevalent. In this case,
differences to Mdl4bmf are often hard to capture while Nassau typically outperforms Panda+.

2.5 Nonnegative Matrix Factorization
The Boolean factorization of Eq. (1) has a popular relative called Nonnegative
Matrix Factorization (NMF). Given a nonnegative, real valued matrix D âˆˆ RmÃ—n
+
and
and a rank r âˆˆ N, the goal is to recover nonnegative factors X âˆˆ RnÃ—r
+
mÃ—r
T
Y âˆˆ R+
such that Y X â‰ˆ D. To find the â€œcorrectâ€ factorization, again, several
objective functions and constraints are proposed. Most commonly, the residual
sum of squares (RSS) is minimized

min F (X, Y ) =
X,Y

1
D âˆ’ Y XT
2

2

.

(3)

The function F is nonconvex, but convex in either X or Y , if the other argument
is fixed. That makes it suitable for the Gauss-Seidel scheme, also known as blockcoordinate descent or alternating least squares, an alternating minimization along
one of the matrices while the other one is fixed. That is, a sequence (Xk , Yk ) is

10

Sibylle Hess et al.

created by

Xk+1 âˆˆ arg min F (X, Yk )
X

Yk+1 âˆˆ arg min F (Xk+1 , Y ).

(4)

Y

However, finding a minimum in every iteration is computationally intensive. Thus,
existing algorithms for NMF approximate the scheme of Eq. (4) in several ways (Wang
and Zhang 2013). Often, the minimization step is replaced by a single gradient descent update.
NMF is originally introduced by Paatero and Tapper (1994) under the name
Positive Matrix Factorization. It received much attention since the publication of
the easily implementable multiplicative update algorithm by Lee and Seung (2001).
Their intuitive explanation of coherence between the nonnegativity constraints and
the resulting parts-based explanation of the data (Lee and Seung 1999), emphasizes
the interpretability of the results.
Although initially the difference between NMF and clustering was emphasized
(Lee and Seung 1999), further research affirms inherent clustering properties (Li
and Ding 2006). In this context, columns of X equate cluster centroids and corresponding columns of Y indicate cluster membership tendencies. Restricting Y to
a binary matrix makes the memberships definite and the orthogonality constraint
Y T Y = I enforces unique cluster assignments. This factorization task is actually
equivalent to k-means (Ding et al 2005, 2006; Bauckhage 2015). If the data matrix is binary, a binary factorization is also desirable, at least to get interpretable
results for the cluster centroids (Li 2005). In this way, the factorization can be
read as a clustering of items, or by using the transposed product, as a clustering
of transactions. This is also known under the terms biclustering, co-clustering or
subspace clustering.
To the best of our knowledge, Zhang et al (2007) are the only ones approaching
the task of biclustering in conjunction with alternating minimization, the standard
procedure to solve NMF. They propose two methods: the first one uses gradient
descent updates with the longest step size preserving nonnegativity of the factor
matrices and integrates the penalization of non-binary values into the minimization
of the factorization error. As penalizing function, they choose the Mexican hat
function Ï‰(x) = 21 (x2 âˆ’ x)2 . The second method is designed to find the threshold
at which nonnegative factor matrices might be rounded best to binary matrices.
Although these methods have several drawbacks (the former lacks a convergence guarantee and the latter applies a costly backtracking linesearch), the results are very promising in comparison to common greedy biclustering algorithms.
However, this branch of research is considered to be substantially different from
its formulation in Boolean algebra (Miettinen and Vreeken 2014; Lucchese et al
2014). Indeed, the numerical optimization of the binary factorization is not easily
adopted for multiplications in Boolean algebra Î¸(Y X T ); Î¸ has a point of discontinuity at 0.5. Equally, all proposed cost measures in Table 1 are not continuous
for real valued matrices with entries in [0, 1].

The PRIMPing Routine

11

3 Merging Tiling, MDL, and NMF
We wish to find a way out of the greedy minimization of tiling cost measures
and ask to which extent the theory behind popular NMF optimization methods
may be applied to Boolean matrix factorizations. In conclusion, we propose an
adaption of the Gauss-Seidel method to minimize a suitable relaxation of tiling
cost measures. Similar to the thresholding algorithm of Zhang et al (2007), the
matrices are rounded according to the actual cost measure afterwards. Moreover,
we incorporate the determination of the factorization rank, utilizing that the cost
measure may select fewer tiles than offered.
With our ambition to adapt the alternating minimization for Boolean matrix
factorization, we face two problems: First, as mentioned above, the use of Boolean
algebra induces points of discontinuity. In particular, the gradient of the cost
measures does not exist at all points which hinders the application of standard
gradient descent methods. Second, many tiling cost measures are not convex in X
or Y , not even if the other argument is fixed, which is a necessary condition to
prove the convergence of the Gauss-Seidel scheme.
To begin with, we inspect how NMF (Eq. (3)) and BMF deal with overlapping
tiles. This is the crucial point where Boolean algebra diverges from elementary algebra. An illustration of a binary data matrix D consisting of two overlapping tiles
and its approximation by a NMF is shown in the top two equations of Fig. 3. We
see that the factors contain values smaller than one at entries which are involved in
overlapping parts. With this, overlapping sections are equally well approximated
as non-overlapping components. The matrices DA and DB in Fig. 3 show the
resulting approximations when the nonnegative factor matrices are rounded to
binary matrices. We find that the reconstruction error is largest when the binary
matrices are multiplied in elementary algebra (matrix DA in Fig. 3). This illustrates how binary matrix factorization penalizes overlapping patterns, a feature
which is desirable in clustering when clusters are not allowed to overlap. Similarly,
NMF would return less overlapping factors at a higher factorization rank. In this
case, however, the original data matrix is exactly reconstructed by the Boolean
product of thresholded factor matrices (matrix DB in Fig. 3). That is why we consider the minimization of a relaxed cost measure with respect to the elementary
algebra whereby the factorization rank is increased stepwise. An evaluation of the
actual cost measure in Boolean algebra on the rounded matrices decides whether
the rank shall be increased or not.
This leads us to the second concern, the minimization of a possibly not even
partially convex objective. Bolte et al (2014) extend the application of the GaussSeidel scheme to such a larger class of functions with the Proximal Alternating
Linearized Minimization (PALM). This technique focuses on objective functions
which break down into a smooth part F : RnÃ—r Ã— RmÃ—r Ã— RmÃ—n â†’ R and a
nonsmooth component Ï† : {X âˆˆ RmÃ—n |m, n âˆˆ N} â†’ (âˆ’âˆž, âˆž]
F (X, Y, D) + Ï†(X) + Ï†(Y ).

(5)

Thereby, no convexity assumptions are made on F and Ï†. Furthermore, the function Ï† may return âˆž, which can be used to model restrictions of the search space,
e.g., the non-negativity constraint of NMF. The method performs an alternating
minimization on the linearized objective, substituting F with its first order Taylor

12

Sibylle Hess et al.

ï£«

ï£¶ ï£«
ï£¶
ï£¬ 1 1 1 0 ï£· ï£¬ 1 .9 .9 .1 ï£·
ï£· ï£¬
ï£·
D=ï£¬
ï£­ 1 1 1 1 ï£¸ â‰ˆ ï£­ .7 1.2 1.2 .7 ï£¸
0 1 1 1
.1 .9 .9 1
ï£«
ï£¶
ï£«
1
0
ï£¬
ï£·
ï£· ï£­ 1 .9
â‰ˆï£¬
ï£­ .6 .6 ï£¸ Â·
.1 .9
0 1
ï£«
ï£¶
ï£«
ï£¶
ï£«
ï£¬ 1 1 1 0 ï£·
ï£¬ 1 0 ï£·
ï£·
ï£¬
ï£· ï£­ 1
DA = ï£¬
ï£­ 1 2 2 1 ï£¸ = Î¸ ï£­ .6 .6 ï£¸ Â· Î¸
.1
0 1
0 1 1 1
ï£« ï£«
ï£«
ï£¶
ï£¶
ï£«
ï£¬ ï£¬ 1 0 ï£·
ï£¬ 1 1 1 0 ï£·
ï£¬
ï£¬
ï£·
ï£¬
ï£·
DB = ï£­ 1 1 1 1 ï£¸ = Î¸ ï£­Î¸ ï£­ .6 .6 ï£¸ Â· Î¸ ï£­
0 1 1 1
0 1

ï£¶
.9 .1 ï£¸
.9 1
ï£¶
.9 .9 .1 ï£¸
.9 .9 1
ï£¶

ï£¶

1 .9 .9 .1 ï£¸ï£·
ï£·
ï£¸
.1 .9 .9 1

Fig. 3: Approximation of a binary matrix D with two overlapping tiles (top) applying NMF (second from above) and the factorizations resulting from thresholding
the factor matrices to binary matrices in elementary algebra (second from below)
and Boolean algebra (below). Tiles are highlighted.

approximation. This is achieved by alternating proximal mappings from the gradient descent update with respect to F , i.e., the following steps are repeated for
1 â‰¤ k â‰¤ K:
Xk+1 = proxÎ±k Ï† (Xk âˆ’ Î±k âˆ‡X F (Xk , Yk , D));

(6)

Yk+1 = proxÎ²k Ï† (Yk âˆ’ Î²k âˆ‡Y F (Xk+1 , Yk , D)).

(7)

The proximal mapping of Ï†, proxÏ† : dom(Ï†) â†’ dom(Ï†)1 is a function which
returns a matrix satisfying the following minimization criterion:


1
? 2
?
proxÏ† (X) âˆˆ arg min
kX âˆ’ X k + Ï†(X ) .
2
X?
Loosely speaking, the proximal mapping gives its argument a little push into a
direction which minimizes Ï†. For a detailed discussion, see, e.g., (Parikh and Boyd
2014). As we can see in Eqs. (6) and (7), the evaluation of this operator is a
base operation. Similarly to the alternating minimization in Eq. (4), finding the
minimum of the proximal mapping in every iteration by numerical methods is
infeasible in practice. Thus, the trick is to use only simple functions Ï† for which
the proximal mapping can be calculated in a closed form.
The variables Î±k and Î²k in Eqs. (6) and (7) are the step sizes, which are
computed under the assumption that the partial gradients âˆ‡X F and âˆ‡Y F are
globally Lipschitz continuous with moduli Mâˆ‡X F (Y ) and Mâˆ‡Y F (X), i.e.,
kâˆ‡X F (X1 , Y, D) âˆ’ âˆ‡X F (X2 , Y, D)k â‰¤ Mâˆ‡X F (Y )kX1 âˆ’ X2 k
1

dom(Ï†) is the domain of Ï†

The PRIMPing Routine

13

for all X1 , X2 âˆˆ RnÃ—r and similarly for âˆ‡Y F . If F computes the RSS as stated in
Eq. (3), the Lipschitz moduli are given as
Mâˆ‡X F (Y ) = kY Y T k,

Mâˆ‡Y F (X) = kXX T k.

The step sizes are computed as
Î±k =

1
,
Î³Mâˆ‡X F (Yk )

Î²k =

1
,
Î³Mâˆ‡Y F (Xk+1 )

where Î³ is a constant larger than one. The parameter Î³ ensures that the step size is
indeed smaller than the inverse Lipschitz constant, which is required to guarantee
the convergence. Note that the step sizes are antimonotonic to Î³, i.e., if Î³ = 2
then the step sizes are almost half as small as they could be. Assuming that the
infimum of F and Ï† exists and Ï† is proper and lower continuous, PALM generates
a nonincreasing sequence of function values which converges to a critical point.

3.1 PAL-Tiling: General Framework
We employ the optimization scheme PALM to minimize a specified relaxation of
a tiling cost measure. Adapting to the terminology of Eq. (5), we assume that for
a factor Âµ â‰¥ 0 and regularizing function G the relaxation has the form
F (X, Y, D) =

Âµ
1
kD âˆ’ Y X T k2 + G(X, Y ).
2
2

(8)

Here the multiplication by one half refers to the traditional formulation of the
residual sum of squares in Eq. (3), which shortens the formulation of gradients.
The regularizing function G is supposed to be real valued and smooth with partial
gradients which are Lipschitz-continuous with moduli Mâˆ‡Y G (X) and Mâˆ‡X G (Y ).
That is,
kâˆ‡X G(X1 , Y ) âˆ’ âˆ‡X G(X2 , Y )k â‰¤ Mâˆ‡X G (Y )kX1 âˆ’ X2 k,
and similarly for âˆ‡Y G. It follows from the triangle inequality that the Lipschitz
moduli of the partial gradients of F are given by the sum
1
Mâˆ‡X F (Y ) = ÂµkY Y T k + Mâˆ‡X G (Y )
2
1
Mâˆ‡Y F (X) = ÂµkXX T k + Mâˆ‡Y G (X).
2
We use the function Ï†, which is integrated into the objective function as stated in
Eq. (5), to limit the matrix entries to the interval [0, 1], i.e., X âˆˆ [0, 1]nÃ—r and Y âˆˆ
[0, 1]mÃ—r . As discussed by Zhang et al (2007), this prevents an imbalance between
the factor matrices in which one matrix is very sparse and the other very dense.
Apart from that, we wish that the relaxed optimization returns factor matrices
which are as close to binary matrices as possible. Therefore, we incorporate penalty
terms for non-binary matrix entries in the function Ï†. Choosing Ï† as a proper and
lower semicontinuous function (to be defined in Sec. 3.2), the objective meets
the requirements of PALM to guarantee the convergence to a critical point in a
nonincreasing sequence of iterative function values.

14

Sibylle Hess et al.

Algorithm 1 Proximal Alternating Linearized Tiling
1: function PAL-Tiling(D, âˆ†r , K, T, Î³ = 1.00001)
2:
(XK , YK ) â† (âˆ…, âˆ…)
3:
for r âˆˆ {âˆ†r , 2âˆ†r , 3âˆ†r , . . .} do
4:
(X0 , Y0 ) â†IncreaseRank(XK , YK , âˆ†r )
. Append âˆ†r random columns
5:
for k âˆˆ {0, . . . , K âˆ’ 1} do
6:
Î±âˆ’1
k â† Î³Mâˆ‡X F (Yk )
7:
Xk+1 â† proxÎ±k Ï† (Xk âˆ’ Î±k âˆ‡X F (Xk , Yk , D))
8:
Î²kâˆ’1 â† Î³Mâˆ‡Y F (Xk+1 )
9:
Yk+1 â† proxÎ²k Ï† (Yk âˆ’ Î²k âˆ‡Y F (Xk+1 , Yk , D))
10:
end for
11:
(X, Y ) â† arg min{f (Î¸x (XK ), Î¸y (YK ))|x, y âˆˆ T }
. Threshold to binary matrices
12:
if r âˆ’ r(X, Y ) > 1 then
13:
return (X, Y )
14:
end if
15:
end for
16: end function

We sketch our method, Proximal Alternating Linearized Tiling (PAL-Tiling),
in Algorithm 1. A data matrix D, rank increment âˆ†r , maximum number of iterations K, a set of threshold values T and the parameter Î³, having a default
value of Î³ = 1.00001, are the input of this algorithm. For every considered rank,
we perform the proximal alternating linearized minimization of the relaxed objective (line 5-10). After the numerical minimization of the relaxed objective F ,
the matrices XK and YK , having entries between zero and one, are rounded to
binary matrices X and Y with respect to the actual cost measure f (line 11). If the
rounding procedure returns binary matrices which use at least one (non-singleton)
pattern less than possible, the current factorization is returned. Otherwise, we increase the rank and add âˆ†r random columns with entries between zero and one
to the relaxed solution of the former iteration (XK , YK ).
To apply this scheme, we need to define the penalizing function Ï†, derive its
proximal mapping in a closed form and find a suitable cost measure with its smooth
relaxed approximation.

3.2 Penalizing Non-Binary Values
While the Mexican hat function can be seen as an L2 regularization equivalent
penalizer for binary
P values, here, we choose an L1-equivalent form. Specifically, we
choose Ï†(X) = i,j Î›(Xij ), which employs the one-dimensional function
(
âˆ’|1 âˆ’ 2x| + 1 x âˆˆ [0, 1]
Î›(x) =
âˆž
otherwise.
to restrict matrix entries to the interval [0, 1] and to penalize non-binary values.
The curve of Î› is depicted in Fig. 4. We derive with the following proposition a
closed form for the computation of the exact minimum as assigned by the proximal
mapping with respect to Ï†.
P
Theorem 1 Let Î± > 0 and Ï†(X) = i,j Î›(Xij ) for X âˆˆ RmÃ—n . The proximal
operator of Î±Ï† maps the matrix X to the matrix proxÎ±Ï† (X) = A âˆˆ [0, 1]mÃ—n

The PRIMPing Routine

15

1

Î›(x)

0.5

0

0.2

0.4

0.6

0.8

1

Fig. 4: The function Î› penalizing non-binary values.
defined by Aji = proxÎ±Î› (Xji ), where for x âˆˆ R it holds that
(
max{0, x âˆ’ 2Î±} x â‰¤ 0.5
proxÎ±Î› (x) =
min{1, x + 2Î±} x > 0.5.

(9)

This enables a minimization according to the cost measure of Asso, setting
G(X, Y ) = 0. However, without a generalizing term it is unlikely that the rank is
properly identified; the loss function certainly attains a minimum when one of the
factor matrices is equal to the data matrix and the other one is the identity. Thus,
we seek cost measures which are suitable for a minimization within PAL-Tiling
and whose application results in an algorithm which is capable to identify the
correct rank.
3.3 Panpal
The cost measure fL1 (as applied by Panda) can easily be integrated into PALTiling. Since the proximal operator ensures that the factor matrices in all steps
have values between zero and one, the L1-norm of the factor matrices equates a
simple summation over all matrix entries. Thus, the L1-norm is a smooth function
on the nonnegative domain of the factor matrices and can be used as regularizing
function. We call the resulting algorithm Panpal as it employs the cost measure
of Panda in the minimization technique PAL-Tiling:
Panpal: Apply PAL-Tiling with
â€“ Cost measure
fL1 (X, Y, D) = |D âˆ’ Y X T | + |X| + |Y |
â€“ Relaxed objective
F (X, Y, D) =

1
1
kD âˆ’ Y X T k2 + (|X| + |Y |)
2
2

â€“ Partial Gradients
âˆ‡X F (X, Y, D) = (Y X T âˆ’ D)T Y + (0.5)is
âˆ‡Y F (X, Y, D) = (Y X T âˆ’ D)X + (0.5)js
â€“ Lipschitz moduli
Mâˆ‡X F (Y ) = kY Y T k
Mâˆ‡Y F (X) = kXX T k

16

Sibylle Hess et al.

3.4 Primp
So far, the cost measure of Krimp has been disregarded in the context of Boolean
matrix factorization. Since the traditionally employed cover function is incompatible with overlapping patterns or patterns which cover more items than persistent
in the transaction, the task to find the best encoding by code tables is associated
with the sub-domain of pattern mining (Miettinen and Vreeken 2014; Lucchese
et al 2014; Karaev et al 2015). The definition of the long-established cover function is heuristically determined under the assumption that there is one globally
valid cover function which is applicable on all datasets if a suitable code table is
found. Although this approach might be favorable in sub-domains like classification or detection of changes in a data stream (Vreeken et al 2011; Van Leeuwen
and Siebes 2008), it is current best practice in the domain of tiling to take negative
noise into account (see Sec. 2.2). Thus, we break away from the conventional view
on the cover function as a predefined instance and regard it as an extrapolation
of the mapping from patterns to transactions which is defined by the matrix Y .
Thereby, we intend to learn a suitable pair of code table and cover function for
every dataset. This is motivated by the following observation.
Lemma 1 Let D be a data matrix. For any code table CT and its cover function
there exists a Boolean matrix factorization D = Î¸(Y X T ) + N such that nonsingleton patterns in CT are mirrored in X and the cover function is reflected by
Y . The description lengths correspond to each other, such that
D
M
LCT (D, CT ) = fCT (X, Y, D) = fCT
(X, Y, D) + fCT
(X, Y, D),

where the functions returning the model and the data description size are given as
D
fCT
(X, Y, D) = âˆ’

=
M
fCT
(X, Y, D)

=

r
X

|YÂ·s | Â· log(ps ) âˆ’

s=1
D
LCT (D, CT )



X

n
X

|NÂ·i | Â· log(pr+i )

i=1


T
XÂ·s
c âˆ’ log(ps ) +

s:|YÂ·s |>0

X

(ci âˆ’ log(pr+i ))

i:|NÂ·i |>0

= LM
CT (CT ).
The probabilities ps and pr+i indicate the relational usage of non-singleton patterns
XÂ·s and singletons {i},
ps =

|YÂ·s |
|NÂ·i |
, pr+i =
.
|Y | + |N |
|Y | + |N |

We denote with c âˆˆ Rn
+ the vector of standard code lengths for each item, i.e.,


|DÂ·i |
.
ci = âˆ’ log
|D|
The proof of this lemma can be found in Appendix B. We remark that this
formulation also puts new emphasis on the debate about the model definition in
this MDL application. As commented by Siebes and Kersten (2011), the cover
function actually is a part of the model and if we learn the cover function together

The PRIMPing Routine

17

with the code table, an encoding of the data is not possible if only the code table
is present. However, to be in line with common practice in the field we stick with
the description length computation as originally proposed by Siebes et al (2006),
which is also used in Lemma 1 and makes our results comparable to previously
published results.
The transfer from a code table encoding to a Boolean matrix factorization provides another view on the objective of Krimp-related algorithms. While the focus
of matrix factorizations lies on the extraction of a given ground truth, the originally formulated task aims at the derivation of subjectively interesting patterns â€“
equating interestingness with the ability to compress. Moreover, the tiling derived
by Boolean matrix factorizations obliges certain requirements such as the linear
independence of columns/rows and the bound on the rank (r â‰¤ min{m, n}) which
follows from that.
Considering, in reverse, the transfer from a matrix factorization to an encoding
by code tables, we naturally receive access to the treatment of negative noise.
We can calculate the description size fCT for arbitrary factor matrices, even if
the resulting noise matrix contains negative entries. Yet, the question arises if
this also has a suitable interpretation with regard to the encoding. In fact, the
interpretation is simple: the items having a negative noise entry can be transmitted
just as the items with positive noise entries; their singleton codes are appended
to the belonging transaction. If the item is not covered by any other pattern used
in this transaction, then it belongs to a positive noise entry and otherwise to a
negative one. We obtain therewith a description length equal to fCT . That is,
each transaction DjÂ· is described by the code concatenation of patterns XÂ·r where
Yjr = 1 and the singleton codes of items i having Nji 6= 0.
However, the compression size fCT (X, Y, D) is not continuous. There are points
of discontinuity at encodings which do not use a pattern present in X or one of
the singletons. To approximate this function as required in PAL-Tiling (Eq. (5)),
we assume that each pattern in X is used at least once. For singletons, we do not
wish to make such an assumption; usages of singletons are reflected in the noise
matrix and we want to keep the noise as small as possible. Therefore, we bound
the description size which is induced by singletons by the RSS. Then, we obtain a
smooth function which meets the requirements of PAL-Tiling. This is specified
by the following theorem whose proof can be found in Appendix C.
Theorem 2 Given binary matrices X and Y and Âµ = 1 + log(n), it holds that


r
X
|YÂ·s | + 1
D
T 2
fCT (X, Y, D) â‰¤ ÂµkD âˆ’ Y X k âˆ’
(|YÂ·s | + 1) log
+ |Y |
(10)
|Y | + r
s=1
So far, this bound encompasses the description size of the data, yet the description size of the model is also discontinuous at points where one of the patterns is
not used at all. The description size of one side of the code table, representing the
patterns by standard singleton codes c, computed by
|X T c| =

r
X
s=1

T
XÂ·s
câ‰¥

X

T
XÂ·s
c,

s:|YÂ·s |>0

can easily be integrated into the smooth approximation. The matrix X and the
standard code sizes ci contain only nonnegative entries, thus the computation of

18

Sibylle Hess et al.

the L1-norm boils down to a summation over all entries in the vector X T c. The
remaining terms which compose the model complexity are bounded above by a
constant, due to the fixation of the rank during the minimization of the relaxed
objective. Thus, we minimize the relaxed function as denoted in the box below.
The required Lipschitz constants are computed in Appendix D. We refer to this
algorithm as Primp, as it performs PAL-Tiling with the objective of Krimp.
Primp: Apply PAL-Tiling with
â€“ Constants

c = (ci )iâˆˆI , ci = âˆ’ log

|DÂ·i |
|D|



Âµ = 1 + log(n)
â€“ Cost measure
fCT (X, Y, D)
â€“ Relaxed objective
Âµ
1
kD âˆ’ Y X T k2 + G(X, Y )
2
2


r
X
|YÂ·s | + 1
G(X, Y ) = âˆ’
(|YÂ·s | + 1) log
+ |X T c| + |Y |
|Y
|
+
r
s=1

F (X, Y, D) =

â€“ Partial Gradients
âˆ‡X F (X, Y, D) = Âµ(Y X T âˆ’ D)T Y + c(0.5)T
s
 

1
|YÂ·s | + 1
âˆ‡Y F (X, Y, D) = Âµ(Y X T âˆ’ D)X âˆ’
+ (0.5)js
log
2
|Y | + r
js
â€“ Lipschitz moduli
Mâˆ‡X F (Y ) = ÂµkY Y T k
Mâˆ‡Y F (X) = ÂµkXX T k + m

4 Experiments
We conduct experiments on a series of synthetic data matrices, exploring the
ability to detect the planted tiling, i.e., to recover generated matrices X and Y in
presence of various noise structures. In real-world data experiments we compare
the costs of obtained models in various measures. Also, we perform a qualitative
evaluation of the factor methods, visualizing the algorithmsâ€™ understanding of
tiles and noise on the basis of images. We compare the PAL-Tiling instances
Panpal and Primp with the available implementations of PaNDa+2 , Mdl4bmf3
2
3

http://hpc.isti.cnr.it/~claudio/web/archives/20131113/index.html
http://people.mpi-inf.mpg.de/~skaraev/

The PRIMPing Routine

19

and Nassau3 . Concerning Panpal and Primp, we apply K = 50, 000 iterations
and try thresholds with step size 0.05, i.e., T = {0.05k | k âˆˆ {0, 1, . . . , 20}}.
We apply the same set of thresholds T to Mdl4bmf, which is also the average
increment used in experiments by Miettinen and Vreeken (2014); Lucchese et al
(2014); Karaev et al (2015). For Panda+ we choose the TypedXOR measure and
use 20 randomization rounds and correlating items as suggested in the literature
Lucchese et al (2014). Apart from that, the default settings apply.
We exclude Slim from our experiments as it can not be fairly compared to
Boolean matrix factorization algorithms. To illustrate, Slim returns far more patterns (500 to 3000 monotonically increasing with noise) than planted (25) in our
synthetic data sets. Hence, a depiction of this algorithmâ€™s rank would distort the
rank charts due to its unreasonable performance.
For synthetic and real world experiments, we set the rank increment âˆ†r = 10;
sensitivity to this parameter is explored in Sec. 4.5. For our image evaluation, we
set (if possible) a maximum number of 10 returned tiles and depict the four most
informative tiles. Here, we set âˆ†r = 1, to consistently allow for more factorization
rounds in case of higher estimated rank.
A separate run time comparison of the aforementioned algorithms is not conducted. This is because we can not guarantee that the underlying data structures and platform specific optimizations are equally well tuned, especially for
the approaches for which we make use of the reference implementation (Panda+,
Mdl4bmf and Nassau). Note, however, that due to the formulation of PALTiling in terms of linear algebra, a highly parallel implementation on graphics
processing units (GPU) is straightforward. Therefore, experiments regarding Panpal and Primp are executed on a GPU with 2688 arithmetic cores and 6GiB
GDDR5 memory. The run time of the GPU based algorithms is about 50 times
lower, compared to the ordinary implementations, e.g., a task that is finished by
Primp in a few seconds, requires 30 minutes by Mdl4bmf. We provide the source
code of our algorithms together with the data generating script4 .

4.1 Synthetic Data Generation
We generate data matrices according to the scheme established by Miettinen and
Vreeken (2014); Karaev et al (2015) and Lucchese et al (2014). Yet, we constrain
the set of generated factor matrices to contain at least one percent of uniquely
assigned ones to ensure linear independence of column? vectors. This ensures? that
for r? â‰¤ n, m and generated matrices X ? âˆˆ {0, 1}nÃ—r and Y ? âˆˆ {0, 1}mÃ—r , the
matrix D = Y ? X ?T indeed has rank r? . We describe the data generation process
as a function from dimensions n and m, rank r? , density parameter q and noise
probabilities p+ and pâˆ’ .
GenerateData(n, m, r? , q, p+ , pâˆ’ )
4

http://sfb876.tu-dortmund.de/primp

20

Sibylle Hess et al.
Variation

p+ [%]

pâˆ’ [%]

r

q

Density [%]

Overlap [%]

Uniform Noise

0
25

0
25

25
25

0.1
0.1

6.6 Â± 0.8
28.3 Â± 0.4

2.3 Â± 0.3
2.3 Â± 0.3

Pos/Neg Noise

25
3

3
25

25
25

0.1
0.1

30.6 Â± 0.4
8.5 Â± 0.4

3.0 Â± 0.4
2.9 Â± 0.5

Rank

10
10

10
10

5
45

0.1
0.1

11.3 Â± 0.4
18.6 Â± 0.9

0.3 Â± 0.2
8.7 Â± 1.0

Density

10
10

10
10

25
25

0.1
0.3

15.3 Â± 0.6
40.6 Â± 4.3

2.3 Â± 0.3
26.9 Â± 6.1

Table 2: Characteristics of generated datasets. The values are aggregated over
eight generated datasets, four for each combination of dimensions (n, m) âˆˆ
{(500, 1600), (800, 1000)}. Overlap denotes the percentage of overlapping entries
in relation to the region covered by all tiles together and density is the region
covered by all tiles together in relation to nm.
n
m
1. Set k = d 100
e and l = d 100
e. Let 1k and 1l denote the k- and l-dimensional
vector filled with ones. Draw factor matrices of the form
ï£¶
ï£«
ï£¶
ï£«
1l
1k
0
0
ï£·
ï£¬ ..
ï£·
ï£¬ ..
ï£·
ï£¬
ï£·
ï£¬
.
.
ï£·
ï£¬
ï£·
ï£¬
ï£¬
ï£·
ï£¬0
?
?
1l ï£·
1k ï£· , Y = ï£¬ 0
X =ï£¬
ï£·,
ï£¬|
ï£¬ |
| ï£·
| ï£·
ï£·
ï£¬
ï£·
ï£¬
ï£­y1 Â· Â· Â· yr? ï£¸
ï£­x1 Â· Â· Â· xr? ï£¸
|
|
|
|

where we draw for 1 â‰¤ s â‰¤ r? , nÌƒ = n âˆ’ kr? and mÌƒ = m âˆ’ lr?
â€“ xs âˆˆ {x âˆˆ {0, 1}nÌƒ | |x| â‰¤ bqnÌƒc} uniformly random
â€“ ys âˆˆ {y âˆˆ {0, 1}mÌƒ | |y| â‰¤ bq mÌƒc} uniformly random
2. Set D = Y ? X ?T + N with noise matrix N generated by the following
scheme
â€“ If Dji = 0 then Nji = 1 with probability p+
â€“ If Dji = 1 then Nji = âˆ’1 with probability pâˆ’
We generate datasets for distinct settings with dimensions (n, m) âˆˆ {(500, 1600),
(1600, 500), (800, 1000), (1000, 800)}, r âˆˆ [5, 25], q âˆˆ [0.1, 0.3] and pÂ± âˆˆ [0, 25].
Table 2 summarizes the basic statistics of the generated datasets.

4.2 Measuring the Tiling Quality
We quantify how well a computed tiling (X, Y ) matches the planted tiling (X ? , Y ? )
by an adaptation of the micro-averaged F-measure, known from multi-class clas?T
sification tasks. In this regard, we identify a planted tile YÂ·s? XÂ·s
with a class
which contains the tuples (j, i) which indicate ones. Then, a suitable one-to-one
matching Ïƒ between computed and planted tiles allows to compare the true la?
?T
bels Yjs
Xis
with the predicted labels YjÏƒ(s) XiÏƒ(s) T . Therewith, we can naturally
calculate precision and recall and finally the F -measure.

The PRIMPing Routine

21

We assume w.l.o.g. that X, X ? âˆˆ {0, 1}nÃ—r and Y, Y ? âˆˆ {0, 1}nÃ—r , otherwise
we attach zero columns to the matrices such that the dimensions match. We compute with the Hungarian algorithm (Kuhn 1955) a permutation Ïƒ : {1, .P
. . , r} â†’
{1, . . . , r} which matches computed and planted tiles one-to-one such that rs=1 Fs,Ïƒ(s)
is maximized. The Fs,t -measure is calculated for 1 â‰¤ s, t â‰¤ r by
Fs,t = 2

pres,t Â· recs,t
,
pres,t + recs,t

?
where pres,t and recs,t denote precision and recall between the planted tile (XÂ·s
, YÂ·s? )
and computed tile (XÂ·t , YÂ·t )

pres,t =

?
|(YÂ·s? â—¦ YÂ·t )(XÂ·s
â—¦ XÂ·t )T |
T|
|YÂ·t XÂ·t

recs,t =

?
|(YÂ·s? â—¦ YÂ·t )(XÂ·s
â—¦ XÂ·t )T |
.
?T|
|YÂ·s? XÂ·s

Having computed the perfect matching Ïƒ, we calculate precision and recall for the
obtained factorization by
Pr
?
|(Y ? â—¦ YÂ·Ïƒ(Â·) )(X ? â—¦ XÂ·Ïƒ(Â·) )T |
|(YÂ·s? â—¦ YÂ·Ïƒ(s) )(XÂ·s
â—¦ XÂ·Ïƒ(s) )T |
Pr
pre = s=1
=
T
|Y X T |
s=1 |YÂ·s XÂ·s |
Pr
?
|(Y ? â—¦ YÂ·Ïƒ(Â·) )(X ? â—¦ XÂ·Ïƒ(Â·) )T |
|(YÂ·s? â—¦ YÂ·Ïƒ(s) )(XÂ·s
â—¦ XÂ·Ïƒ(s) )T |
=
rec = s=1
.
Pr
T
?
?
|Y ? X ? T |
s=1 |YÂ·s XÂ·s |
The micro F -measure is defined in terms of precision and recall as defined above.
This is equivalent to a convex combination of the Fs,Ïƒ(s) -measurements:

F =2

T
?T
r
+ YÂ·Ïƒ(s) XÂ·Ïƒ(s)
YÂ·s? XÂ·s
X
pre Â· rec
Fs,Ïƒ(s) .
=
pre + rec s=1
Y ? X ? T + |Y X T |

The F -measure has values between zero and one. The closer it approaches one,
the more accurate the obtained tiling is. The plots which display the F -measure
indicate the average value with error bars having the length of twice the standard
deviation.
We express the values of involved cost measures in relation to the empty model
%f (X, Y, D) =

f (X, Y, D)
Â· 100.
f (0n , 0m , D)

4.3 Make some Noise
In the following series of experiments, varying the noise, we plot the F -measure
and the rank of the returned tiling against the percentage of noise which is added.
The planted factorization has a rank of r? = 25 and density parameter q = 0.1.
The noise level varies from 0% to 25% as displayed on the x-axis.
First, we compare the effects of the matrix dimensions and aggregate results
over 10 generated matrices with dimensions 800 Ã— 1000 and 500 Ã— 1600 together
with their transpose, as depicted in Figs. 5 and 6. Comparing the results for a data
matrix and its transpose is particularly interesting for the algorithm Primp. Since
it applies different regularizations on X and Y , we want to asses how this affects

22

Sibylle Hess et al.

F

D âˆˆ {0, 1}800Ã—1000
1

1

0.5

0.5

0

0
0

r(X, Y )

DT âˆˆ {0, 1}1000Ã—800

10

20

0

40

40

30

30

20

20

10

10

10

20

0

0
0

10
p+ = pâˆ’ [%]
Primp

Panpal

20

0

Panda+

10
p+ = pâˆ’ [%]
Nassau

20

Mdl4bmf

Fig. 5: Variation of uniform noise for 800 Ã— 1000 and 1000 Ã— 800 dimensional
data. Comparison of F -measures (the higher the better) and the estimated rank
of the calculated tiling (the closer to 25 the better) for varying levels of noise, i.e.,
p+ = pâˆ’ is indicated on the x-axis (best viewed in color).

the results of Primp in practice. The remaining algorithms minimize an objective
which is invariant to a transposition of the input matrix. It is desirable that this
is also reflected in practice.
We observe from Figs. 5 and 6 that the algorithms likely return fewer tiles
the more the noise increases. This culminates in the replication of almost none of
the tiles at highest noise level for the algorithms Panda+ and Nassau. Nassau
particularly strongly underestimates the rank if the data matrix is transposed, i.e.,
n > m. In this case, Nassau returns close or equal to zero tiles, even if the noise is
low. Panda+ yields correct rank estimations up to a noise of 15%, but its fluctuating F -measure indicates that planted tiles are not correctly recovered after all. In
particular, its F -values differ from the untransposed to the transposed case even if
the rank estimations are similar and close to r? . Mdl4bmf shows a robust behavior towards a transposition of the the input matrix. Its suitable rank estimations
up to a noise of 15% are mirrored in a high F -measure. Panpal consistently underestimates the rank, yet can achieve comparatively high F -measures. Its results
exhibit minor deviations from the untransposed to the transposed case. Recognizable differences occur when n and m differ more widely (Fig. 6) and the noise
level is low. Under these circumstances, Panpal yields higher rank estimations if
the matrix is transposed. We note, that the code of PAL-Tiling and therewith
also the code of Panpal inhibits only one distinction between X and Y , which
is the order in which gradient steps are invoked. Whether this actually influences
the output of the algorithm is an interesting question but it is beyond the scope

The PRIMPing Routine

23

F

D âˆˆ {0, 1}500Ã—1600
1

1

0.5

0.5

0

0
0

r(X, Y )

DT âˆˆ {0, 1}1600Ã—500

10

20

0

40

40

30

30

20

20

10

10

0

10

20

0
0

10
p+ = pâˆ’ [%]
Primp

Panpal

20

0

Panda+

10
p+ = pâˆ’ [%]
Nassau

20

Mdl4bmf

Fig. 6: Variation of uniform noise for 500 Ã— 1600 and 1600 Ã— 500 dimensional
data. Comparison of F -measures (the higher the better) and the estimated rank
of the calculated tiling (the closer to 25 the better) for varying levels of noise, i.e.,
p+ = pâˆ’ is indicated on the x-axis (best viewed in color).

of this paper. Primp is characterized by overall high values in the F -measure.
It has a tendency to estimate the rank higher in the untransposed case, i.e., if
m > n. This is particularly notably if the matrices are almost square (Fig. 5).
This suggests that the cost measure favors modeling tiles having fewer items and
more transactions. That aside, the overall high F -measure shows that additionally
modeled tiles cover only a small area in comparison to planted ones.
In Fig. 7 we contrast varying distributions of positive and negative noise (p+
and pâˆ’ ). From here on, we aggregate results over eight matrices, two for each of
the considered matrix dimensions. However, we make an exception for Nassau
and transpose the input matrix if n > m, as Nassau tends to return zero tiles in
this case.
On the left of Fig. 7, we show the aggregated results when varying uniform
noise, as discussed for individual dimensions before. All algorithms except for
Primp tend to return fewer tiles with increasing noise. Despite correct rank estimations, Panda+ displays volatile F -measure values. Primpâ€™s rank estimations
are correct in the mean, but variance is quite high.
The middle plot depicts variations of negative noise while positive noise is fixed
to 3%. In this setting, the algorithms Primp, Mdl4bmf and Nassau are capable
of identifying the planted tiling for all noise levels. The suitability of Nassau in
the prevalence of negative noise corresponds to the experimental evaluation by
Karaev et al (2015). Mdl4bmf and Primp yield equally appropriate results in
this experiment. The approximations of Panda+ and Panpal are notably less

24

Sibylle Hess et al.
Negative Noise

F

Uniform Noise
1

1

1

0.5

0.5

0.5

0

0
0

r(X, Y )

Positive Noise

10

20

0
0

10

20

0

40

40

40

30

30

30

20

20

20

10

10

10

0

0
0

10
20
p+ = pâˆ’ [%]
Primp

Panpal

10

20

0
0
pâˆ’

10
20
[%] (p+ = 3%)

Panda+

Nassau

0

10
20
p+ [%] (pâˆ’ = 3%)
Mdl4bmf

Fig. 7: Variation of uniform, positive and negative noise. Comparison of F measures (the higher the better) and the estimated rank of the calculated tiling
(the closer to 25 the better) for varying levels of noise, i.e., p+ and pâˆ’ are indicated
on the x-axis (best viewed in color).

accurate. Although Panda+ correctly estimates the rank around 25 and Panpalâ€™s estimations lie between 10 and 20, Panpal achieves higher F -measures than
Panda+.
The plots on the right of Fig. 7 show the impact of variations on the positive
noise, fixing the negative noise to 3%. Here, Nassau, Mdl4bmf and Panpal tend
to underestimate the rank the more the noise increases, similarly to but not as
drastic as in experiments with uniformly distributed noise. Panda+ shows a poor
recovery of planted coherent tiles at 0% positive noise, but its F -value peculiarly
increases with increasing positive noise. Primp robustly identifies the true tiling
for all levels of noise, yet inhibits a higher variance from the mean of the rank
estimations.

4.4 Variation of Tiling Generation Parameters
We present effects on variations from the rank in Fig. 8 whereby the default parameters of 10% uniform noise and q = 0.1 apply. We observe a hierarchy of
algorithms in the tendency to underestimate the rank throughout all values of r? .
By far the lowest rank estimations are returned by Panpal, followed by Nassau,
Mdl4bmf, Panda+ and Primp. Panda+ and Primp consistently return accurate
rank estimations. It is remarkable that for ranks higher than 30, Panpal obtains

The PRIMPing Routine

25

40
r(X, Y )

F

1

0.5

20

0

0
10

20

30

40

0

20
r?

r?
Primp

Panpal

Nassau

Panda+

40

Mdl4bmf

Fig. 8: Variation of the rank r? âˆˆ {5, . . . , 45} of the planted tiling. Comparison of
F -measures (the higher the better) and estimated rank (the closer to the identity
function the better) of calculated tilings for uniform noise of p+ = pâˆ’ = 10% (best
viewed in color).

80
r(X, Y )

F

1

0.5

60
40
20

0
0.1

0.15
Primp

0.2
q

0.25
Panpal

0.3
Panda+

0
0.1

0.15
Nassau

0.2
q

0.25

0.3

Mdl4bmf

Fig. 9: Variation of density and overlap influencing parameter q âˆˆ [0.1, . . . , 0.3].
Comparison of F -measures (the higher the better) and the estimated rank of the
calculated tiling (the closer to 25 the better) for uniform noise of p+ = pâˆ’ = 10%
(best viewed in color).

higher F values than Panda+ despite of modeling only a fraction of the planted
tiles. Primp provides a steadily accurate recovery of planted tiles.
In Fig. 9 we vary the density and overlap influencing parameter q, which determines the maximum density of a column vector in X and Y . We observe two
classes of algorithms. The first class, consisting of Primp, Panda+ and Mdl4bmf
decreases in the F -measure with increasing q. In this class, Primp always retrieves
highest F -values. In return, the F -values from the second class of Panpal and Nassau increase with q. Here, Panpal bounds the F -values of Nassau from above.
Correspondingly, Primp and Panpal have a break-even-point at q = 0.2. From
this value on, Primp starts to considerably overestimate the rank while Panpalâ€™s
tendency to underestimate the rank, decreases. For q â‰¥ 0.2, Panpal estimates the
rank close to 20 in average. That is, five planted tiles are not modeled in average.
Still, the F -measure indicates that for the denser and more overlapping datasets,
Panpal most accurately discovers the planted tiles.

26

Sibylle Hess et al.

30
r(X, Y )

F

1

0.5

0

20
10
0

0

Primp

10
p+ = pâˆ’ [%]
Panpal

20

âˆ†r = 2

0

âˆ†r = 5

10
p+ = pâˆ’ [%]
âˆ†r = 10

20

âˆ†r = 20

Fig. 10: Variation of rank increment âˆ†r âˆˆ {2, 5, 10, 20}. Comparison of F -measures
(the higher the better) and the estimated rank of the calculated tiling (the closer
to 25 the better) for uniform noise of p+ = pâˆ’ indicated by the x-axis (best viewed
in color).

4.5 Sensitivity to the Rank Increment
In the default setting of our synthetic experiments, the PAL-Tiling algorithms
Primp and Panpal have to increase the rank two times by âˆ†r = 10 to estimate
the rank r? = 25 correctly. In the experiments varying the rank, we have seen that
Primp is able to find the correct rank if twice as many decisions correctly have
to be made. Here, we want to assess how robust the performance of Pal-Tiling
algorithms to the parameter âˆ†r is. What happens if, e.g., âˆ†r = 2 and 23 rank
increments have to be administered correctly?
Fig. 10 shows F -measurements and estimated ranks of the algorithms Primp
and Panpal, invoked with diverse rank increments âˆ†r âˆˆ {2, 5, 10, 20} on datasets
with varying uniform noise. It is noticeable that the rank estimations of Panpal
rapidly diverge with increasing noise while the plots of Primp stay comparatively
close. Panpalâ€™s tendency to underestimate the rank grows for smaller rank increments. In return, the rank estimations of Panpal can be improved by choosing
a large rank increment, i.e. âˆ†r â‰ˆ r? . However, since we do not know the rank in
real world applications, different increment values have to be tried and compared,
contradicting our goal to automatically determine this parameter. Still, Panpal
yields potentially useful lower bounds on the actual rank.
The average rank estimations of Primp have a maximum aberration of five from
the actual rank throughout all noise variations. The graphical display of r(X, Y )
for âˆ†r = 20 has a peak at 5% uniform noise but is close to r? otherwise. For rank
increments smaller than 10, the estimations do not distinctly decrease until the
noise exceeds 20%. Here, a rank increment of âˆ†r = 5 yields the most accurate rank
estimations, having also lowest standard deviations from the mean. Particularly,
Primpâ€™s tendency to overestimate the rank in specific settings can be corrected
by choosing smaller rank increments. Nonetheless, all these rank deviations barely
effect the F -measure, which demonstrates the robustly well fitted recovery of the
underlying model regardless of the choice of rank increment.

Algorithm

F

%fRSS

%fCT

%fL1

%fTXD

pÂ± = 25%

Planted
Primp
Panpal
Mdl4bmf
Panda
Nassau

1.0 Â± 0.0
0.9 Â± 0.05
0.35 Â± 0.2
0.46 Â± 0.08
0.14 Â± 0.11
0.1 Â± 0.05

88.37 Â± 1.24
89.58 Â± 1.71
97.17 Â± 1.62
96.6 Â± 0.86
99.14 Â± 0.77
100.5 Â± 0.29

89.88 Â± 1.25
91.0 Â± 1.54
97.56 Â± 1.46
97.25 Â± 0.76
99.28 Â± 0.62
100.7 Â± 0.3

89.51 Â± 1.25
90.65 Â± 1.59
97.47 Â± 1.49
97.11 Â± 0.77
99.24 Â± 0.66
100.69 Â± 0.31

96.5 Â± 0.61
97.0 Â± 0.62
99.16 Â± 0.56
99.2 Â± 0.25
99.75 Â± 0.19
99.75 Â± 0.15

r? = 45

27

Planted
Primp
Panpal
Mdl4bmf
Panda
Nassau

1.0 Â± 0.0
1.0 Â± 0.0
0.67 Â± 0.1
0.8 Â± 0.04
0.53 Â± 0.02
0.74 Â± 0.21

50.27 Â± 1.25
50.32 Â± 1.23
73.0 Â± 6.04
62.67 Â± 1.41
89.02 Â± 1.76
64.43 Â± 10.08

54.67 Â± 1.29
54.74 Â± 1.27
75.04 Â± 5.56
66.72 Â± 1.53
92.34 Â± 2.16
68.27 Â± 10.24

53.29 Â± 1.29
53.35 Â± 1.27
74.29 Â± 5.71
65.48 Â± 1.46
92.76 Â± 2.09
67.28 Â± 10.43

69.77 Â± 0.96
69.85 Â± 0.93
84.66 Â± 3.78
79.21 Â± 1.03
86.0 Â± 0.7
77.47 Â± 4.87

q = 0.3

The PRIMPing Routine

Planted
Primp
Panpal
Mdl4bmf
Panda
Nassau

1.0 Â± 0.0
0.7 Â± 0.1
0.92 Â± 0.11
0.59 Â± 0.04
0.51 Â± 0.05
0.9 Â± 0.09

24.94 Â± 2.74
27.04 Â± 2.46
29.45 Â± 3.17
45.08 Â± 2.14
54.12 Â± 8.9
29.11 Â± 5.19

27.84 Â± 2.78
31.23 Â± 2.33
31.98 Â± 3.06
48.53 Â± 2.01
57.07 Â± 8.83
32.07 Â± 5.2

27.11 Â± 2.7
30.33 Â± 2.25
31.31 Â± 3.1
47.88 Â± 1.96
56.74 Â± 8.86
31.42 Â± 5.2

51.97 Â± 1.04
57.52 Â± 2.03
57.09 Â± 3.86
73.81 Â± 1.49
75.88 Â± 2.32
56.79 Â± 4.2

Table 3: Average cost measures of computed and planted models, denoted relation
to the costs of the empty model. For each setting (variation of one data generation
parameter while the others are set to default values r? = 25, q = 0.3 and pÂ± =
25%) the average value is computed over all considered dimension variations.

4.6 Comparison of Cost Measures
We have seen how well the competing algorithms perform with regard to the
F -measure. Then again, assessing the performance on real data requires other
measurements. Possible candidates are the costs listed in Table 1. Subsequently,
we relate selected costs of computed and planted models to the F -measure and
discuss whether we can deduce a suitable extraction of the underlying model from
a low cost measure; is smaller always better?
Table 3 displays the average costs in relation to the empty model for the four
measures fRSS , the residual sum of squares, fCT , the compression size obtained by
code tables, fL1 , the L1-regularized residual sum of squares and fTXD , the Typed
XOR DtM measure. We examine three parameter settings, one for the highest
value in each variation of the data generation parameters r? , q and pÂ± . Thereby,
default settings of r? = 25, q = 0.1, pÂ± = 10% apply, if not stated otherwise.
The values of the planted model are shaded out while the highest F -measure and
lowest mean costs of computed models are highlighted.
We can trace that high F -values often correspond to lower costs, regardless
of the measurement. This effect is immediately perceivable at rows where Primp
attains highest F -values and all of its cost values are highlighted as well. Yet, the
experiments for q = 0.3 display a more diverse ranking among the measurements.
In this setting, Primp decidedly overestimates the rank but still obtains lowest
costs in all but the fTXD measure. Panpal attains the highest F -value, closely followed by Nassau. Both algorithms reach second or third lowest costs in fRSS , fCT
and fL1 . The fTXD costs reflect the order of F -values more suitably, Nassau obtains lowest costs, closely followed by Panpal and Primp. In brief, the costs of
Primp, Panpal and Nassau are always close while only Mdl4bmf and Panda+

28

Sibylle Hess et al.
Dataset D
Abstracts
Mushroom
MovieLens5M
MovieLens500K
Chess

m

n

Density [%]

859
8124
29980
3329
3196

4977
120
9044
3015
75

1.02
19.33
1.81
4.99
49.33

Table 4: Characteristics of considered datasets: Number of rows m, number of
columns n and density |D|/(nm) in percent.

lie notably behind. Here, the deciding clue is given by the rank, which separates
the close cost measurements of Primp, Panpal and Nassau by showing that slight
improvements in the costs by Primp are achieved by a disproportionate increase
of the rank.
While for q = 0.3, the fTXD costs appear suitable to reflect an appropriate
extraction of tiles, in the setting of pÂ± = 25% we observe another facet. Here, we
see that Nassau reaches the same average fTXD costs as Panda+ although Nassau
increases the RSS in comparison to the empty model. This is indicated by relative
costs larger than 100% in all measurements but fTXD . Still, the ranking of fTXD
costs matches the F -measure ranking but this example shows, that a compression
with respect to the fTXD description length can be achieved without adaptation
to the data.

4.7 Real-World Data Experiments
We conduct experiments on five datasets, whose characteristics are summarized
in Table 4. Chess and Mushroom are discretized benchmark UCI datasets having
a comparatively high density and around 50 times more rows than columns. The
Abstracts dataset indicates the presence of stemmed words, excluding stop-words,
in all ICDM paper abstracts until 2007 (De Bie 2011). It is a sparse dataset with
around 5 times as many columns (words) as rows (documents). Finally, the MovieLens5M and MovieLens500K are binarized versions of the MovieLens10M 5 and
MovieLens1M 6 datasets, where rows correspond to users and columns to movies.
We set Dji = 1 iff user j recommends movie i with more than three out of five stars.
After selecting only those users which recommend more than 50 movies and those
movies which receive more than five recommendations, we obtain two datasets
with a balanced number of of rows and columns. The MovieLens5M dataset, containing 5M ones, and the MovieLens500K dataset, with 500 thousand ones, have
a (as one would expect, due to the dataset domain) high amount of negative noise
due to missing values. Originally, we intended to consider only the MovieLens5M
dataset, but Nassau and Mdl4bmf could not terminate in reasonable time â€“ we
aborted the calculations after one month. Therefore, we also prepared the smaller
MovieLens500K dataset. (For comparison: While Primp, Panpal and Panda+
require around ten minutes to compute the result for MovieLens500K, Mdl4bmf
5
6

http://grouplens.org/datasets/movielens/10m/
http://grouplens.org/datasets/movielens/1m/

Rank

%fRSS

%fCT

%fL1

%fTXD

Abstracts

Primp
Panpal
Mdl4bmf
Nassau
Panda+

46
1
24
3
133

93.0
99.8
95.84
99.81
113.34

98.6
99.96
100.68
101.76
125.27

96.33
99.89
100.49
103.05
140.49

96.12
99.74
97.05
96.84
88.19

Primp
Panpal
Mdl4bmf
Nassau
Panda+

18
6
3
10
27

24.61
40.76
35.91
31.92
25.76

31.3
46.71
39.34
39.03
36.58

29.32
45.67
39.51
38.94
35.74

62.8
78.92
68.88
65.78
65.01

Primp
Panpal
Mdl4bmf
Nassau
Panda+

78
15
56
29
120

88.59
94.05
89.65
111.15
160.93

93.29
95.92
94.97
118.47
165.61

91.4
94.87
93.43
120.58
168.58

89.37
92.26
88.72
85.89
79.49

209
38
1919

89.31
93.68
181.42

93.14
95.72
202.87

91.2
94.39
201.45

88.16
88.73
72.23

14
7
87
65
40

35.75
44.03
23.39
40.60
100.30

40.89
51.23
36.6
58.77
117.34

40.25
48.52
32.47
54.93
112.80

56.09
63.75
50.37
50.62
66.98

5M

500K

Algorithm

Chess

Data

29

MovieLens

The PRIMPing Routine

Primp
Panpal
Panda+

Mushroom

Primp
Panpal
Mdl4bmf
Nassau
Panda+

Table 5: Comparison of cost measures for real-world datasets.
MovieLens
500K
5M

Primp

Panpal

Mdl4bmf

Nassau

Panda+

2.38
2.08

2.23
2.78

3.68
-

10.33
-

18.78
23.14

Table 6: Percentage of traceable wrong recommendations of computed models for
the MovieLens datasets, i.e., the relative amount of user-movie recommendations
which correspond to bad reviews (< 2.5 stars out of five).

and Nassau need more than five days.) Furthermore, we note that we transpose
the Abstracts dataset for Nassau, as it returns zero tiles otherwise.
We state the estimated rank and the attained costs, relative to the costs of
the empty model for every considered dataset and algorithm in Table 5. The
lowest costs are highlighted for each measure and dataset. We observe, similarly
to the evaluation in Sec. 4.2, a tendency toward compliance among all measures,
except for the Typed XOR description length. As such, Primp mostly obtains
minimal costs in all datasets but Mushroom, where Mdl4bmf reaches lowest costs.
The models of Panda+ exhibit for sparse datasets low Typed XOR DtM costs
although the fit to the data is low (fRSS > 100%). The discrepancy between the
fTXD compression size and the other measurements is most remarkably for the
MovieLens datasets. Here, the ranking with respect to fTXD is almost inverse to
the ranking with respect to other costs.
This leads to the question which cost measure indicates the suitable tiling in
such situations? Luckily, we have for the MovieLens data the possibility to assess

30

Sibylle Hess et al.

how many recommendations would fail by the submitted bad reviews, which are
not reflected in the input data. We state the relative amount of recommendations
which correspond to bad reviews, i.e., |Dâˆ’ â—¦Î¸(Y X T )|/|Dâˆ’ | where Dâˆ’ is the matrix
having Dji = 1 iff user j rates movie i with less than 2.5 of five stars, in Table 6.
We observe that the lower fTXD costs are, the higher is the rate of recommendation
failures, regardless of the estimated rank. Therefore, we expect Primp to discover
the most liable grouping of users and movies, having the lowest approximation
error and a very low ration of traceable wrong recommendations. Similarly, it is
questionable if low fTXD costs indicate suitable models in specific cases where the
approximation error diverges such as for the Abstracts dataset.

4.8 Qualitative Inspection of Mined Tiles
The F -measure gives a hint at the kind of tiling we can expect from the algorithms,
e.g., Panpal returns a coarse view, modeling only a few tiles which match actually
persistent ones, the quality of Panda+â€™ results substantially varies and Mdl4bmf
and particularly Primp are most often able to identify the persistent interrelations.
Yet how do the algorithms relate in their actual cognition of structure and noise,
what makes a tile a tile?
Image data allows us to visually inspect the resulting factorizations without
the need to specify a numeric measure. We can intuitively assess the attempts
to capture relevant sub-structures. However, some preprocessing is required in
order to feed w Ã— h images to the mining algorithms. We employ a standard
representation of images: the RGB888 pixel format. Each of the w Ã— h pixels is
represented by 24 bits, using 8 bits per color (red, green and blue). In order to
convert an image into a set of transactions, we divide it into blocks (patches)
h
of 4 Ã— 4 pixels, resulting in a total of w
4 Ã— 4 transactions per image. We adopt
this representation from computer vision, where image patches are a standard
preprocessing step for raw pixel data (Jarrett et al 2009). Within each block, let
(r, g, b)l,k denote the pixel at row l and column k, where r, g, b âˆˆ {0, 1}8 are the
8-bit binary representation of its red, green and blue color values. We model the
concatenation of all 16 pixels within one block as one transaction
[(r, g, b)1,1 , (r, g, b)1,2 , (r, g, b)1,3 , (r, g, b)1,4 , (r, g, b)2,1 , . . . , (r, g, b)4,4 ]

(11)

which has a length of 24 Â· 16 = 384 bits.
This way, we process two images: an illustration of Alice in Wonderland (Fig. 11)
and a selection of â€œaliensâ€ from the classic game Space Invaders (Fig. 12). We select Alice because the image contains multiple connected areas, each representing
a reasonable substructure, i.e., hair, face, dress, arm and background. In return,
the Space Invaders image contains multiple patterns in terms of color and shape,
but the components are clearly spatially separable.
The original Alice image, as well as reconstructions Î¸(XY ) and the top-4 tiles
generated by Nassau, Mdl4bmf, Panda+, Panpal and Primp, are depicted in
Fig. 11. Clearly, only Panda+ and Primp select patterns, i.e., blocks of pixels
which provide a reasonable reconstruction of the original image. Panpalâ€™s tendency to underestimate the rank (choosing only three factors) becomes apparent

The PRIMPing Routine
Reconstruction

Fac 1

Fac 2

Fac 3

Fac 4

Primp

Panpal

Panda+

Mdl4bmf

Nassau

Original

31

Fig. 11: Reconstructions of the Alice image and postprocessed top-4 tiles. Best
viewed in color.

here again. Regarding the figured structures, Panda+, Panpal and Primp discover a hair-related substructure, where the one found by Primp has the most distinctive contours, and Panda+, Panpal and Primp identify a face-related structure. The reconstructions and factors found by Nassau and Mdl4bmf are not
easy to interpret without knowledge of the original image.
Reconstruction results and top-4 patterns of the Space Invaders image are
shown in Fig. 12. All methods reconstruct at least the shape of the aliens. In terms
of color, however, the results diverge. Panda+ and Nassau interpret all colors
as negative noise effects on the color white; white has a binary representation
of 24 ones. Panpal recovers the yellow color correctly and it extracts the full
blue channel from the imageâ€”an identical pattern is also detected by Primp.
Primp and Mdl4bmf reconstruct all three colors of the original image, yet the
reconstruction of Mdl4bmf exhibits injections of white blocks. Hence, only Primp
is capable to reconstruct the color information correctly.
Having a look at derived tiles, the greedy processes of Panda+ and Nassau
become particularly visible; Panda+ and Nassau overload the first factor with
all the shape information. The remaining factors reduce the quantitative reconstruction error, but have no deeper interpretation. Mdl4bmf tries to model one
type of aliens by each tile. Although this would result in a reasonable description
of the image, the actual extraction of tiles suffers from the greedy implementation.
We can see that, e.g., the first tile captures information about the yellow aliens as
well as strayed parts of other aliens. This unfortunate allocation of tiles results in

Sibylle Hess et al.
Original

32

Fac 1

Fac 2

Fac 3

Fac 4

Primp

Panpal

Panda+

Mdl4bmf

Nassau

Reconstruction

Fig. 12: Reconstructions of the Space Invaders image and the top-4 postprocessed
tiles. Best viewed in color.

the injection of white blocks in the reconstruction image. Panpal clearly separates
yellow and blue aliens but interprets differences from the color blue to purple and
to turquoise as noise. Finally, Primp separates by its tiles the three basic color
channels which are actually used to mix the colors that appear in the original image. Hence, Primp achieves the factorization rank that corresponds to the natural
amount of color concepts in the image, unlike all other competitors.
The results of this qualitive experiment particularly illustrates the benefits of
a non-greedy minimization procedure. Even though Panpal is often not able to
minimize the costs due to an underestimation of the rank, its categorization into
tiles always yields interpretable parts.

5 Conclusion
We introduce PAL-Tiling, a general framework to compute tilings according to a
cost measure based on a theoretically founded numerical optimization technique.
Requiring that the cost measure has a smooth relaxed function, which combines
the matrix factorization error with a regularizing function, PAL-Tiling minimizes
the relaxed objective under convergence guarantees. To simulate the minimization
subject to the constraint that the matrices are binary, we derive a closed form of the

The PRIMPing Routine

33

proximal mapping with respect to a function which penalizes non-binary values.
A thresholding to binary values according to the actual cost measure enables an
automatic determination of the factorization rank.
Aiming at the robust identification of tilings in presence of various noise distributions, we consider two cost measures in this framework which defines two tiling
algorithms. The first algorithm uses a simple L1-norm regularization on the factor
matrices and is called Panpal. The second minimizes the MDL-description length
of the encoding by code tables as known from Krimp (Siebes et al 2006). Foregoing the heuristics in computing the usage of codes, we extend the application
of this encoding from pattern mining to Boolean matrix factorization and derive
an upper bound which induces the relaxed objective. We refer to this instance of
PAL-Tiling as Primp.
Our experiments on synthetically generated datasets show that the quality of
competing algorithms Panda+, Mdl4bmf and Nassau is sensitive towards multiple data generation parameters. The first of the two newly introduced algorithms,
Panpal, regularly underestimates the true factorization rank. We have seen that
this property can be beneficial in settings with large, overlapping tiles which induce dense datasets (cf. Fig. 9). In all other settings, the second algorithm Primp
is able to detect the underlying structure, regardless of the considered distribution
of noise or variations the factorization rank (cf. Figs. 5-8).
A comparison of cost measures on real-world datasets show that Primp also
most often achieves lowest costs (cf. Table 5). With experiments based on images,
we visualize the derived tiles under presence of ambiguous tiling structures and
special noise distributions (cf. Figs. 11 and 12). The quality of the reconstruction
by established algorithms varies considerably between both images. On the contrary, Panpal and Primp provide solid representations of the original images. The
extracted factors reveal a parts-based decomposition of the data (as known from
non-negative matrix factorizations), which allows for interpretation of the results.
In the Space Invaders image (cf. Fig. 12), Panpal partitions the space invaders
into those with a non-zero blue component in their color (rank-1 factorization 2)
and those with a zero blue component in their color (rank-1 factorization 1). On
the other hand, Primp divides the space invaders by the primary colors they contain (repeating each space invader exactly twice, hence finding structure in the
data too, albeit a different structure from the one found by Panpal). From the
Alice image (cf. Fig. 11) particularly Primp manages to extract coherent factors
representing the hair (rank-1 factorization 1) and the face (rank-1 factorization 4).
The implementation of other popular cost measures , e.g., the Typed XOR
DtM, is possible in PAL-Tiling and a topic of future research. Furthermore,
the application of other penalizing functions Ï† is possible if the corresponding
prox-operator can be derived. An analysis of the synergy between the penalizing
function, the cost-measure and the thereby derived Boolean Matrix Factorization
has the potential to show how the structure from arbitrary binary datasets can be
robustly identified.
Acknowledgements Part of the work on this paper has been supported by Deutsche Forschungsgemeinschaft (DFG) within the Collaborative Research Center SFB 876 â€œProviding Information by Resource-Constrained Analysisâ€, projects A1 and C1 http://sfb876.tu-dortmund.de.
Furthermore, we thank Jilles Vreeken and Sanjar Karaev for their support in the execution
of experiments and useful remarks.

34

Sibylle Hess et al.

References
Bauckhage C (2015) k-means clustering is matrix factorization. arXiv preprint arXiv:151207548
Bolte J, Sabach S, Teboulle M (2014) Proximal alternating linearized minimization for nonconvex and nonsmooth problems. Mathematical Programming 146(1-2):459â€“494
Cover T, Thomas J (2006) Elements of information theory. Wiley-Interscience
De Bie T (2011) Maximum entropy models and subjective interestingness: an application to
tiles in binary databases. Data Mining and Knowledge Discovery 23(3):407â€“446
Ding C, Li T, Peng W, Park H (2006) Orthogonal nonnegative matrix t-factorizations for clustering. In: Proceedings of the 12th ACM SIGKDD international conference on Knowledge
discovery and data mining, ACM, pp 126â€“135
Ding CH, He X, Simon HD (2005) On the equivalence of nonnegative matrix factorization and
spectral clustering. In: Proceedings of the SIAM International Conference on Data Mining
(SDM), SIAM, vol 5, pp 606â€“610
Geerts F, Goethals B, MielikaÌˆinen T (2004) Tiling databases. In: International Conference on
Discovery Science, Springer, pp 278â€“289
GruÌˆnwald P (2007) Minimum Description Length Principle. MIT press, Cambridge, MA
Hess S, Piatkowski N, Morik K (2014) Shrimp: Descriptive patterns in a tree. In: Proceedings
of the 16th LWA Workshops: KDML, IR and FGWM., pp 181â€“192
Jarrett K, Kavukcuoglu K, Ranzato M, LeCun Y (2009) What is the best multi-stage architecture for object recognition? In: IEEE 12th International Conference on Computer Vision,
IEEE Computer Society, pp 2146â€“2153
Karaev S, Miettinen P, Vreeken J (2015) Getting to know the unknown unknowns: Destructivenoise resistant boolean matrix factorization. In: Proceedings of the SIAM International
Conference on Data Mining (SDM), SIAM, pp 325â€“333
Kontonasios KN, De Bie T (2010) An information-theoretic approach to finding informative
noisy tiles in binary databases. In: Proceedings of the SIAM International Conference on
Data Mining (SDM), SIAM, pp 153â€“164
Kuhn HW (1955) The hungarian method for the assignment problem. Naval research logistics
quarterly 2(1-2):83â€“97
Lee DD, Seung HS (1999) Learning the parts of objects by non-negative matrix factorization.
Nature 401(6755):788â€“791
Lee DD, Seung HS (2001) Algorithms for non-negative matrix factorization. In: Advances in
neural information processing systems, pp 556â€“562
Li PVM (1997) An Introduction to Kolmogorov Complexity and Its Applications. Springer
Li T (2005) A general model for clustering binary data. In: Proceedings of the eleventh ACM
SIGKDD international conference on Knowledge discovery in data mining, ACM, pp 188â€“
197
Li T, Ding C (2006) The relationships among various nonnegative matrix factorization methods
for clustering. In: International Conference on Data Mining (ICDM), IEEE, pp 362â€“371
Lucchese C, Orlando S, Perego R (2010) Mining top-k patterns from binary datasets in presence
of noise. In: Proceedings of the SIAM International Conference on Data Mining (SDM),
SIAM, vol 10, pp 165â€“176
Lucchese C, Orlando S, Perego R (2014) A unifying framework for mining approximate top-k
binary patterns. Transactions on Knowledge and Data Engineering 26(12):2900â€“2913
Miettinen P (2015) Generalized matrix factorizations as a unifying framework for pattern set
mining: Complexity beyond blocks. In: Machine Learning and Knowledge Discovery in
Databases, Springer International Publishing, pp 36â€“52
Miettinen P, Vreeken J (2014) Mdl4bmf: Minimum description length for boolean matrix factorization. ACM Transactions on Knowledge Discovery from Data (TKDD) 8(4):18:1â€“18:31
Miettinen P, Mielikainen T, Gionis A, Das G, Mannila H (2008) The discrete basis problem.
IEEE Transactions on Knowledge and Data Engineering 20(10):1348â€“1362
Paatero P, Tapper U (1994) Positive matrix factorization: A non-negative factor model with
optimal utilization of error estimates of data values. Environmetrics 5(2):111â€“126
Parikh N, Boyd S (2014) Proximal algorithms. Foundations and Trends in Optimization 1(3)
Rissanen J (1978) Modeling by shortest data description. Automatica 14:465â€“471
Siebes A, Kersten R (2011) A structure function for transaction data. In: Proceedings of the
SIAM International Conference on Data Mining (SDM), SIAM, pp 558â€“569
Siebes A, Vreeken J, van Leeuwen M (2006) Item sets that compress. In: Proceedings of the
SIAM International Conference on Data Mining (SDM), SIAM, vol 6, pp 393â€“404

The PRIMPing Routine

35

Smets K, Vreeken J (2012) Slim: Directly mining descriptive patterns. In: Proceedings of the
SIAM International Conference on Data Mining (SDM), SIAM, pp 236â€“247
Tatti N, Vreeken J (2012) Comparing apples and oranges: measuring differences between exploratory data mining results. Data Mining and Knowledge Discovery 25(2):173â€“207
Van Leeuwen M, Siebes A (2008) Streamkrimp: Detecting change in data streams. In: Joint
European Conference on Machine Learning and Knowledge Discovery in Databases, pp
672â€“687
Vreeken J, Van Leeuwen M, Siebes A (2011) Krimp: mining itemsets that compress. Data
Mining and Knowledge Discovery 23(1):169â€“214
Wang YX, Zhang YJ (2013) Nonnegative matrix factorization: A comprehensive review. IEEE
Transactions on Knowledge and Data Engineering 25(6):1336â€“1353
Xiang Y, Jin R, Fuhry D, Dragan FF (2011) Summarizing transactional databases with overlapped hyperrectangles. Data Mining and Knowledge Discovery 23(2):215â€“251
Zhang Z, Ding C, Li T, Zhang X (2007) Binary matrix factorization with applications. In:
Seventh IEEE International Conference on Data Mining (ICDM), pp 391â€“400
Zimek A, Vreeken J (2013) The blind men and the elephant: On meeting the problem of
multiple truths in data from clustering and pattern mining perspectives. Machine Learning
98(1-2):121â€“155

A Derivation of the Proximal Operator
P
Theorem 1 Let Î± > 0 and Ï†(X) = i,j Î›(Xij ) for X âˆˆ RmÃ—n . The proximal operator of Î±Ï†
maps the matrix X to the matrix proxÎ±Ï† (X) = A âˆˆ [0, 1]mÃ—n defined by Aji = proxÎ±Î› (Xji ),
where for x âˆˆ R it holds that
(
proxÎ±Î› (x) =

max{0, x âˆ’ 2Î±}
min{1, x + 2Î±}

x â‰¤ 0.5
x > 0.5.

(9)

Proof Let Î± > 0, X âˆˆ RmÃ—n for some m, n âˆˆ N and A = proxÎ±Ï† (X). The function Ï† is fully
separable across all matrix entries. In this case, the proximal operator can be applied entrywise to the composing scalar functions (Parikh and Boyd 2014), i.e., Aji = proxÎ±Î› (Xji ). It
remains to derive the proximal mapping of Î› (Eq. (9)).
The proximal operator reduces to Euclidean projection if the argument lies outside of the
functionâ€™s domain (Parikh and Boyd 2014) and it follows that
proxÎ±Î› (x) = Î¸(x) if x âˆˆ
/ [0, 1].
For x âˆˆ [0, 1] holds Î›(x) = âˆ’|1 âˆ’ 2x| + 1 and

proxÎ±Î› (x) = arg min
x? âˆˆR


1
(x âˆ’ x? )2 âˆ’ Î±|1 âˆ’ 2x? | + 1Î±
2

ï£±
ï£¼
ï£´
ï£´
ï£´
ï£´
ï£²
ï£½
= arg min (x âˆ’ x? )2 âˆ’ 2Î±|1 âˆ’ 2x? | + (2Î±)2 ,
{z
}ï£´
x? âˆˆR ï£´
ï£´
ï£´
ï£³|
ï£¾
?
=g(x ;x,Î±)

where g is derived by a multiplication and addition of constants, such that the minimum can
easily be derived by completing the square.
(

?

(x âˆ’ x? )2 âˆ’ 2Î±(1 âˆ’ 2x? ) + (2Î±)2 x? â‰¤ 0.5
(x âˆ’ x? )2 + 2Î±(1 âˆ’ 2x? ) + (2Î±)2 x? > 0.5
(
(x? âˆ’ (x âˆ’ 2Î±))2 âˆ’ 2Î±(1 âˆ’ 2x) x? â‰¤ 0.5
=
.
(x? âˆ’ (x + 2Î±))2 + 2Î±(1 âˆ’ 2x) x? > 0.5

g(x ; x, Î±) =

36

Sibylle Hess et al.

The function g is a continuous piecewise quadratic function which attains its global minimum
at the minimum of one of the two quadratic functions, i.e.,
arg min g(x? ; x, Î±) âˆˆ {x âˆ’ 2Î± | x â‰¤ 0.5 + 2Î±} âˆª {x + 2Î± | x > 0.5 âˆ’ 2Î±}.
x? âˆˆR

A function value comparison in the intersecting domain x âˆˆ (0.5 âˆ’ 2Î±, 0.5 + 2Î±] yields that
g(x âˆ’ 2Î±; x, Î±) = âˆ’2Î±(1 âˆ’ 2x) â‰¤ g(x + 2Î±; x, Î±) = 2Î±(1 âˆ’ 2x) â‡” x â‰¤ 0.5
u
t

B Krimpâ€™s Encoding as Matrix Factorization
Lemma 1 Let D be a data matrix. For any code table CT and its cover function there exists
a Boolean matrix factorization D = Î¸(Y X T ) + N such that non-singleton patterns in CT are
mirrored in X and the cover function is reflected by Y . The description lengths correspond to
each other, such that
D
M
LCT (D, CT ) = fCT (X, Y, D) = fCT
(X, Y, D) + fCT
(X, Y, D),

where the functions returning the model and the data description size are given as
D
fCT
(X, Y, D) = âˆ’

r
X

|YÂ·s | Â· log(ps ) âˆ’

s=1

n
X

|NÂ·i | Â· log(pr+i )

i=1

= LD
CT (D, CT )

X 
M
T
fCT (X, Y, D) =
XÂ·s
c âˆ’ log(ps ) +
s:|YÂ·s |>0

X

(ci âˆ’ log(pr+i ))

i:|NÂ·i |>0

= LM
CT (CT ).
The probabilities ps and pr+i indicate the relational usage of non-singleton patterns XÂ·s and
singletons {i},
|NÂ·i |
|YÂ·s |
, pr+i =
.
ps =
|Y | + |N |
|Y | + |N |
n
We denote with c âˆˆ R+ the vector of standard code lengths for each item, i.e.,


|DÂ·i |
ci = âˆ’ log
.
|D|
Proof Let D be a data matrix, CT = {(XÏƒ , CÏƒ )|1 â‰¤ Ïƒ â‰¤ Ï„ } a Ï„ -element code table and
cover the cover function. Let r be the number of non-singleton patterns in CT and assume
w.l.o.g. that CT is indexed such that these non-singleton patterns have an index 1 â‰¤ Ïƒ â‰¤ r.
We construct the pattern matrix X âˆˆ {0, 1}nÃ—r and usage matrix Y âˆˆ {0, 1}mÃ—r such that
for 1 â‰¤ Ïƒ â‰¤ r it holds that
XiÏƒ = 1 â‡” i âˆˆ XÏƒ
YjÏƒ = 1 â‡” XÏƒ âˆˆ cover(CT, DjÂ· ).
XT )

The Boolean product Î¸(Y
indicates the entries of D which are covered by non-singleton
patterns of CT . That implies that ones in the noise matrix N = D âˆ’ Î¸(Y X T ) are covered by
singletons, it holds that
Nji 6= 0 â‡” i âˆˆ cover(CT, DjÂ· ).
The usage of a non-singleton pattern XÏƒ is then computed as
usage(XÏƒ ) = |{XÏƒ âˆˆ cover(CT, DjÂ· )|j âˆˆ T }|
= |{YjÏƒ = 1|j âˆˆ T }|
= |YÂ·Ïƒ |,
and correspondingly it follows that usage({i}) = |NÂ·i |. The calculation of the probabilities
pÏƒ for 1 â‰¤ Ïƒ â‰¤ r + n is directly obtained by inserting this usage calculation in the definition
M and f D from the
of code-usage-probabilities of Eq. (2). Likewise follow the functions fCT
CT
D .
definition of the description sizes LM
and
L
u
t
CT
CT

The PRIMPing Routine

37

C Bounding the Description Length of Code Tables
Lemma 1 Let (as ) be a finite sequence of r non-negative scalars such that Sr =
The function g : [0, âˆž) â†’ [0, âˆž) defined by
g(x; a1 , . . . , ar , Sr ) = âˆ’

r
X


(as + x) log

s=1

as + x
Sr + rx

Pr

s=1

as > 0.



is monotonically increasing in x.
Proof W.l.o.g., let a1 , . . . , ar0 > 0 and ar0 +1 , . . . , ar = 0 for some r0 âˆˆ N. We rewrite the
function g as
g(x; a1 , . . . , ar , Sr ) = g(x; a1 , . . . , ar0 , Sr ) + g(x; ar0 +1 , . . . , ar , Sr )
and show that each of the subfunctions is monotonically increasing. The first subfunction is
differentiable and its derivative is non-negative



r 
X
d
as + x
Sr + rx Sr + rx âˆ’ r(as + x)
log
g(x; a1 , . . . , ar0 , Sr ) = âˆ’
+ (as + x)
2
dx
Sr + rx
as + x
(Sr + rx)
s=1


r
r
X
X Sr âˆ’ ras
as + x
=âˆ’
log
+
S
+
rx
Sr + rx
r
s=1
s=1


r
X
as + x
â‰¥ 0.
log
=âˆ’
S
r + rx
s=1
The second subfunction is monotonically increasing, since for as = 0 and all x â‰¥ 0 it holds
that

 

as + x
as
= 0 â‰¤ âˆ’(as + x) log
as log
.
Sr
Sr + rx
u
t
Theorem 2 Given binary matrices X and Y and Âµ = 1 + log(n), it holds that
D
fCT
(X, Y, D) â‰¤ ÂµkD âˆ’ Y X T k2 âˆ’

r
X


(|YÂ·s | + 1) log

s=1

|YÂ·s | + 1
|Y | + r


+ |Y |

(10)

Proof We recall that the description size of the data is computed by
D
fCT
(X, Y, D) = âˆ’

r
X


|YÂ·s | Â· log

s=1

|

|YÂ·s |
|Y | + |N |

{z

=f1 (X,Y,D)


âˆ’

n
X


|NÂ·i | Â· log

i=1

}|

|NÂ·i |
|N | + |Y |

{z

=f2 (X,Y,D)

Applying the logarithmic properties, we rewrite the first sum
r
X


|YÂ·s |
|Y |
|Y | |Y | + |N |
s=1
 X



r
r
X
|YÂ·s |
|Y | + |N |
=âˆ’
|YÂ·s | log
+
|YÂ·s | log
|Y |
|Y |
s=1
s=1


|N |
= g(0; |YÂ·1 |, . . . , |YÂ·r |, |Y |) + |Y | log 1 +
.
|Y |

f1 (X, Y, D) = âˆ’



|YÂ·s | log


.
}

38

Sibylle Hess et al.

It follows from the monotonicity of g (Lemma 1) and the logarithm inequality (log(1 + x) â‰¤
x, âˆ€x â‰¥ 0) that f1 is upper bounded by
f1 (X, Y, D) â‰¤ âˆ’

r
X


(|YÂ·s | + 1) log

s=1

|YÂ·s | + 1
|Y | + r


+ |N |.

The second term f2 can be transformed into
f2 (X, Y, D) = âˆ’

=

n
X

i=1
n
X

|NÂ·i | Â· log (|NÂ·i |) +

|NÂ·i | Â· log (|N | + |Y |)

i=1

|Ni | log

i=1

n
X

1
+ |N | log(|N | + |Y |).
|Ni |

Subsequently, we show f2 (X, Y, D) â‰¤ |N | log(n)+|Y |. This inequality trivially holds if |N | = 0.
Otherwise, we apply Jensenâ€™s inequality to the concave logarithm function
|N |



n
X
1
n
|Ni |
log
â‰¤ |N | log
.
|N |
|Ni |
|N |
i=1

and obtain

f2 (X, Y, D) â‰¤ |N | log

n
|N |


+ |N | log(|N | + |Y |)



|Y |
= |N | log(n) + |N | log 1 +
|N |
â‰¤ |N | log(n) + |Y |,
where the last equality again follows from the logarithm inequality. We derive the final inequality by
D
fCT
(X, Y, D) = f1 (X, Y, D) + f2 (X, Y, D)

â‰¤ (1 + log(n))|N | âˆ’

r
X


(|YÂ·s | + 1) log

s=1

|YÂ·s | + 1
|Y | + r


+ |Y |
u
t

D Calculating the Lipschitz Moduli of PRIMP
We study the partial gradients of the regularization term used in Primp (Sec. 3.4)
âˆ‡X G(X, Y ) = c(0.5)T
s



1
|YÂ·s | + 1
âˆ‡Y G(X, Y ) = âˆ’
log
+ (0.5)js .
2
|Y | + r
js
The partial gradient with respect to X is constant and has a Lipschitz constant of zero. The
partial gradient with respect to Y can be written as the sum
1
âˆ‡Y G(X, Y ) = âˆ’ ((log(|YÂ·s | + 1))js âˆ’ (log(|Y | + r))js ) + (0.5)js .
2 |
{z
} |
{z
}
=A(Y )

=B(Y )

The PRIMPing Routine

39

From the triangle inequality follows that the gradient with respect to Y is Lipschitz continuous
with modulus Mâˆ‡Y G (X) = 21 (MA + MB ), if the functions A and B are Lipschitz continuous
with moduli MA and MB :
1
kA(Y ) âˆ’ A(V ) + B(Y ) âˆ’ B(V )k
2
1
â‰¤ kA(Y ) âˆ’ A(V )k + kB(Y ) âˆ’ B(V )k
2
MA + MB
kY âˆ’ V k.
â‰¤
2

kâˆ‡Y G(X, Y ) âˆ’ âˆ‡V G(X, V )k =

The one-dimensional function x 7â†’ log(x + Î´), x âˆˆ R+ is for any Î´ > 0 Lipschitz continuous
with modulus Î´ âˆ’1 . This can be easily derived by the mean value theorem and the bound
d
1
1
log(x + Î´) =
â‰¤
dx
x+Î´
Î´
for all x â‰¥ 0. We show with the following equations, that MA = MB = m. For improved
readability, we use the squared Lipschitz inequality, i.e.,
X
kA(Y ) âˆ’ A(V )k2 =
(log(|YÂ·s | + 1) âˆ’ log(|VÂ·s | + 1))2
s,j

=m

â‰¤m

r
X

(log(|YÂ·s | + 1) âˆ’ log(|VÂ·s | + 1))2

s=1
r
X

(|YÂ·s | âˆ’ |VÂ·s |)2

(12)

s=1

=m

r
X

ï£«

m
X

ï£­
s=1

â‰¤ m2

ï£¶2
(Yjs âˆ’ Vjs )ï£¸

j=1

X

(Yjs âˆ’ Vjs )2 = m2 kY âˆ’ V k2 ,

(13)

s,j

where Eq. (12) follows from the Lipschitz continuity of the logarithmic function as discussed
above for Î´ = 1 and Eq. (13) follows from the Cauchy-Schwarz inequality. Similar steps yield
the Lipschitz modulus of B,
X
kB(Y ) âˆ’ B(V )k2 =
(log(|Y | + r) âˆ’ log(|V | + r))2
s,j

= mr(log(|Y | + r) âˆ’ log(|V | + r))2
mr
â‰¤ 2 (|Y | âˆ’ |V |)2
r
ï£¶2
ï£«
m ï£­X
(Yjs âˆ’ Vjs )ï£¸
=
r
s,j
X
â‰¤ m2
(Yjs âˆ’ Vjs )2 .
s,j

We conclude that the Lipschitz moduli of the gradients are given as
Mâˆ‡X G (Y ) = 0

Mâˆ‡Y G (X) = m.

